<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curvature Computation and Visualization of Implicit Surfaces</title>
    <link href="/site/styles/extern/prism-dark.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/site/styles/extern/katex/katex.min.css">
    <link rel="stylesheet" href="/site/styles/extern/github-markdown.css">
    

    <script>
        function openNav() {
            document.getElementById("navigation").style.width = "30%";
            document.getElementById("content").style.marginLeft = "30%";
        }

        function closeNav() {
            document.getElementById("navigation").style.width = "0";
            document.getElementById("content").style.marginLeft = "0";
        }
    </script>

    <link rel="stylesheet" href="/site/styles/post.css">

    

    

<script>
    const App = {
        basePath : "/site/"
    };
</script>

</head>

<body>

    <div id="header">
    </div>

    <div id="navigation">
        <div class="navigationBase">
            <div class="navigationBaseEntry"> <a href="/site/">Home</a></div>
            <div class="navigationBaseEntry"><a href="/site/all_pages/">All pages</a></div>
        </div>
    </div>

    <div id="content">

        <h1>Curvature Visualization of Implicit Surfaces</h1>
<p>The following shows two types of curvature visualizations computed live from the implicit surface definition. Curvature, as the name suggests, measures how much a curve or surface &quot;curves&quot;, meaning diverges from a straight line/plane. You can find a general overview on <a href="https://en.wikipedia.org/wiki/Curvature">Wikipedia</a>.</p>
<p>As Shadertoy embeds don't seem to work anymore, here are screenshots and links to the shaders.</p>
<p><strong>You can find the first shader here: <a href="https://www.shadertoy.com/view/4stSRf">https://www.shadertoy.com/view/4stSRf</a></strong></p>
<p><img class="figure" alt="Image showcasing the first and second principal curvature directions on a torus" src="/site/images/previews/preview_curvature_lines.jpg"></p>
<p>In the second example, the <a href="https://en.wikipedia.org/wiki/Gaussian_curvature">Gaussian curvature</a> is computed from the Hessian and gradient.</p>
<p><strong>You can find the second shader here: <a href="https://www.shadertoy.com/view/Nd3GRS">https://www.shadertoy.com/view/Nd3GRS</a></strong></p>
<p><img class="figure" alt="Image showcasing the Gaussian curvature of an implicit surface encoded in a red/blue/white color scheme." src="/site/images/curvature/gaussian_curvature.png"></p>
<p>The shaders use my automatic differentiation pack for GLSL (<a href="https://github.com/sibaku/glsl-autodiff">https://github.com/sibaku/glsl-autodiff</a>). Basically, this computes derivatives of expressions by wrapping each operation and adding a bit of additional data to each number. The nice thing is, that it is exact minus numerical precision without too much overhead. This is in stark contrast to numerical differentiation, but requires implementing all operations using custom types (much easier in languages with operator overloading).</p>
<p>The first example utilizes a special property of distance fields, where the Hessian matrix is the Shape operator. I won't go into all the details here, but it basically follows from the following: You can get the normal of an implicit surfaces, which distance fields are, by calculating its gradient. Since the gradient points into the direction of largest increase, it will be perpendicular to the surface, as the surface is given as all points for which the implicit function has a specific constant value, usually 0, so the value does not change along the surface, but changes the most if you move straight away from it. For distance fields, the gradient is normalized as well. This also makes sense, because it measures the rate of change. If you move straight away from the surface, your distance to it will also increase by that same amount and that is the value that a distance field measures. In differential geometry, you can define the so called <em>Shape operator</em> as the derivative of the normal field (the function assigning a unit normal to each point). As this is exactly the distance field gradient, its Hessian is the Shape operator. This operator has a few nice properties which are also listed on the Wikipedia article linked above. Here, we use one of those:</p>
<p>Its two non-zero eigenvalues correspond to the principal curvatures (largest and leas curvature) and the corresponding eigenvectors are the directions. One of the eigenvalues is zero, as the normal defines the null-space of the Shape operator. This is used in the first shader. For that, the shader uses a simple iterative algorithm called <a href="https://en.wikipedia.org/wiki/Jacobi_eigenvalue_algorithm">Jacobi Iteration</a>. The curvature directions are then projected onto the screen, so we get a 2D direction. This is then used in the final step to actually display the directions using a simple version of <a href="https://en.wikipedia.org/wiki/Line_integral_convolution">Line integral convolution</a>. It basically steps along a the direction in a random noise texture and accumulates values along the way. As the directions are aligned to the surface, this results in stroke like lines. Due to the random texture, these lines don't have common aliasing or spacing issues, but aren't overly regular, so they have a more painterly look instead of a nice and clean &quot;math&quot; look.</p>
<p>For the second shader, we compute an implicit surface's <a href="https://en.wikipedia.org/wiki/Gaussian_curvature">Gaussian curvature</a>. For distance fields, this would be a bit easier, as the Gaussian curvature is given by the determinant of the hessian. In this shader, we use the general formula for implicit surfaces given <a href="https://en.wikipedia.org/wiki/Gaussian_curvature#Alternative_formulas">here</a>. The nice thing about this value is that it is an &quot;intrinsic&quot; value of the surface, so it is independent of the surrounding space. The second shader colorizes the value of the Gaussian curvature at each point, blue for negative curvature, red for positive, and white for no curvature.</p>


        <div id="footer">

        </div>
    </div>

    <button onclick="topFunction()" id="scrollUpButton" title="Go to top">Top</button>

    <script>
        // Get the button
        let mybutton = document.getElementById("scrollUpButton");

        // When the user scrolls down 20px from the top of the document, show the button
        window.onscroll = function () { scrollFunction() };

        function scrollFunction() {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                mybutton.style.display = "block";
            } else {
                mybutton.style.display = "none";
            }
        }

        // When the user clicks on the button, scroll to the top of the document
        function topFunction() {
            document.body.scrollTop = 0;
            document.documentElement.scrollTop = 0;
        }
    </script>
</body>

</html>