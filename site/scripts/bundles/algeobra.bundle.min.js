var zs=Object.defineProperty,qs=Object.defineProperties;var Bs=Object.getOwnPropertyDescriptors;var ln=Object.getOwnPropertySymbols;var lr=Object.prototype.hasOwnProperty,ar=Object.prototype.propertyIsEnumerable;var ur=u=>{throw TypeError(u)};var kn=(u,t,e)=>t in u?zs(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e,K=(u,t)=>{for(var e in t||(t={}))lr.call(t,e)&&kn(u,e,t[e]);if(ln)for(var e of ln(t))ar.call(t,e)&&kn(u,e,t[e]);return u},an=(u,t)=>qs(u,Bs(t));var fr=(u,t)=>{var e={};for(var n in u)lr.call(u,n)&&t.indexOf(n)<0&&(e[n]=u[n]);if(u!=null&&ln)for(var n of ln(u))t.indexOf(n)<0&&ar.call(u,n)&&(e[n]=u[n]);return e};var ht=(u,t,e)=>kn(u,typeof t!="symbol"?t+"":t,e),Cn=(u,t,e)=>t.has(u)||ur("Cannot "+e);var g=(u,t,e)=>(Cn(u,t,"read from private field"),e?e.call(u):t.get(u)),U=(u,t,e)=>t.has(u)?ur("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(u):t.set(u,e),z=(u,t,e,n)=>(Cn(u,t,"write to private field"),n?n.call(u,e):t.set(u,e),e),D=(u,t,e)=>(Cn(u,t,"access private method"),e);var hr=(u,t,e,n)=>({set _(r){z(u,t,r,e)},get _(){return g(u,t,n)}});function zn(u,t){let e=[[u,t]],n=r=>r&&typeof r=="object"&&!Array.isArray(r);for(;e.length>0;){let[r,s]=e.pop();if(!(!n(r)||!n(s)))for(let i of Object.keys(s)){let c=s[i];n(c)?(r[i]||Object.assign(r,{[i]:{}}),e.push([r[i],c])):Object.assign(r,{[i]:c})}}return u}function Ot(u,t){let e=zn({},u);return zn(e,t)}var L=class u{static vec2(t=0,e=0){return{x:t,y:e}}static new(t=0,e=0){return{x:t,y:e}}static add(t,e){return{x:t.x+e.x,y:t.y+e.y}}static sub(t,e){return{x:t.x-e.x,y:t.y-e.y}}static scale(t,e){return{x:t.x*e,y:t.y*e}}static cwiseMult(t,e){return{x:t.x*e.x,y:t.y*e.y}}static cwiseDiv(t,e){return{x:t.x/e.x,y:t.y/e.y}}static rotate(t,e,n=Math.cos(e),r=Math.sin(e)){return{x:t.x*n-t.y*r,y:t.x*r+t.y*n}}static dot(t,e){return t.x*e.x+t.y*e.y}static len2(t){return t.x*t.x+t.y*t.y}static len(t){return Math.sqrt(t.x*t.x+t.y*t.y)}static polar(t,e){return{x:t*Math.cos(e),y:t*Math.sin(e)}}static normalize(t){return u.scale(t,1/u.len(t))}static normalizeIfNotZero(t,e=1e-10){let n=u.len2(t);return n>e&&(t=u.scale(t,1/Math.sqrt(n))),t}static lerp(t,e,n){let r=1-n;return u.add(u.scale(t,r),u.scale(e,n))}static normal2D(t){return{x:-t.y,y:t.x}}},{vec2:vt,add:q,sub:I,scale:R,cwiseMult:ls,cwiseDiv:$s,rotate:de,dot:pe,len2:Wt,len:An,polar:Dt,normalize:Hs,normalizeIfNotZero:ze,lerp:yt,normal2D:gt}=L,qn=class u{static num(t=0,e=0){return[t,e]}static add(t,e){return[t[0]+e[0],t[1]+e[1]]}static sub(t,e){return[t[0]-e[0],t[1]-e[1]]}static mult(t,e){return[t[0]*e[0]-t[1]*e[1],t[0]*e[1]+t[1]*e[0]]}static div(t,e){let[n,r]=t,[s,i]=e,c=s*s+i*i;return[(n*s+r*i)/c,(r*s-n*i)/c]}static conj(t){return[t[0],-t[1]]}static neg(t){return[-t[0],-t[1]]}static abs(t){let[e,n]=t;return Math.sqrt(e*e+n*n)}static abs2(t){let[e,n]=t;return e*e+n*n}static equals(t,e,n=1e-10){return u.abs(u.sub(t,e))<n}static real(t){return t[0]}static imag(t){return t[1]}static sqrt(t){let e=u.abs(t),[n,r]=t,s=r<0?-1:1;return u.num(Math.sqrt((e+n)*.5),s*Math.sqrt((e-n)*.5))}},{num:et,add:un,sub:Ct,mult:qt,div:Bn,conj:as,neg:pr,abs:Un,abs2:_s,equals:Nn,real:ne,imag:Ht,sqrt:Ft}=qn,$n=class u{static solveLinear(t,e,n=1e-10){return Math.abs(t)<n?[]:[-e/t]}static solveQuadratic(t,e,n,r=1e-10){if(Math.abs(t)<r)return u.solveLinear(e,n,r);let s=e*e-4*t*n;if(s<-r)return[];if(s=Math.max(0,s),s<r)return[-e/(2*t)];let i=Math.sqrt(s);return[(-e+i)/(2*t),(-e-i)/(2*t)]}static solveQuadraticComplex(t,e,n,r=1e-10){if(Math.abs(t)<r)return u.solveLinear(e,n,r).map(c=>et(c));let s=e*e-4*t*n;if(s<-r){let c=e/(2*t),l=-c,o=Math.sqrt(Math.abs(c*c-n/t));return[et(l,o),et(l,-o)]}if(s=Math.max(0,s),Math.abs(s)<r)return[et(-e/(2*t))];let i=Math.sqrt(s);return[(-e+i)/(2*t),(-e-i)/(2*t)]}static solveCubicComplex(t,e,n,r,s=1e-10){if(Math.abs(t)<s)return u.solveQuadraticComplex(e,n,r,s);let i=e/t,c=n/t,l=r/t,o=c-i*i/3,a=2*i*i*i/27-i*c/3+l,f=o*o*o/27+a*a/4;if(f>s){let M=Math.sqrt(f),P=Math.cbrt(-a/2+M),T=Math.cbrt(-a/2-M),k=P+T,B=et(k-i/3),V=et(-(P+T)/2-i/3,Math.sqrt(3)/2*(P-T)),Y=as(V);return[B,V,Y]}if(Math.abs(f)<s){let M=Math.cbrt(-a/2),P=M,T=M+P,k=-(M+P)*.5,B=et(T-i/3),V=et(k-i/3);return[B,V,V]}f=Math.min(f,0);let h=Math.sqrt(-o*o*o/27),p=Math.sqrt(-f),m=Math.atan2(p,-a/2),w=Math.cbrt(h),A=w*(Math.cos(m/3)+Math.cos((6*Math.PI-m)/3))-i/3,x=w*(Math.cos((2*Math.PI+m)/3)+Math.cos((4*Math.PI-m)/3))-i/3,v=w*(Math.cos((4*Math.PI+m)/3)+Math.cos((2*Math.PI-m)/3))-i/3;return[et(A),et(x),et(v)]}static solveBiquadraticQuarticComplex(t,e,n=1e-10){let r=et(t*t-4*e),s=Ft(qt(un(et(-t),Ft(r)),et(.5))),i=Ft(qt(Ct(et(-t),Ft(r)),et(.5)));return[s,pr(s),i,pr(i)]}static solveDepressedQuarticComplex(t,e,n,r=1e-10){let s=f=>Math.abs(f)<r?0:f;if(t=s(t),e=s(e),n=s(n),t===0&&e===0&&n===0)return[et(0),et(0),et(0),et(0)];if(Math.abs(e)<r)return u.solveBiquadraticQuarticComplex(t,n,r);let i=[],c=0,l=et(0),o=0;i=u.solveCubicComplex(1,2*t,t*t-4*n,-e*e,r);for(let f of i){let h=Un(f);h>r&&h>o&&(c=Bn(et(-2*e),Ft(f)),l=f,o=h)}let a=[];{let f=et(1),h=Ct(Ct(qt(f,c),et(2*t)),l),p=qt(f,Ft(l)),m=un(p,Ft(h));m=qt(m,et(.5));let w=Ct(p,Ft(h));w=qt(w,et(.5)),a.push(m,w)}{let f=et(-1),h=Ct(Ct(qt(f,c),et(2*t)),l),p=qt(f,Ft(l)),m=un(p,Ft(h));m=qt(m,et(.5));let w=Ct(p,Ft(h));w=qt(w,et(.5)),a.push(m,w)}return a}static solveQuarticComplex(t,e,n,r,s,i=1e-10){if(Math.abs(t)<i)return u.solveCubicComplex(e,n,r,s,i);let c=(8*t*n-3*e*e)/(8*t*t),l=(e*e*e-4*t*e*n+8*t*t*r)/(8*t*t*t),o=(16*t*e*e*n-64*t*t*e*r-3*e*e*e*e+256*t*t*t*s)/(256*t*t*t*t),a=u.solveDepressedQuarticComplex(c,l,o,i),f=[];for(let h of a)f.push(Ct(h,et(e/(4*t))));return f}},{solveLinear:mr,solveQuadratic:Je,solveCubicComplex:pn,solveBiquadraticQuarticComplex:to,solveDepressedQuarticComplex:eo,solveQuarticComplex:Ce}=$n,it="boolean",G="number",Me="angle",O="point",Xe="polar",$="vector",ee="coordSystem",Q="line",ut="lineStrip",ot="polygon",J="arc",ct="ellipse",pt="bezier",mt="bezSpline",En="text",jn="collection",us="val",X=Object.create({}),b=Object.create({type:"NONE"});function dr(u){return u!==X}function S(u){return u===b}function C(...u){for(let t of u)if(!t||S(t))throw new Error(`Expected existing parameter, got ${JSON.stringify(t)}`)}var E=class u{constructor(t,e={},n={},r=!1){this.name=t,this.dependencies=e,this.params=n,this.ignoreInvalids=r}static new(t,e={},n={},r=!1){return new u(t,e,n,r)}},dt=new E("empty_info");function yr(u,t,e=1e-10){let n=t.length-1;if(n<1)return[];let r=[],s=[],i=l=>l.filter(o=>Math.abs(Ht(o))<e).map(o=>ne(o));if(n===1){let[l,o]=t,a=I(o-l),f=l,h=mr(a.x,f.x-u.x,e),p=mr(a.y,f.y-u.y,e);r=h,s=p}else if(n===2){let[l,o,a]=Qe(...t),f=Je(a.x,o.x,l.x-u.x),h=Je(a.y,o.y,l.y-u.y);r=f,s=h}else if(n===3){let[l,o,a,f]=ps(...t),h=pn(f.x,a.x,o.x,l.x-u.x),p=pn(f.y,a.y,o.y,l.y-u.y);r=i(h),s=i(p)}else if(n===4){let[l,o,a,f,h]=ms(...t),p=Ce(h.x,f.x,a.x,o.x,l.x-u.x),m=Ce(h.y,f.y,a.y,o.y,l.y-u.y);r=i(p),s=i(m)}let c=[];for(let l of r)for(let o of s)Math.abs(l-o)<e&&l>=0&&l<=1&&c.push(l);return c}function mn(u){let t=[],e=u.length-1;for(let n=0;n<e;n++)t.push(R(I(u[n+1],u[n]),e));return t}function Ne(u,t){u=[...u];let e=u.length-1;for(let n=1;n<=e;n++)for(let r=0;r<=e-n;r++)u[r]=yt(u[r],u[r+1],t);return u[0]}function Rn(u,t){if(u=[...u],u.length===1)return{left:u,right:u};let e=[u[0]],n=[u[u.length-1]],r=u.length-1;for(let s=1;s<=r;s++){for(let i=0;i<=r-s;i++)u[i]=yt(u[i],u[i+1],t);e.push(u[0]),n.push(u[r-s])}return{left:e,right:n.reverse()}}function no(u,t,e){({left:u}=Rn(u,e));let n=t/e;return{right:u}=Rn(u,n),u}function Gn(u,t=1){if(u.length<3)return u;let e=[[u,0,1]],n=[u[0]],r=t*t;for(;e.length>0;){let[s,i,c]=e.pop(),l=s[0],o=s[s.length-1],a=L.sub(o,l),f=L.normalizeIfNotZero(a),h=!0;for(let p=1;p<s.length-1;p++){let m=s[p],w=L.sub(m,l),A=L.dot(w,a);if(A<0||A>1){h=!1;break}if(L.len2(w)-A*A>r){h=!1;break}}if(h)n.push(o);else{let p=(i+c)*.5,{left:m,right:w}=Rn(s,p);e.push([w,p,c]),e.push([m,i,p])}}return n}function Re(u=!1){return{value:u,type:it}}function ye(u=0){return{value:u,type:G}}function N(n={}){var r=n,{x:u=0,y:t=0}=r,e=fr(r,["x","y"]);return an(K({x:u,y:t},e),{type:O})}function fs({r:u=1,alpha:t=0}={}){return{r:u,alpha:t,type:Xe}}function Rt({x:u=0,y:t=0,ref:e={x:0,y:0}}={}){return{x:u,y:t,ref:e,type:$}}function gr(u,t,e){return{origin:u,u:t,v:e,type:ee}}function We({value:u=0,start:t=0,ref:e={x:0,y:0}}={}){return u=at(u),t=at(t),{value:u,start:t,ref:e,type:Me}}function Xt({p0:u={x:0,y:0},p1:t={x:0,y:0},leftOpen:e=!1,rightOpen:n=!1}={}){return{p0:u,p1:t,leftOpen:e,rightOpen:n,type:Q}}function Jn({points:u=[]}={}){return{points:u,type:ut}}function Qn({points:u=[]}={}){return{points:u,type:ot}}function Zn({points:u=[]}={}){return{points:u,degree:u.length-1,type:pt}}function Kn({points:u,degree:t}={}){return{points:u,degree:t,type:mt}}function ue({r:u=1,startAngle:t=0,endAngle:e=2*Math.PI,center:n={x:0,y:0}}={}){return{r:u,startAngle:t,endAngle:e,center:n,type:J}}function Xn({center:u={x:0,y:0},rx:t=1,ry:e=1,startAngle:n=0,endAngle:r=2*Math.PI,rotation:s=0}){return{center:u,rx:t,ry:e,startAngle:n,endAngle:r,rotation:s,type:ct}}function Rs({text:u="",ref:t={x:0,y:0}}={}){return{text:u,ref:t,type:En}}function ro(u,t){return Array.isArray(u)||(u=[u]),t&&!Array.isArray(t)&&(t=[t]),{objects:u,properties:t,type:jn}}function Ds(u){return{value:u,type:us}}function hs(u,{maxDecimals:t=2,formatter:e=new Intl.NumberFormat("en-US",{minimumFractionDigits:0,maximumFractionDigits:t})}={}){if(Array.isArray(u))return`[${u.map(n=>hs(n)).join(", ")}]`;if(u===b)return"Empty";if(u===X)return"Invalid";if(u.type===it)return`${u.value}`;if(u.type===G)return e.format(u.value);if(u.type===O)return`Point(${e.format(u.x)}, ${e.format(u.y)})`;if(u.type===$)return`Vector(${e.format(u.x)}, ${e.format(u.y)})`;if(u.type===Me)return`Angle(${e.format(ke(u.value))}\xB0)`;if(u.type===Q){let n=u.leftOpen?"(":"[",r=u.rightOpen?")":"]",{p0:s,p1:i}=u;return`Line${n} (${e.format(s.x)}, ${e.format(s.y)}), (${e.format(i.x)}, ${e.format(i.y)})${r} `}else if(u.type===J){let{center:n,r,startAngle:s,endAngle:i}=u;return s=ke(s),i=ke(i),`Arc(${e.format(r)}, (${e.format(n.x)}, ${e.format(n.y)}), ${e.format(s)}\xB0,${e.format(i)}\xB0)`}else{if(u.type===En)return e.format(u.text);if(u.type===us)return u.value.toString()}return u.toString()}function at(u){let t=2*Math.PI;return Math.min(t,Math.max(0,u-t*Math.floor(u/t)))}function $t(u,t){return at(Math.atan2(t,u))}function so(u){return u.type===Q&&u.leftOpen&&u.rightOpen}function oo(u){return u.type===Q&&(u.leftOpen&&!u.rightOpen||!u.leftOpen&&u.rightOpen)}function io(u){return u.type===Q&&!u.leftOpen&&!u.rightOpen}function wr(u,t){return Math.min(at(u-t),at(t-u))}function ve(u,t){let{x:e,y:n}=u,{x:r,y:s}=t,i=Math.atan2(s,r)-Math.atan2(n,e);return i=at(i),i}function co(u){return Math.PI*u/180}function ke(u){return 180*u/Math.PI}function Yt(u,t,e,n,r,s=!1){let i=Math.cos(-e),c=Math.sin(-e);return s||(u=u.map(l=>I(l,t))),u=u.map(l=>de(l,-e,i,c)),u=u.map(l=>$s(l,vt(n,r))),u}function Kt(u,t,e,n,r,s=!1){let i=Math.cos(e),c=Math.sin(e);return u=u.map(l=>ls(l,vt(n,r))),u=u.map(l=>de(l,e,i,c)),s||(u=u.map(l=>q(l,t))),u}function Fs(u,t=1e-10){let e=[];for(let n=0;n<u.length;n++){let r=u[n];if(e.length>1){let s=e[e.length-2],i=e[e.length-1],c=I(i,s),l=I(r,i),o=c.x*l.y-c.y*l.x;Math.abs(o)<t?e[e.length-1]=r:e.push(r)}else e.push(r)}return e}function Vs(u,{isPolygon:t=!1,eps:e=1e-10}={}){if(u.length===0)return[];let n=[u[0]];for(let r=1;r<u.length;r++){let s=u[r],i=n[n.length-1],c=I(i,s);L.len2(c)>e&&n.push(s)}if(t&&n.length>1){let r=n[n.length-1],s=n[0],i=I(s,r);L.len2(i)<e&&n.pop()}return n}function Ys(u){if(u.length<4)return u;let t=0,e=u[0].y;for(let s=1;s<u.length;s++){let i=u[s];i.y<e&&(e=i.y,t=s)}let n=[u[t]],r=t;do{let s=1/0,i=-1,c;n.length===1?c={x:1,y:0}:c=I(n[n.length-1],n[n.length-2]);let l=n[n.length-1];for(let a=0;a<u.length;a++){if(a===r)continue;let f=I(u[a],l);if(Wt(f)<1e-10)continue;let h=ve(c,f);h<s&&(s=h,i=a)}let o=u[i];n.push(o),r=i}while(r!==t);return Vs(Fs(n),{isPolygon:!0})}function Tt(u,t,e,n,{minA:r=-1/0,maxA:s=1/0,minB:i=-1/0,maxB:c=1/0,eps:l=1e-10}={}){let{x:o,y:a}=u,{x:f,y:h}=t,{x:p,y:m}=e,{x:w,y:A}=n,x=(A-m)*(f-o)-(w-p)*(h-a);if(Math.abs(x)<l)return null;let v=((w-p)*(a-m)-(A-m)*(o-p))/x,M=((f-o)*(a-m)-(h-a)*(o-p))/x;if(v<r||v>s||M<i||M>c)return null;let P=o+v*(f-o),T=a+v*(h-a);return{x:P,y:T,ua:v,ub:M}}function Qe(u,t,e){let n=q(I(u,R(t,2)),e),r=I(R(t,2),R(u,2));return[u,r,n]}function ps(u,t,e,n){let r=u,s=R(I(u,t),-3),i=R(I(q(u,e),R(t,2)),3),c=q(I(n,u),R(I(t,e),3));return[r,s,i,c]}function ms(u,t,e,n,r){let s=u,i=R(I(t,u),4),c=R(I(q(u,e),R(t,2)),6),l=R(q(I(n,u),R(I(t,e),3)),4),o=I(q(q(u,r),R(e,6)),R(q(t,n),4));return[s,i,c,l,o]}function Ws(u,t,{eps:e=1e-10}={}){let[n,r,s]=Qe(...u),[i,c,l]=Qe(...t),{x:o,y:a}=s,{x:f,y:h}=r,{x:p,y:m}=n,{x:w,y:A}=l,{x,y:v}=c,{x:M,y:P}=i,T=Math.pow(o,2)*Math.pow(A,2)-2*o*a*w*A+Math.pow(a,2)*Math.pow(w,2),k=2*Math.pow(o,2)*v*A-2*o*a*x*A-2*o*a*w*v+2*Math.pow(a,2)*x*w,B=2*p*o*a*A-2*p*Math.pow(a,2)*w-Math.pow(f,2)*a*A+f*o*h*A+f*h*a*w-2*Math.pow(o,2)*m*A+2*Math.pow(o,2)*P*A+Math.pow(o,2)*Math.pow(v,2)+2*o*m*a*w-o*Math.pow(h,2)*w-2*o*a*M*A-2*o*a*x*v-2*o*a*w*P+2*Math.pow(a,2)*M*w+Math.pow(a,2)*Math.pow(x,2),V=2*p*o*a*v-2*p*Math.pow(a,2)*x-Math.pow(f,2)*a*v+f*o*h*v+f*h*a*x-2*Math.pow(o,2)*m*v+2*Math.pow(o,2)*P*v+2*o*m*a*x-o*Math.pow(h,2)*x-2*o*a*M*v-2*o*a*x*P+2*Math.pow(a,2)*M*x,Y=Math.pow(p,2)*Math.pow(a,2)-p*f*h*a-2*p*o*m*a+p*o*Math.pow(h,2)+2*p*o*a*P-2*p*Math.pow(a,2)*M+Math.pow(f,2)*m*a-Math.pow(f,2)*a*P-f*o*m*h+f*o*h*P+f*h*a*M+Math.pow(o,2)*Math.pow(m,2)-2*Math.pow(o,2)*m*P+Math.pow(o,2)*Math.pow(P,2)+2*o*m*a*M-o*Math.pow(h,2)*M-2*o*a*M*P+Math.pow(a,2)*Math.pow(M,2),j=Ce(T,k,B,V,Y),W=[];for(let nt of j){if(Math.abs(Ht(nt))>e)continue;let Z=ne(nt);if(Z<0||Z>1)continue;let st=q(R(l,Z*Z),q(R(c,Z),i));{let xt=Je(s.x,r.x,n.x-st.x,e*2),zt=Je(s.y,r.y,n.y-st.y,e*2);if(xt.sort(),zt.sort(),xt.length<1||zt.length<1)continue;let ft=-1,Et=1/0;for(let ae=0;ae<xt.length;ae++){let sn=xt[ae];for(let jt=0;jt<zt.length;jt++){let on=zt[jt],cn=Math.abs(sn-on);cn<Et&&(ft=sn,Et=cn)}}if(Et>2*e||ft<0||ft>1)continue}W.push(st)}return W}function In(u,t,{eps:e=1e-10}={}){t.length>u.length&&([u,t]=[t,u]);let n=u.length-1,r=t.length-1;if(n===3||n===4){if(r===1)return Gt(t[0],t[1],u,{minA:0,maxA:1,eps:e})}else if(n===2){if(r===2)return Ws(u,t,{eps:e});if(r===1)return Gt(t[0],t[1],u,{minA:0,maxA:1,eps:e})}else if(n===1&&r===1)return Tt(u[0],u[1],t[0],t[1],{minA:0,maxA:1,minB:0,maxB:1,eps:e});throw new Error(`Intersection between degrees ${n} and ${r} not supported`)}function Mt(u,t,{wrapPoints:e=!1}={}){let n=[],r=e?t.length:t.length-1;for(let s=0;s<r;s++){let i=t[s],c=t[(s+1)%t.length],l=u(i,c);l&&(Array.isArray(l)?n.push(...l):n.push(l))}return n}function Us(u,t){let e=I(t,u),n=gt(e),r=-pe(u,n);return[n.x,n.y,r]}function me(u,t,e){let n=I(t,u),r=I(e,u),s=pe(n,r),i=Wt(n);return s/i}function Gt(u,t,e,{minA:n=-1/0,maxA:r=1/0,eps:s=1e-10}={}){if(e.length===0)return[];let i=Us(u,t);if(e.length===1){let[c]=e,l=i[0]*c.x+i[1]*c.y+i[2];if(Math.abs(l)<s){let o=me(u,t,c);return o<n||o>r?[]:c}else return[]}else if(e.length===2){let[c,l]=e;return Tt(u,t,c,l,{minA:n,maxA:r,minB:0,maxB:1})}else if(e.length===3){let[c,l,o]=e,a=q(I(c,R(l,2)),o),f=I(R(l,2),R(c,2)),h=c,[p,m,w]=i,A=p*a.x+m*a.y,x=p*f.x+m*f.y,v=p*h.x+m*h.y+w,M=Je(A,x,v),P=[];for(let T of M){if(T<0||T>1)continue;let k=q(R(a,T*T),q(R(f,T),h)),B=me(u,t,k);B<n||B>r||P.push(k)}return P}else if(e.length===4){let[c,l,o,a]=ps(...e),[f,h,p]=i,{x:m,y:w}=c,{x:A,y:x}=l,{x:v,y:M}=o,{x:P,y:T}=a,k=m*f+w*h+p,B=A*f+x*h,V=v*f+M*h,Y=P*f+T*h,j=pn(Y,V,B,k,s),W=[];for(let nt of j){if(Math.abs(Ht(nt))>s)continue;let Z=ne(nt);if(Z<0||Z>1)continue;let st=a;st=q(R(st,Z),o),st=q(R(st,Z),l),st=q(R(st,Z),c);let xt=me(u,t,st);xt<n||xt>r||W.push(st)}return W}else if(e.length===5){let[c,l,o,a,f]=ms(...e),[h,p,m]=i,{x:w,y:A}=c,{x,y:v}=l,{x:M,y:P}=o,{x:T,y:k}=a,{x:B,y:V}=f,Y=w*h+A*p+m,j=x*h+v*p,W=M*h+P*p,nt=T*h+k*p,Z=B*h+V*p,st=Ce(Z,nt,W,j,Y,s),xt=[];for(let zt of st){if(Math.abs(Ht(zt))>s)continue;let ft=ne(zt);if(ft<0||ft>1)continue;let Et=f;Et=q(R(Et,ft),a),Et=q(R(Et,ft),o),Et=q(R(Et,ft),l),Et=q(R(Et,ft),c);let ae=me(u,t,Et);ae<n||ae>r||xt.push(Et)}return xt}else throw new Error(`Intersection with bezier only defined up to degree 3, got ${e.length-1}`)}function xr(u,t,e,{angleMin:n=0,angleMax:r=2*Math.PI,eps:s=1e-10}={}){if(e.length===0)return[];if(e.length===1){let[i]=e;if(Math.abs(d)<s){let c=I(i,u),l=Wt(c);return Math.abs(l-t*t)<s?[]:i}else return[]}else if(e.length===2){let[i,c]=e;return De(i,c,u,t,{minA:0,maxA:1,angleMin:n,angleMax:r,eps:s})}else if(e.length===3){let[i,c,l]=e;i=I(i,u),c=I(c,u),l=I(l,u);let[o,a,f]=Qe(i,c,l),{x:h,y:p}=o,{x:m,y:w}=a,{x:A,y:x}=f,v=h*h+p*p-t*t,M=2*h*m+2*p*w,P=2*h*A+m*m+2*p*x+w*w,T=2*m*A+2*w*x,k=A*A+x*x,B=Ce(k,T,P,M,v,s),V=[];for(let j=0;j<B.length;j++){let W=B[j],nt=!1;for(let Z=j+1;Z<B.length;Z++){let st=B[Z];if(Un(Ct(W,Z))<s){nt=!0;break}}nt||V.push(W)}let Y=[];for(let j of V){if(Math.abs(Ht(j))>s)continue;let W=ne(j);if(W<0||W>1)continue;let nt=q(R(f,W*W),q(R(a,W),o)),Z=$t(nt.x,nt.y);Ie(Z,n,r)&&Y.push(q(nt,u))}return Y}else throw new Error(`Intersection with bezier only defined up to degree 2, got ${e.length-1}`)}function De(u,t,e,n,{minA:r=-1/0,maxA:s=1/0,angleMin:i=0,angleMax:c=2*Math.PI,eps:l=1e-10}={}){i=at(i),c=at(c);let{x:o,y:a}=u,f=t.x-u.x,h=t.y-u.y,{x:p,y:m}=e,w=f*f+h*h,A=o-p,x=a-m,v=f*A+h*x,M=A*A+x*x,P=v*v-w*(M-n*n);if(P<-l)return[];if(P=Math.max(0,P),P<l){let Y=-v/w;if(Y<r||Y>s)return[];let j=o+Y*f,W=a+Y*h,nt=$t(j-p,W-m);return Ie(nt,i,c)?[{x:j,y:W}]:[]}let T=(-v+Math.sqrt(P))/w,k=(-v-Math.sqrt(P))/w;k<T&&([T,k]=[k,T]);let B=[];T>=r&&T<s&&B.push({x:o+T*f,y:a+T*h}),k>=r&&k<s&&B.push({x:o+k*f,y:a+k*h});let V=[];for(let Y=0;Y<B.length;Y++){let j=B[Y],W=$t(j.x-p,j.y-m);Ie(W,i,c)&&V.push(j)}return V}function Fe(u,t,e){let n=at(Math.atan2(u.y,u.x));return Ie(n,t,e)}function Ie(u,t,e){return t<e?u>=t&&u<=e:u>=t||u<=e}function ds(u,t,e,n,{angleMinA:r=0,angleMaxA:s=2*Math.PI,angleMinB:i=0,angleMaxB:c=2*Math.PI,eps:l=1e-10}={}){let o=u,a=e,f=a.x-o.x,h=a.y-o.y,p=f*f+h*h,m=n+t,w=n-t;if(p>m*m)return[];if(p<w*w)return[];let A=Math.sqrt(p),x=(t*t-n*n+p)/(2*A),v=o.x+x*f/A,M=o.y+x*h/A,P=t*t-x*x,T={x:v,y:M},k=at(r),B=at(s),V=at(i),Y=at(c);if(Math.abs(P)<l)return Fe({x:T.x-o.x,y:T.y-o.y},k,B)&&Fe({x:T.x-a.x,y:T.y-a.y},V,Y)?[T]:[];let j=Math.sqrt(P),W=[];W.push({x:v+j*h/A,y:M-j*f/A}),W.push({x:v-j*h/A,y:M+j*f/A});let nt=[];for(let Z=0;Z<W.length;Z++){let st=W[Z];Fe({x:st.x-o.x,y:st.y-o.y},k,B)&&Fe({x:st.x-a.x,y:st.y-a.y},V,Y)&&nt.push(st)}return nt}function vr(u,t,{eps:e=1e-10}={}){let{rx:n,ry:r,center:s,rotation:i}=u,{x:c,y:l}=s,{rx:o,ry:a,center:f,rotation:h}=t,{x:p,y:m}=f,w=Math.cos,A=Math.sin,x=w(2*h),v=A(2*h),M=w(i),P=A(i),T=w(i-2*h),k=A(i-2*h),B=w(2*i-2*h),V=A(2*i-2*h),Y=-c*c*o*o*x/2+c*c*o*o/2+c*c*a*a*x/2+c*c*a*a/2-c*l*o*o*v+c*l*a*a*v+c*p*o*o*x-c*p*o*o-c*p*a*a*x-c*p*a*a+c*m*o*o*v-c*m*a*a*v+c*n*o*o*M-c*n*o*o*T+c*n*a*a*M+c*n*a*a*T+l*l*o*o*x/2+l*l*o*o/2-l*l*a*a*x/2+l*l*a*a/2+l*p*o*o*v-l*p*a*a*v-l*m*o*o*x-l*m*o*o+l*m*a*a*x-l*m*a*a+l*n*o*o*P+l*n*o*o*k+l*n*a*a*P-l*n*a*a*k-p*p*o*o*x/2+p*p*o*o/2+p*p*a*a*x/2+p*p*a*a/2-p*m*o*o*v+p*m*a*a*v-p*n*o*o*M+p*n*o*o*T-p*n*a*a*M-p*n*a*a*T+m*m*o*o*x/2+m*m*o*o/2-m*m*a*a*x/2+m*m*a*a/2-m*n*o*o*P-m*n*o*o*k-m*n*a*a*P+m*n*a*a*k-n*n*o*o*B/2+n*n*o*o/2+n*n*a*a*B/2+n*n*a*a/2-o*o*a*a,j=2*r*(-c*o*o*P+c*o*o*k-c*a*a*P-c*a*a*k+l*o*o*M+l*o*o*T+l*a*a*M-l*a*a*T+p*o*o*P-p*o*o*k+p*a*a*P+p*a*a*k-m*o*o*M-m*o*o*T-m*a*a*M+m*a*a*T+n*o*o*V-n*a*a*V),W=-c*c*o*o*x+c*c*o*o+c*c*a*a*x+c*c*a*a-2*c*l*o*o*v+2*c*l*a*a*v+2*c*p*o*o*x-2*c*p*o*o-2*c*p*a*a*x-2*c*p*a*a+2*c*m*o*o*v-2*c*m*a*a*v+l*l*o*o*x+l*l*o*o-l*l*a*a*x+l*l*a*a+2*l*p*o*o*v-2*l*p*a*a*v-2*l*m*o*o*x-2*l*m*o*o+2*l*m*a*a*x-2*l*m*a*a-p*p*o*o*x+p*p*o*o+p*p*a*a*x+p*p*a*a-2*p*m*o*o*v+2*p*m*a*a*v+m*m*o*o*x+m*m*o*o-m*m*a*a*x+m*m*a*a+n*n*o*o*B-n*n*o*o-n*n*a*a*B-n*n*a*a+2*r*r*o*o*B+2*r*r*o*o-2*r*r*a*a*B+2*r*r*a*a-2*o*o*a*a,nt=2*r*(-c*o*o*P+c*o*o*k-c*a*a*P-c*a*a*k+l*o*o*M+l*o*o*T+l*a*a*M-l*a*a*T+p*o*o*P-p*o*o*k+p*a*a*P+p*a*a*k-m*o*o*M-m*o*o*T-m*a*a*M+m*a*a*T-n*o*o*V+n*a*a*V),Z=-c*c*o*o*x/2+c*c*o*o/2+c*c*a*a*x/2+c*c*a*a/2-c*l*o*o*v+c*l*a*a*v+c*p*o*o*x-c*p*o*o-c*p*a*a*x-c*p*a*a+c*m*o*o*v-c*m*a*a*v-c*n*o*o*M+c*n*o*o*T-c*n*a*a*M-c*n*a*a*T+l*l*o*o*x/2+l*l*o*o/2-l*l*a*a*x/2+l*l*a*a/2+l*p*o*o*v-l*p*a*a*v-l*m*o*o*x-l*m*o*o+l*m*a*a*x-l*m*a*a-l*n*o*o*P-l*n*o*o*k-l*n*a*a*P+l*n*a*a*k-p*p*o*o*x/2+p*p*o*o/2+p*p*a*a*x/2+p*p*a*a/2-p*m*o*o*v+p*m*a*a*v+p*n*o*o*M-p*n*o*o*T+p*n*a*a*M+p*n*a*a*T+m*m*o*o*x/2+m*m*o*o/2-m*m*a*a*x/2+m*m*a*a/2+m*n*o*o*P+m*n*o*o*k+m*n*a*a*P-m*n*a*a*k-n*n*o*o*B/2+n*n*o*o/2+n*n*a*a*B/2+n*n*a*a/2-o*o*a*a,st=Ce(Z,nt,W,j,Y),xt=[];for(let zt of st){if(Math.abs(Ht(zt))>e)continue;let ft=ne(zt),Et=Math.atan(ft)*2;if(!Ie(at(Et),u.startAngle,u.endAngle))continue;let ae=(1-ft*ft)/(1+ft*ft),sn=2*ft/(1+ft*ft),jt=ls(vt(n,r),vt(ae,sn));jt=de(jt,i),jt=q(jt,s);let[on]=Yt([jt],f,h,o,a),cn=$t(on.x,on.y);Ie(cn,t.startAngle,t.endAngle)&&xt.push(jt)}return xt}function dn(u,t,e,{angleMin:n=0,angleMax:r=2*Math.PI,eps:s=1e-10}={}){let i=Wt(I(u,t))-e*e,c=Math.sqrt(i);return ds(t,e,u,c,{angleMinA:n,angleMaxA:r,eps:s})}function yn(u,t){let e=I(u,t.center);return Fe({x:e.x,y:e.y},t.startAngle,t.endAngle)}function ys(u,t,{eps:e=1e-10}={}){let n=!1;t.r>u.r&&([u,t]=[t,u],n=!0);let r=I(t.center,u.center),s=An(r),c=(u.r-t.r)/s;if(Math.abs(c)>1+e)return[];c=Math.min(1,Math.max(-1,c));let l=Math.acos(c),o=Math.atan2(r.y,r.x),a=o+l,f=o-l,h=Dt(1,a),p=Dt(1,f),m=[];m.push(q(R(h,u.r),u.center)),m.push(q(R(h,t.r),t.center)),m.push(q(R(p,u.r),u.center)),m.push(q(R(p,t.r),t.center));let w=[];for(let A=0;A<m.length;A+=2){let x=m[A+0],v=m[A+1];!yn(x,u)||!yn(v,t)||(n&&([x,v]=[v,x]),w.push(x,v))}return w}function gs(u,t,{eps:e=1e-10}={}){let n=!1;t.r>u.r&&([u,t]=[t,u],n=!0);let r=I(t.center,u.center),s=An(r),i=u.r+t.r,c=Math.atan2(r.y,r.x),l=i/s;if(Math.abs(l)>1+e)return[];l=Math.min(1,Math.max(-1,l));let o=Math.asin(l)-Math.PI/2,a=c+o,f=c-o,h=Dt(1,a),p=Dt(1,f),m=[];m.push(q(R(h,u.r),u.center)),m.push(q(R(Dt(1,a+Math.PI),t.r),t.center)),m.push(q(R(p,u.r),u.center)),m.push(q(R(Dt(1,f+Math.PI),t.r),t.center));let w=[];for(let A=0;A<m.length;A+=2){let x=m[A+0],v=m[A+1];!yn(x,u)||!yn(v,t)||(n&&([x,v]=[v,x]),w.push(x,v))}return w}function Mn(u,t){if((u.length-(t+1))%t!==0)throw new Error("Wrong number of input points");return t===1?u.length-1:Math.floor(u.length/t)}function Pn(u,t,e){if((u.length-(t+1))%t!==0)throw new Error("Wrong number of input points");let n=e*t,r=new Array(t+1);for(let s=0;s<=t;s++)r[s]=u[n+s];return r}var F=class F{static setIntersector(t,e,n,r=!0){var i,c;let s=(i=F.intersectors[t])!=null?i:{};if(s[e]=n,F.intersectors[t]=s,t!==e&&r){let l=(a,f)=>n(f,a),o=(c=F.intersectors[e])!=null?c:{};o[t]=l,F.intersectors[e]=o}}static getIntersector(t,e){var r;return((r=F.intersectors[t])!=null?r:{})[e]}static intersect(t,e){let n=t.type,r=e.type;return F.getIntersector(n,r)(t,e)}};ht(F,"intersectors",{}),F.setIntersector(Q,Q,(t,e)=>{let n=Tt(t.p0,t.p1,e.p0,e.p1,{minA:t.leftOpen?-1/0:0,maxA:t.rightOpen?1/0:1,minB:e.leftOpen?-1/0:0,maxB:e.rightOpen?1/0:1});return n?N(K({},n)):null}),F.setIntersector($,Q,(t,e)=>{let n=q(t.ref,t),r=Tt(t.ref,n,e.p0,e.p1,{minA:0,maxA:1,minB:e.leftOpen?-1/0:0,maxB:e.rightOpen?1/0:1});return r?N(K({},r)):null}),F.setIntersector($,$,(t,e)=>{let n=q(t.ref,t),r=q(e.ref,e),s=Tt(t.ref,n,e.ref,r,{minA:0,maxA:1,minB:0,maxB:1});return s?N(K({},s)):null}),F.setIntersector(J,Q,(t,e)=>{let n=De(e.p0,e.p1,{x:t.center.x,y:t.center.y},t.r,{minA:e.leftOpen?-1/0:0,maxA:e.rightOpen?1/0:1,angleMin:t.startAngle,angleMax:t.endAngle}),r=[];for(let s=0;s<n.length;s++)r.push(N(K({},n[s])));return r}),F.setIntersector(J,$,(t,e)=>{let n=q(e.ref,e);return De(e.ref,n,t.center,t.r,{minA:0,maxA:1,angleMin:t.startAngle,angleMax:t.endAngle}).map(s=>N(K({},s)))}),F.setIntersector(J,J,(t,e)=>{let n=ds(t.center,t.r,e.center,e.r,{angleMinA:t.startAngle,angleMaxA:t.endAngle,angleMinB:e.startAngle,angleMaxB:e.endAngle}),r=[];for(let s=0;s<n.length;s++)r.push(N(K({},n[s])));return r}),F.setIntersector(ut,Q,(t,e)=>{let{p0:n,p1:r}=e;return Mt((i,c)=>Tt(n,r,i,c,{minA:e.leftOpen?-1/0:0,maxA:e.rightOpen?1/0:1,minB:0,maxB:1}),t.points,{wrapPoints:!1}).map(i=>N(K({},i)))}),F.setIntersector(ut,$,(t,e)=>{let[n,r]=[e.ref,q(e.ref,e)];return Mt((i,c)=>Tt(n,r,i,c,{minA:0,maxA:1,minB:0,maxB:1}),t.points,{wrapPoints:!1}).map(i=>N(K({},i)))}),F.setIntersector(ut,J,(t,e)=>{let{points:n}=t;return Mt((s,i)=>De(s,i,e.center,e.r,{angleMin:e.startAngle,angleMax:e.endAngle,minA:0,maxA:1}),n,{wrapPoints:!1}).map(s=>N(K({},s)))}),F.setIntersector(ut,ut,(t,e)=>{let{points:n}=t,{points:r}=e;return Mt((i,c)=>Mt((l,o)=>Tt(i,c,l,o,{minA:0,maxA:1,minB:0,maxB:1}),n,{wrapPoints:!1}),r,{wrapPoints:!1}).map(i=>N(K({},i)))}),F.setIntersector(ot,Q,(t,e)=>{let{points:n}=t;return Mt((s,i)=>Tt(s,i,e.p0,e.p1,{minB:e.leftOpen?-1/0:0,maxB:e.rightOpen?1/0:1,minA:0,maxA:1}),n,{wrapPoints:!0}).map(s=>N(K({},s)))}),F.setIntersector(ot,$,(t,e)=>{let{points:n}=t,[r,s]=[e.ref,q(e.ref,e)];return Mt((c,l)=>Tt(r,s,c,l,{minB:0,maxB:1,minA:0,maxA:1}),n,{wrapPoints:!0}).map(c=>N(K({},c)))}),F.setIntersector(ot,J,(t,e)=>{let{points:n}=t;return Mt((s,i)=>De(s,i,e.center,e.r,{minA:0,maxA:1,angleMin:e.startAngle,angleMax:e.endAngle}),n,{wrapPoints:!0}).map(s=>N(K({},s)))}),F.setIntersector(ot,ut,(t,e)=>{let{points:n}=t,{points:r}=e;return Mt((i,c)=>Mt((l,o)=>Tt(i,c,l,o,{minA:0,maxA:1,minB:0,maxB:1}),n,{wrapPoints:!0}),r,{wrapPoints:!1}).map(i=>N(K({},i)))}),F.setIntersector(ot,ot,(t,e)=>{let{points:n}=t,{points:r}=e;return Mt((i,c)=>Mt((l,o)=>Tt(i,c,l,o,{minA:0,maxA:1,minB:0,maxB:1}),n,{wrapPoints:!0}),r,{wrapPoints:!0}).map(i=>N(K({},i)))}),F.setIntersector(pt,Q,(t,e)=>{let n=Gt(e.p0,e.p1,t.points,{minA:e.leftOpen?-1/0:0,maxA:e.rightOpen?1/0:1}),r=[];for(let s=0;s<n.length;s++)r.push(N(K({},n[s])));return r}),F.setIntersector(pt,$,(t,e)=>{let[n,r]=[e.ref,q(e.ref,e)],s=Gt(n,r,t.points,{minA:0,maxA:1}),i=[];for(let c=0;c<s.length;c++)i.push(N(K({},s[c])));return i}),F.setIntersector(pt,J,(t,e)=>{let n=xr(e.center,e.r,t.points,{angleMin:e.startAngle,angleMax:e.endAngle}),r=[];for(let s=0;s<n.length;s++)r.push(N(K({},n[s])));return r}),F.setIntersector(pt,ut,(t,e)=>{let{points:n}=t;return Mt((s,i)=>Gt(s,i,n,{minA:0,maxA:1}),e.points,{wrapPoints:!1}).map(s=>N(K({},s)))}),F.setIntersector(pt,ot,(t,e)=>{let{points:n}=t;return Mt((s,i)=>Gt(s,i,n,{minA:0,maxA:1}),e.points,{wrapPoints:!0}).map(s=>N(K({},s)))}),F.setIntersector(pt,pt,(t,e)=>{let n=In(t.points,e.points,{}),r=[];for(let s=0;s<n.length;s++)r.push(N(K({},n[s])));return r}),F.setIntersector(mt,Q,(t,e)=>{let{points:n,degree:r}=t;if((n.length-(r+1))%r!==0)throw new Error("Wrong number of input points");let s=[],i=new Array(r+1);for(let c=0;c<n.length-1;c+=r){for(let o=0;o<r+1;o++)i[o]=n[c+o];let l=Gt(e.p0,e.p1,i,{minA:e.leftOpen?-1/0:0,maxA:e.rightOpen?1/0:1});l&&(Array.isArray(l)?s.push(...l):s.push(l))}return s.map(c=>N(c))}),F.setIntersector(mt,$,(t,e)=>{let{points:n,degree:r}=t;if((n.length-(r+1))%r!==0)throw new Error("Wrong number of input points");let s=[],i=new Array(r+1),[c,l]=[e.ref,q(e.ref,e)];for(let o=0;o<n.length-1;o+=r){for(let f=0;f<r+1;f++)i[f]=n[o+f];let a=Gt(c,l,i,{minA:e.leftOpen?-1/0:0,maxA:e.rightOpen?1/0:1});a&&(Array.isArray(a)?s.push(...a):s.push(a))}return s.map(o=>N(o))}),F.setIntersector(mt,J,(t,e)=>{let{points:n,degree:r}=t;if((n.length-(r+1))%r!==0)throw new Error("Wrong number of input points");let s=[],i=new Array(r+1),{center:c,r:l,startAngle:o,endAngle:a}=e;for(let f=0;f<n.length-1;f+=r){for(let p=0;p<r+1;p++)i[p]=n[f+p];let h=xr(c,l,i,{angleMin:o,angleMax:a});h&&(Array.isArray(h)?s.push(...h):s.push(h))}return s.map(f=>N(f))}),F.setIntersector(mt,ut,(t,e)=>{let{points:n,degree:r}=t;if((n.length-(r+1))%r!==0)throw new Error("Wrong number of input points");let s=[],i=new Array(r+1);for(let c=0;c<n.length-1;c+=r){for(let o=0;o<r+1;o++)i[o]=n[c+o];let l=Mt((o,a)=>Gt(o,a,i,{minA:0,maxA:1}),e.points,{wrapPoints:!1});l&&(Array.isArray(l)?s.push(...l):s.push(l))}return s.map(c=>N(c))}),F.setIntersector(mt,ot,(t,e)=>{let{points:n,degree:r}=t;if((n.length-(r+1))%r!==0)throw new Error("Wrong number of input points");let s=[],i=new Array(r+1);for(let c=0;c<n.length-1;c+=r){for(let o=0;o<r+1;o++)i[o]=n[c+o];let l=Mt((o,a)=>Gt(o,a,i,{minA:0,maxA:1}),e.points,{wrapPoints:!0});l&&(Array.isArray(l)?s.push(...l):s.push(l))}return s.map(c=>N(c))}),F.setIntersector(mt,pt,(t,e)=>{let{points:n,degree:r}=t;if((n.length-(r+1))%r!==0)throw new Error("Wrong number of input points");let s=[],i=new Array(r+1);for(let c=0;c<n.length-1;c+=r){for(let o=0;o<r+1;o++)i[o]=n[c+o];let l=In(e.points,i,{});l&&(Array.isArray(l)?s.push(...l):s.push(l))}return s.map(c=>N(c))}),F.setIntersector(mt,mt,(t,e)=>{let{points:n,degree:r}=t,{points:s,degree:i}=e;if((n.length-(r+1))%r!==0)throw new Error("Wrong number of input points");if((s.length-(i+1))%i!==0)throw new Error("Wrong number of input points");let c=[],l=new Array(r+1),o=new Array(i+1);for(let a=0;a<n.length-1;a+=r){for(let f=0;f<r+1;f++)l[f]=n[a+f];for(let f=0;f<s.length-1;f+=i){for(let p=0;p<i+1;p++)o[p]=s[f+p];let h=In(l,o,{});h&&(Array.isArray(h)?c.push(...h):c.push(h))}}return c.map(a=>N(a))}),F.setIntersector(ct,Q,(t,e)=>{let n=[e.p0,e.p1];n=Yt(n,t.center,t.rotation,t.rx,t.ry);let r=F.getIntersector(Q,J),s=Xt({p0:n[0],p1:n[1]}),i=ue({r:1,startAngle:t.startAngle,endAngle:t.endAngle,center:{x:0,y:0}}),c=r(s,i);c=Kt(c,t.center,t.rotation,t.rx,t.ry);let l=[];for(let o=0;o<c.length;o++)l.push(N(K({},c[o])));return l}),F.setIntersector(ct,$,(t,e)=>{let n=[e.ref,q(e.ref,e)];n=Yt(n,t.center,t.rotation,t.rx,t.ry);let r=F.getIntersector(Q,J),s=Xt({p0:n[0],p1:n[1]}),i=ue({r:1,startAngle:t.startAngle,endAngle:t.endAngle,center:{x:0,y:0}}),c=r(s,i);c=Kt(c,t.center,t.rotation,t.rx,t.ry);let l=[];for(let o=0;o<c.length;o++)l.push(N(K({},c[o])));return l}),F.setIntersector(ct,J,(t,e)=>{let n=Xn({center:e.center,rx:e.r,ry:e.r,startAngle:e.startAngle,endAngle:e.endAngle,rotation:0}),r=vr(t,n),s=[];for(let i=0;i<r.length;i++)s.push(N(K({},r[i])));return s}),F.setIntersector(ct,ut,(t,e)=>{let n=e.points;n=Yt(n,t.center,t.rotation,t.rx,t.ry);let r=F.getIntersector(ut,J),s=Jn({points:n}),i=ue({r:1,startAngle:t.startAngle,endAngle:t.endAngle,center:{x:0,y:0}}),c=r(s,i);c=Kt(c,t.center,t.rotation,t.rx,t.ry);let l=[];for(let o=0;o<c.length;o++)l.push(N(K({},c[o])));return l}),F.setIntersector(ct,ot,(t,e)=>{let n=e.points;n=Yt(n,t.center,t.rotation,t.rx,t.ry);let r=F.getIntersector(ot,J),s=Qn({points:n}),i=ue({r:1,startAngle:t.startAngle,endAngle:t.endAngle,center:{x:0,y:0}}),c=r(s,i);c=Kt(c,t.center,t.rotation,t.rx,t.ry);let l=[];for(let o=0;o<c.length;o++)l.push(N(K({},c[o])));return l}),F.setIntersector(ct,pt,(t,e)=>{let n=e.points;n=Yt(n,t.center,t.rotation,t.rx,t.ry);let r=F.getIntersector(pt,J),s=Zn({points:n}),i=ue({r:1,startAngle:t.startAngle,endAngle:t.endAngle,center:{x:0,y:0}}),c=r(s,i);c=Kt(c,t.center,t.rotation,t.rx,t.ry);let l=[];for(let o=0;o<c.length;o++)l.push(N(K({},c[o])));return l}),F.setIntersector(ct,mt,(t,e)=>{let n=e.points;n=Yt(n,t.center,t.rotation,t.rx,t.ry);let r=F.getIntersector(mt,J),s=Kn({points:n,degree:e.degree}),i=ue({r:1,startAngle:t.startAngle,endAngle:t.endAngle,center:{x:0,y:0}}),c=r(s,i);c=Kt(c,t.center,t.rotation,t.rx,t.ry);let l=[];for(let o=0;o<c.length;o++)l.push(N(K({},c[o])));return l}),F.setIntersector(ct,ct,(t,e)=>{let n=vr(t,e),r=[];for(let s=0;s<n.length;s++)r.push(N(K({},n[s])));return r});var Dn=F;function Ve(u,t,e,{minA:n=-1/0,maxA:r=1/0,eps:s=1e-10}={}){let i=e.x-t.x,c=e.y-t.y,l=i*i+c*c;if(l<s)return{x:t.x,y:t.y,t:0};let o=u.x-t.x,a=u.y-t.y,f=o*i+a*c;f=f/l,f=Math.min(r,Math.max(n,f));let h=t.x+f*i,p=t.y+f*c;return{x:h,y:p,t:f}}function Ar(u,t,e,{angleMin:n=0,angleMax:r=2*Math.PI,eps:s=1e-10}={}){let i=u.x-t.x,c=u.y-t.y,l=i*i+c*c;if(l<s)return{x:t.x+e,y:t.y};let o=Math.sqrt(l),a=$t(i,c);if(a>=n&&a<r){let f=t.x+i*e/o,h=t.y+c*e/o;return{x:f,y:h}}else{let f=wr(a,n),h=wr(a,r),p=f<h?n:r,m=t.x+e*Math.cos(p),w=t.y+e*Math.sin(p);return{x:m,y:w}}}function Er(u,t,{eps:e=1e-10}={}){let n=t.length-1;if(n<0)throw new Error("No Bezier control points given");if(n>2)throw new Error("Closest Bezier point only defined for up to degree 2");if(n===0)return t[0];if(n===1)return Ve(u,t[0],t[1],{minA:0,maxA:1,eps:e});let[r,s,i]=Qe(...t),{x:c,y:l}=r,{x:o,y:a}=s,{x:f,y:h}=i,{x:p,y:m}=u,w=2*c*o-2*o*p+2*l*a-2*a*m,A=4*c*f+2*o*o-4*f*p+4*l*h+2*a*a-4*h*m,x=6*o*f+6*a*h,v=4*f*f+4*h*h,M=pn(v,x,A,w,e),P=1/0,T=null;for(let k of M){if(Math.abs(Ht(k))>e)continue;let B=ne(k);B=Math.min(1,Math.max(0,B));let V=i;V=q(R(V,B),s),V=q(R(V,B),r);let Y=Wt(I(V,u));Y<P&&(P=Y,T=V)}return T}var bt=class bt{static setClosestPointFunction(t,e){bt[t]=e}static getClosestPointFunction(t){return bt[t]}static closestPoint(t,e){let n=e.type;return bt.getClosestPointFunction(n)(t,e)}};ht(bt,"closest",{}),bt.setClosestPointFunction(O,(t,e)=>e),bt.setClosestPointFunction(Q,(t,e)=>{let n=Ve(t,e.p0,e.p1,{minA:e.leftOpen?-1/0:0,maxA:e.rightOpen?1/0:1});return N(K({},n))}),bt.setClosestPointFunction($,(t,e)=>{let n=q(e.ref,e),r=Ve(t,e.ref,n,{minA:0,maxA:1});return N(r)}),bt.setClosestPointFunction(J,(t,e)=>{let n=Ar(t,e.center,e.r,{angleMin:e.startAngle,angleMax:e.endAngle});return N(K({},n))}),bt.setClosestPointFunction(ut,(t,e)=>{let{points:n}=e,r=1/0,s=null,i=n.length-1;for(let c=0;c<i;c++){let l=n[c],o=n[c+1],a=Ve(t,l,o,{minA:0,maxA:1}),f=Wt(I(t,a));f<r&&(r=f,s=a)}return N(an(K({},s),{d2:r}))}),bt.setClosestPointFunction(ot,(t,e)=>{let{points:n}=e,r=1/0,s=null,i=n.length;for(let c=0;c<i;c++){let l=n[c],o=n[(c+1)%n.length],a=Ve(t,l,o,{minA:0,maxA:1}),f=Wt(I(t,a));f<r&&(r=f,s=a)}return N(an(K({},s),{d2:r}))}),bt.setClosestPointFunction(pt,(t,e)=>{let n=Er(t,e.points,{});return n?N(n):X}),bt.setClosestPointFunction(mt,(t,e)=>{let{points:n,degree:r}=e;if((n.length-(r+1))%r!==0)throw new Error("Wrong number of input points");let s=1/0,i=null,c=new Array(r+1);for(let l=0;l<n.length-1;l+=r){for(let f=0;f<r+1;f++)c[f]=n[l+f];let o=Er(t,c,{});if(!o)continue;let a=Wt(I(t,o));a<s&&(s=a,i=o)}return i?N(i):X}),bt.setClosestPointFunction(ct,(t,e)=>{let[n]=Yt([t],e.center,e.rotation,e.rx,e.ry),r=Ar(n,{x:0,y:0},1,{angleMin:e.startAngle,angleMax:e.endAngle});return[r]=Kt([r],e.center,e.rotation,e.rx,e.ry),N(K({},r))});var gn=bt;function Fn(u,t){return{x:t.x,y:t.y,d:-L.dot(u,t)}}function Vn(u,t){let e=t,n=[],r=u.length;for(let s=0;s<r;s++){let i=u[s],c=(s-1+u.length)%u.length,l=u[c],o=L.dot(e,i)+e.d,a=L.dot(e,l)+e.d;if(o>=0){if(a<0){let f=a/(a-o),h=L.add(l,L.scale(L.sub(i,l),f));n.push(h)}n.push(i)}else if(a>=0){let f=a/(a-o),h=L.add(l,L.scale(L.sub(i,l),f));n.push(h)}}return u=n,u}function js(u,t){for(let e=0;e<t.length;e++){if(u.length<3){u=[];break}let n=(e+1)%t.length,r=t[e],s=t[n],i=L.sub(s,r),c=L.normal2D(i),l=Fn(r,c);u=Vn(u,l)}return u}function y(u,...t){for(let e of t)if(u.type===e)return;throw new Error(`Expected type ${type}, got ${u.type}`)}var Mr=class{constructor({x:t=0,y:e=0,ref:n={x:0,y:0},normalize:r=!1}={}){this.x=t,this.y=e,this.ref=n,this.normalize=r}static fromPosition({p:t,ref:e=b,normalize:n=b}){return E.new("pc",{p:t,ref:e,normalize:n})}static fromRefVector({ref:t=b,v:e=b,normalize:n=b}){return E.new("rv",{ref:t,v:e,normalize:n})}static fromCoordinates({x:t=b,y:e=b,refX:n=b,refY:r=b,normalize:s=b}){return E.new("c",{x:t,y:e,refX:n,refY:r,normalize:s})}static fromLineSegment(t,e=b){return E.new("l",{line:t,normalize:e})}static fromPoints(t,e,n=b){return E.new("pp",{p0:t,p1:e,normalize:n})}static fromPolar({polar:t,ref:e=b,normalize:n=b}){return E.new("pol",{polar:t,ref:e,normalize:n})}compute(t){let{dependencies:e}=t,{x:n,y:r,ref:s,normalize:i}=this;if(t.name==="rv"){let{ref:c,v:l,normalize:o}=e;S(c)||(y(c,O),s=c),S(l)||(y(l,$),n=l.x,r=l.y),S(o)||(y(o,it),i=o.value)}else if(t.name==="c"){let{x:c,y:l,refX:o,refY:a,normalize:f}=e;S(c)||(y(c,G),n=c.value),S(l)||(y(l,G),r=l.value),S(o)||(y(o,G),s.x=o.value),S(a)||(y(a,G),s.y=a.value),S(f)||(y(f,it),i=f.value)}else if(t.name==="pc"){let{p:c,normalize:l,ref:o}=e;S(c)||(y(c,O),n=c.x,r=c.y),S(l)||(y(l,it),i=l.value),S(o)||(y(o,O),s=o)}else if(t.name==="l"){let{line:c,normalize:l}=e;C(c),y(c,Q);let{p0:o,p1:a}=c;({x:n,y:r}=I(a,o)),s=o,S(l)||(y(l,it),i=l.value)}else if(t.name==="pp"){let{p0:c,p1:l,normalize:o}=e;C(c,l),y(c,O),y(l,O),s=c,S(o)||(y(o,it),i=o.value),{x:n,y:r}=I(l,c)}else if(t.name==="pol"){let{polar:c,ref:l,normalize:o}=e;C(c),y(c,Xe);let{r:a,alpha:f}=c;({x:n,y:r}=Dt(a,f)),S(l)||(y(l,O),s=l),S(o)||(y(o,it),i=o.value)}else if(t!==dt)throw new Error("No suitable parameters found to construct Vector");return i&&({x:n,y:r}=ze(vt(n,r))),Rt({x:n,y:r,ref:s})}},Pr=class{static fromAttach(t,e,n=b){return E.new("att",{a:t,b:e,ref:n})}static fromDot(t,e){return E.new("dot",{a:t,b:e})}static fromNegate(t,e=!1){return E.new("neg",{a:t},{attachAtEndPoint:e})}static fromTransform(t,{alpha:e=b,scale:n=b,normalize:r=b,ref:s=b},i={}){let{alpha:c=0,scale:l=1,normalize:o=!1}=i;return E.new("tr",{a:t,alpha:e,scale:n,normalize:r,ref:s},{alpha:c,scale:l,normalize:o})}compute(t){let{dependencies:e,params:n}=t;if(t.name==="att"){let{a:r,b:s,ref:i}=e;C(r,s),y(r,$),y(s,$);let c=L.add(r,s),l=r.ref;return S(i)||(y(i,O),l=i),Rt({x:c.x,y:c.y,ref:l})}else if(t.name==="dot"){let{a:r,b:s}=e;C(r,s),y(r,$),y(s,$);let i=L.dot(r,s);return ye(i)}else if(t.name==="neg"){let{a:r}=e,{attachAtEndPoint:s}=n,i=L.scale(r,-1),c=r.ref;return s&&(c=L.add(c,r)),Rt({x:i.x,y:i.y,ref:c})}else if(t.name==="tr"){let{a:r,alpha:s,scale:i,normalize:c,ref:l}=e,{alpha:o,scale:a,normalize:f}=n;C(r),y(r,$),S(s)||(y(s,G),o=s.value),S(i)||(y(i,G),a=i.value),S(c)||(y(c,it),f=c.value);let h=r.ref;S(l)||(y(l,O),h=l);let p=r;return f&&(p=L.normalizeIfNotZero(p)),p=L.scale(p,a),p=L.rotate(p,o),Rt({x:p.x,y:p.y,ref:h})}else throw new Error("No suitable constructor")}},fe=class u{static createSystem({origin:t,u:e,v:n}={}){return t=t!=null?t:L.vec2(0,0),e||(n=null),e=e!=null?e:L.vec2(1,0),n=n!=null?n:L.normal2D(e),{origin:t,u:e,v:n}}static computeContravariantBasis(t,e){let n=L.len2(t),r=L.len2(e),s=L.dot(t,e),i=1/(n*r-s*s),c=L.add(L.scale(t,i*r),L.scale(e,-i*s)),l=L.add(L.scale(t,-i*s),L.scale(e,i*n));return{u:c,v:l}}static vectorFromCoordSystem(t,{u:e,v:n}){return L.add(L.scale(e,t.x),L.scale(n,t.y))}static pointFromCoordSystem(t,{origin:e,u:n,v:r}){return L.add(e,L.add(L.scale(n,t.x),L.scale(r,t.y)))}static isRightHanded(t,e){return t.x*e.y-t.y*e.x>=0}constructor({local:t={},parent:e={}}={}){this.local=t,this.parent=e}static fromValues({origin:t=b,u:e=b,v:n=b,parent:r=b}={}){return E.new("v",{origin:t,u:e,v:n,parent:r})}static fromTransform({translation:t=b,rotation:e=b,scale:n=b,parent:r=b},s){let{translation:i={x:0,y:0},rotation:c=0,scale:l={x:1,y:1}}=s;return E.new("t",{translation:t,rotation:e,scale:n,parent:r},{translation:i,rotation:c,scale:l})}static fromContravariant(t,e=b){return E.new("c",{system:t,parent:e})}compute(t){let{dependencies:e,params:n}=t,{local:r,parent:s}=this;if(r=Object.assign({},r),s=Object.assign({},s),t.name==="v"){let{origin:o,u:a,v:f,parent:h}=e;S(o)||(y(o,O),r.origin=o),S(a)||(y(a,$),r.u=a),S(f)?r.v=null:(y(f,$),r.v=f),S(h)||(y(h,ee),s=h)}else if(t.name==="t"){let{translation:o,rotation:a,scale:f}=n;typeof f=="number"&&(f=L.vec2(f,f));let{translation:h,rotation:p,scale:m,parent:w}=e;S(h)||(y(h,$),o=h),S(m)||(y(m,$,G),m.type===$?f=m:f=L.vec2(m.value,m.value)),S(p)||(y(p,G),a=p.value);let A=L.vec2(f.x,0),x=L.vec2(0,f.y);A=L.rotate(A,a),x=L.rotate(x,a),r.u=A,r.v=x,r.origin=o,S(w)||(y(w,ee),s=w)}else if(t.name==="c"){let{origin:o,u:a,v:f,parent:h}=e;S(o)||(y(o,O),r.origin=o),S(a)||(y(a,$),r.u=a),S(f)?r.v=null:(y(f,$),r.v=f),S(h)||(y(h,ee),s=h),r=u.createSystem(r),s=u.createSystem(s);let p=L.add(s.origin,u.vectorFromCoordSystem(r.origin,s)),m=u.vectorFromCoordSystem(r.u,s),w=u.vectorFromCoordSystem(r.v,s);return{u:m,v:w}=u.computeContravariantBasis(m,w),gr(p,m,w)}else if(t!==dt)throw new Error("No suitable constructor");r=u.createSystem(r),s=u.createSystem(s);let i=L.add(s.origin,u.vectorFromCoordSystem(r.origin,s)),c=u.vectorFromCoordSystem(r.u,s),l=u.vectorFromCoordSystem(r.v,s);return gr(i,c,l)}},Sr=class{static fromPointOrVec(t,e=b){return E.new("v",{v:t,coordSystem:e})}static fromToCoordinates(t,e=b){return E.new("c",{v:t,coordSystem:e})}static fromIsRightHanded(t){return E.new("r",{coordSystem:t})}compute(t){let{dependencies:e,params:n}=t;if(t.name==="v"){let{v:r,coordSystem:s}=e;C(r),y(r,O,$);let i=s;S(i)?i=fe.createSystem():y(i,ee);let c=fe.vectorFromCoordSystem(r,i);if(r.type===O)return c=L.add(c,i.origin),N(c);{let l=fe.vectorFromCoordSystem(r.ref,i);return l=L.add(i.origin,l),Rt({x:c.x,y:c.y,ref:l})}}else if(t.name==="c"){let{v:r,coordSystem:s}=e;C(r),y(r,O,$);let i=s;S(i)?i=fe.createSystem():y(i,ee);let{u:c,v:l}=fe.computeContravariantBasis(i.u,i.v),o=r;if(r.type===O){o=L.sub(o,i.origin);let a=L.dot(o,c),f=L.dot(o,l);return N({x:a,y:f})}else{let a=L.dot(o,c),f=L.dot(o,l),h=L.sub(r.ref,i.origin),p=L.dot(h,c),m=L.dot(h,l);return Rt({x:a,y:f,ref:{x:p,y:m}})}}else if(t.name==="r"){let{coordSystem:r}=e;return C(r),y(r,ee),Re(fe.isRightHanded(r.u,r.v))}else throw new Error("No suitable constructor")}},br=class u{constructor({normalize:t=!1,ref:e={x:0,y:0}}={}){this.normalize=t,this.ref=e}static fromPointCoordinates({p:t,ref:e=b,normalize:n=b}){return E.new("pc",{p:t,ref:e,normalize:n})}static fromLine({line:t,ref:e=b,normalize:n=b}){return E.new("l",{line:t,ref:e,normalize:n})}static fromVector({v:t,ref:e=b,normalize:n=b}){return E.new("v",{v:t,ref:e,normalize:n})}static fromCoordinates({x:t,y:e,ref:n=b,normalize:r=b}){return E.new("c",{x:t,y:e,ref:n,normalize:r})}static fromPoints({p0:t,p1:e,ref:n=b,normalize:r=b}){return E.new("pp",{p0:t,p1:e,ref:n,normalize:r})}static fromArc(t,e,n=b){return E.new("arc",{p:t,arc:e,normalize:n})}static fromEllipse(t,e,n=b){return E.new("eli",{p:t,ellipse:e,normalize:n})}static circleNormal(t,e,n){return t=I(t,e),R(t,2/(n*n))}static ellipseNormal(t,e,n,r,s){let i=I(t,e);i=de(i,-s);let c=vt(2*i.x/(n*n),2*i.y/(r*r));return c=de(c,s),c}compute(t){let{dependencies:e}=t,{normalize:n,ref:r}=this,s;if(t.name==="pc"){let{p:i,ref:c,normalize:l}=e;C(i),y(i,O),S(c)||(y(c,O),r=c),S(l)||(y(l,it),n=l.value),s=gt(i)}else if(t.name==="l"){let{line:i,ref:c,normalize:l}=e;C(i),y(i,Q);let{p0:o,p1:a}=i;s=gt(I(a,o)),r=o,S(c)||(y(c,O),r=c),S(l)||(y(l,it),n=l.value)}else if(t.name==="v"){let{v:i,ref:c,normalize:l}=e;C(i),y(i,$),s=gt(i),r=i.ref,S(c)||(y(c,O),r=c),S(l)||(y(l,it),n=l.value)}else if(t.name==="c"){let{x:i,y:c,ref:l,normalize:o}=e;C(i,c),y(i,G),y(c,G),s=gt(vt(i.val,c.val)),S(l)||(y(l,O),r=l),S(o)||(y(o,it),n=o.value)}else if(t.name==="pp"){let{p0:i,p1:c,ref:l,normalize:o}=e;C(i,c),y(i,O),y(c,O),s=gt(I(c,i)),r=i,S(l)||(y(l,O),r=l),S(o)||(y(o,it),n=o.value),S(o)||(y(o,it),n=o.value)}else if(t.name==="arc"){let{p:i,arc:c,normalize:l}=e;C(i,c),y(i,O),y(c,J);let{r:o,center:a}=c;s=u.circleNormal(i,a,o),r=i,S(l)||(y(l,it),n=l.value)}else if(t.name==="eli"){let{p:i,ellipse:c,normalize:l}=e;C(i,c),y(i,O),y(c,ct);let{rx:o,ry:a,rotation:f,center:h}=c;s=u.ellipseNormal(i,h,o,a,f),r=i,S(l)||(y(l,it),n=l.value)}else throw new Error("No suitable constructor found");return n&&(s=ze(s)),Rt({x:s.x,y:s.y,ref:r})}},Tr=class{static fromVectorsOrLine({v:t,ref:e=b}){return E.new("vl",{v:t,ref:e})}compute(t){let{dependencies:e}=t,n={x:0,y:0},r={x:0,y:0};if(t.name==="vl"){let{v:c,ref:l}=e;if(S(c))throw new Error("Expected non-empty parameter");if(c.type===$)n=c.ref,r=Object.assign({},c);else if(c.type===Q){let{p0:o,p1:a}=c;n=o,r=I(a,o)}else throw new Error("Expected vector or line");if(!S(l)){if(l.type!==O)throw new Error("Expected point");n=l}}else throw new Error("No suitable constructor found");let s=gt({x:r.x,y:r.y}),i=q(n,s);return Xt({p0:n,p1:i,leftOpen:!0,rightOpen:!0})}},vn,ws,Or=class{constructor({distance:t=1}={}){U(this,vn);this.distance=t}static fromVectorsOrLine({v:t,distance:e=b}){return E.new("vld",{v:t,distance:e})}static fromVectorsOrLineRef({v:t,ref:e=b}){return E.new("vlr",{v:t,ref:e})}compute(t){let{dependencies:e}=t,{distance:n}=this,r={x:0,y:0},s={x:0,y:0};if(t.name==="vlr"){let{v:i,ref:c}=e;if(S(i))throw new Error("Expected non-empty");if(i.type===$)s=i,r=i.ref;else if(i.type===Q){let{p0:l,p1:o}=i;s=I(o,l),r=l}else throw new Error("Expected vector or line");if(!S(c)){if(c.type!==O)throw new Error("Expected point");r=c,n=0}}else if(t.name==="vld"){let{v:i,distance:c}=e;if(S(i))throw new Error("Expected non-empty");if(i.type===$)s=i,r=i.ref;else if(i.type===Q){let{p0:l,p1:o}=i;s=I(o,l),r=l}else throw new Error("Expected vector or line");if(!S(c)){if(c.type!==G)throw new Error("Expected number");n=c.value}}else throw new Error("No suitable constructor found");return D(this,vn,ws).call(this,r,s,n)}};vn=new WeakSet,ws=function(t,e,n){let r=gt(e),s=An(r);if(s<1e-10)return X;r.x/=s,r.y/=s;let i=q(t,R(r,n)),c=q(i,e);return Xt({p0:i,p1:c,leftOpen:!0,rightOpen:!0})};var Lr=class u{constructor(t=!1){this.normalize=t}static fromVectorNormal({v:t,n:e,ref:n=b,normalize:r=b}){return E.new("vn",{v:t,n:e,ref:n,normalize:r})}static reflectVector(t,e){let n=pe(t,e);return I(t,R(e,2*n))}compute(t){let{dependencies:e}=t,{normalize:n}=this;if(t.name==="vn"){let{v:r,n:s,ref:i,normalize:c}=e;C(r,s),y(r,$),y(s,$);let l=r.ref,o=u.reflectVector(r,s);return S(c)||(y(c,it),n=c.value),n&&(o=ze(o)),S(i)||(y(i,O),l=i),Rt({x:o.x,y:o.y,ref:l})}else throw new Error("No suitable constructor found")}},kr=class u{constructor({eta:t=1,normalize:e=!1}={}){this.eta=t,this.normalize=e}static fromVectorNormal({v:t,n:e,ref:n=b,eta:r=b,normalize:s=b}){return E.new("vn",{v:t,n:e,ref:n,eta:r,normalize:s})}static refractVector(t,e,n){e=Object.assign({},e);let r=pe(t,e);r>0&&(r=-r,e.x*=-1,e.y*=-1,n=1/n);let s=1-n*n*(1-r*r);return s<0?null:I(R(t,n),R(e,n*r+Math.sqrt(s)))}compute(t){let{dependencies:e}=t;if(t.name==="vn"){let{v:n,n:r,ref:s,normalize:i,eta:c}=e,{eta:l,normalize:o}=this;C(n,r),y(n,$),y(r,$);let a=n.ref;S(i)||(y(i,it),o=i.value),S(c)||(y(c,G),l=c.value),S(s)||(y(s,O),a=s);let f=u.refractVector(n,r,l);return f?(o&&(f=ze(f)),Rt({x:f.x,y:f.y,ref:a})):X}else throw new Error("No suitable constructor found")}},Cr=class{constructor({r:t=1,alpha:e=0,ref:n={x:0,y:0}}={}){this.r=t,this.alpha=e,this.ref=n}static fromPolar(t,e=b){return E.new("pol",{polar:t,ref:e})}static fromAngle({angle:t,startAngle:e=b,r:n=b,ref:r=b}){return E.new("ang",{angle:t,startAngle:e,r:n,ref:r})}static fromRadiusAngle({r:t=b,alpha:e=b,ref:n=b}){return E.new("ra",{r:t,alpha:e,ref:n})}compute(t){let{r:e,alpha:n,ref:r}=this,{dependencies:s}=t;if(t.name==="ra"){let{r:l,alpha:o,ref:a}=s;S(l)||(y(l,G),e=l.value),S(o)||(y(o,G),n=o.value),S(a)||(y(a,O),r=a)}else if(t.name==="ang"){let{angle:l,startAngle:o,r:a,ref:f}=s;C(l),y(l,Me);let{value:h,start:p}=l;r=l.ref,S(a)||(y(a,G),e=a.value),S(o)||(y(o,G),p=o.value),S(f)||(y(f,O),r=f),n=p+h}else if(t.name==="pol"){let{polar:l,ref:o}=s;C(l),y(l,Xe),{r:e,alpha:n}=l,S(o)||(y(o,O),r=o)}else if(t!==dt)throw new Error("No suitable constructor found");let{x:i,y:c}=Dt(e,n);return Rt({x:i,y:c,ref:r})}},Nr=class{constructor(t){this.value=t}static fromField(t,e,n=null){return E.new("ok",{obj:t},{key:e,transform:n})}static fromFunc(t,e){return Array.isArray(e)?E.new("f",e,{f:t}):E.new("f",[e],{f:t})}compute(t){let{value:e}=this,{dependencies:n,params:r}=t;if(t.name==="ok"){let{obj:s}=n;C(s);let{key:i,transform:c}=t.params;if(e=s[i],e===void 0)return X;if(typeof e!="number")throw new Error("Trying to create number from non-number field");c&&c instanceof Function&&(e=c(e))}else if(t.name==="f"){let{f:s}=r;if(!Array.isArray(n))throw new Error("Expected array");let i=[];for(let c of n)C(c),y(c,G),i.push(c.value);e=s(...i)}else if(t!==dt)throw new Error("No suitable constructor");return ye(e)}},Ir=class{constructor(t){this.value=t}static fromField(t,e,n=null){return E.new("ok",{obj:t},{key:e,transform:n})}compute(t){let{value:e}=this,{dependencies:n}=t;if(t.name==="ok"){let{obj:r}=n;C(r);let{key:s,transform:i}=t.params;if(e=r[s],e===void 0)return X;i&&i instanceof Function&&(e=i(e))}else if(t!==dt)throw new Error("No suitable constructor");return Ds(e)}},Le=class Le{constructor(t){this.value=t}static fromPredicate(t,e){return E.new("p",e,{predicate:t})}static fromNot(t){return E.new("not",{boolValue:t})}static fromOp(t,e){return E.new("op",t,{operation:e})}compute(t){let{value:e}=this,{dependencies:n,params:r}=t;if(t.name==="p"){let{predicate:s}=r;return Re(s(n))}else if(t.name==="not"){let{boolValue:s}=n;return C(s),y(s,it),Re(!s.value)}else if(t.name==="op"){let{boolValues:s}=n;C(s);let{operation:i}=r,c=[];for(let o of s)y(o,it),c.push(o.value);let l;if(i===Le.OP_AND)l=c.reduce((o,a)=>o&&a,!0);else if(i===Le.OP_OR)l=c.reduce((o,a)=>o||a,!1);else throw new Error("Requested Boolean operation not supported");return Re(l)}else if(t!==dt)throw new Error("No suitable constructor");return Re(e)}};ht(Le,"OP_AND",0),ht(Le,"OP_OR",1);var zr=Le,qr=class{static fromCondition(t,e){return E.new("c",{obj:t,condition:e})}static fromEitherOr(t,e,n){return E.new("eo",{obj0:t,obj1:e,condition:n})}compute(t){let{dependencies:e}=t;if(t.name==="c"){let{obj:n,condition:r}=e;return C(n,r),y(r,it),r.value?n:X}else if(t.name==="eo"){let{obj0:n,obj1:r,condition:s}=e;return C(n,r,s),y(s,it),s.value?n:r}else throw new Error("No suitable constructor")}},Br=class u{static fromCurve(t,e,{eps:n=1e-10,takeIndex:r=-1}={}){return E.new("curve",{curve:t,p:e},{eps:n,takeIndex:r})}static bezierParam(t,e,n=1e-10){return yr(e,t.points,n)}static arcParam(t,e,n=1e-10){let{center:r,r:s,startAngle:i,endAngle:c}=t;i>c&&(c+=2*Math.PI);let l=c-i,o=I(e,r);return Math.abs(Wt(o)-s*s)>n?[]:[($t(o.x,o.y)-i)/l]}static ellipseParam(t,e,n=1e-10){let{center:r,rx:s,ry:i,rotation:c,startAngle:l,endAngle:o}=t;l>o&&(o+=2*Math.PI);let a=o-l,[f]=Yt([e],r,c,s,i);return Math.abs(Wt(f)-1)>n?[]:[($t(f.x,f.y)-l)/a]}static lineParam(t,e,{eps:n=1e-10,minT:r=0,maxT:s=1}={}){let{p0:i,p1:c}=t,l=I(c,i),o=gt(l),a=pe(o,I(e,i));if(Math.abs(a)>n)return[];let f=me(i,c,e);return f<r||f>s?[]:[f]}static vectorParam(t,e,n=1e-10){let r=gt(t),s=pe(r,I(e,t.ref));if(Math.abs(s)>n)return[];let i=me(t.ref,q(t,t.ref),e);return i<0||i>1?[]:[i]}static lineStripParam(t,e,n=1e-10){let r=[],{points:s}=t,i=s.length-1;for(let c=0;c<i;c++){let[l,o]=[s[c],s[c+1]],a=I(o,l),f=gt(a),h=pe(f,I(e,l));if(Math.abs(h)>n)continue;let p=me(l,o,e);p<0||p>1||r.push((p+c)/i)}return r}static polygonParam(t,e,n=1e-10){let r=[],{points:s}=t,i=s.length;for(let c=0;c<i;c++){let[l,o]=[s[c],s[(c+1)%s.length]],a=I(o,l),f=gt(a),h=pe(f,I(e,l));if(Math.abs(h)>n)continue;let p=me(l,o,e);p<0||p>1||r.push((p+c)/i)}return r}static bezierSplineParam(t,e,n=1e-10){let r=[],{points:s,degree:i}=t,c=Mn(s,i);for(let l=0;l<c;l++){let o=Pn(s,i,l),a=yr(e,o,n);r.push(...a.map(f=>(f+l)/c))}return r}static curveParam(t,e,n){let r=t.type;if(r===pt)return u.bezierParam(t,e,n);if(r===J)return u.arcParam(t,e);if(r===ct)return u.ellipseParam(t,e);if(r===Q)return u.lineParam(t,e,{eps:n,minT:t.leftOpen?-1/0:0,maxT:t.rightOpen?1/0:1});if(r===$)return u.vectorParam(t,e,n);if(r===ut)return u.lineStripParam(t,e,n);if(r===ot)return u.polygonParam(t,e,n);if(r===mt)return u.bezierSplineParam(t,e,n);throw new Error(`Object type ${r} not supported`)}compute(t){let{dependencies:e}=t;if(t.name==="curve"){let{curve:n,p:r}=e,{eps:s,takeIndex:i}=t.params;C(n,r),y(r,O);let c=u.curveParam(n,r,s);return i>=0?i>=c.length?X:ye(c[i]):c.map(l=>ye(l))}else throw new Error("No suitable constructor")}},$r=class{constructor({text:t="",ref:e={x:0,y:0}}={}){this.text=t,this.ref=e}static fromObjectRef({obj:t=b,ref:e=b}){return E.new("or",{obj:t,ref:e})}compute(t){let{text:e,ref:n}=this,{dependencies:r}=t;if(t.name==="or"){let{obj:s,ref:i}=r;S(s)||(e instanceof Function?e=e(s):e=hs(s)),S(i)||(y(i,O),n=i)}else if(t!==dt)throw new Error("No suitable constructor found");return e instanceof Function&&(e=e()),Rs({text:e,ref:n})}},Lt=class Lt{static fromVectorsOrLines(t,e,n=Lt.USE_COMPUTED_ANGLE){return E.new("vl",{v0:t,v1:e},{useAngle:n})}static fromPoints(t,e,n,r=Lt.USE_COMPUTED_ANGLE){return E.new("ppp",{p0:t,p1:e,p2:n},{useAngle:r})}static fromFixedDir({v:t,fixedDir:e={x:1,y:0},useAngle:n=Lt.USE_COMPUTED_ANGLE}){return E.new("fd",{v:t},{useAngle:n,fixedDir:e})}compute(t){let{dependencies:e,params:n}=t;if(t.name==="vl"){let r,s,i,c,{v0:l,v1:o}=e;if(l.type===Q)r=l.p0,s=I(l.p1,l.p0);else if(l.type===$)r=l.ref,s=l;else throw new Error(`Expected line or vector, got ${l.type} `);if(o.type===Q)i=o.p0,c=I(o.p1,o.p0);else if(o.type===$)i=o.ref,c=o;else throw new Error(`Expected line or vector, got ${o.type} `);let a=Tt(r,q(r,s),i,q(i,c));a||(a=r);let f=ve(s,c),p=ve({x:1,y:0},s),m=p+f;m<p&&(m+=2*Math.PI);let{useAngle:w}=n,A=m-p;return w===Lt.USE_SMALLER_ANGLE?A>Math.PI&&([p,m]=[m,p]):w===Lt.USE_LARGER_ANGLE&&A<Math.PI&&([p,m]=[m,p]),We({value:m-p,start:p,ref:a})}else if(t.name==="ppp"){let{p0:r,p1:s,p2:i}=e;if(r.type!==O||s.type!==O||i.type!==O)throw new Error(`Expected points, got ${r.type}, ${s.type}, ${i.type} `);let c=s,l=I(r,c),o=I(i,c),a=ve(l,o),h=ve({x:1,y:0},l),p=h+a;p<h&&(p+=2*Math.PI);let{useAngle:m}=n,w=p-h;return m===Lt.USE_SMALLER_ANGLE?w>Math.PI&&([h,p]=[p,h]):m===Lt.USE_LARGER_ANGLE&&w<Math.PI&&([h,p]=[p,h]),We({value:p-h,start:h,ref:c})}else if(t.name==="fd"){let r,s,{v:i}=e;C(i),y(i,$,Q);let{fixedDir:c,useAngle:l}=n;i.type===Q?(r=i.p0,s=I(i.p1,i.p0)):i.type===$&&(r=i.ref,s=i);let o=ve(c,s),f=ve({x:1,y:0},c),h=f+o;h<f&&(h+=2*Math.PI);let p=h-f;return l===Lt.USE_SMALLER_ANGLE?p>Math.PI&&([f,h]=[h,f]):l===Lt.USE_LARGER_ANGLE&&p<Math.PI&&([f,h]=[h,f]),We({value:h-f,start:f,ref:r})}throw new Error("No suitable constructor found")}};ht(Lt,"USE_SMALLER_ANGLE",-1),ht(Lt,"USE_COMPUTED_ANGLE",0),ht(Lt,"USE_LARGER_ANGLE",1);var Ue=Lt,Rr=class{constructor({r:t=1,alpha:e=0}={}){this.r=t,this.alpha=e}static fromPointOrVector(t){return E.new("pv",{p:t})}static fromValues({r:t=b,alpha:e=b}={}){return E.new("v",{r:t,alpha:e})}compute(t){let{r:e,alpha:n}=this,{dependencies:r}=t;if(t.name==="pv"){let{p:s}=r;C(s),y(s,O,$),e=An(s),n=$t(s.x,s.y)}else if(t.name==="v"){let{r:s,alpha:i}=r;S(s)||(y(s,G),e=s.value),S(i)||(y(i,G),n=i.value)}else if(t!==dt)throw new Error("No suitable constructor");return fs({r:e,alpha:n})}},Ze=class{constructor(t=0,e=0){this.x=t,this.y=e}static fromPointOrVector(t){return E.new("p",{p:t})}static fromCoordinates({x:t=b,y:e=b}={}){return E.new("xy",{x:t,y:e})}static fromAttachedVector(t,e){return E.new("pv",{p:t,v:e})}static fromPolar(t){return E.new("pol",{polar:t})}compute(t){let{x:e,y:n}=this,{dependencies:r}=t;if(t.name==="p"){let{p:s}=r;if(S(s)||s.type!==O&&s.type!==$)throw new Error("Point from point or vector requires 1 valid point or vector no suitable parameter set available");if(s.type===O)e=s.x,n=s.y;else if(s.type===$){let{ref:i}=s;({x:e,y:n}=q(i,s))}}else if(t.name==="xy"){let{x:s,y:i}=r;if(!S(s)){if(s.type!==G)throw new Error("Point from coordinates requires x to be either empty or a number");e=s.value}if(!S(i)){if(i.type!==G)throw new Error("Point from coordinates requires y to be either empty or a number");n=i.value}}else if(t.name==="pv"){let{p:s,v:i}=r;if(S(s)||S(i))throw new Error("Point from point and vector requires non - empty parameter");if(s.type!==O||i.type!==$)throw new Error("Point from point and vector requires a point and a vector");({x:e,y:n}=q(s,i))}else if(t.name==="pol"){let{polar:s}=r;C(s),y(s,Xe),{x:e,y:n}=Dt(s.r,s.alpha)}else if(t!==dt)throw new Error("Point: No suitable parameter set available");return N({x:e,y:n})}},Pt=class u{constructor(t=0){this.t=t}static fromCurve({obj:t,t:e=b}){return E.new("obj",{obj:t,t:e})}static ellipsePoint(t,e,n,r,s){let i=Dt(1,s);return[i]=Kt([i],t,r,e,n),i}static circlePoint(t,e,n){return q(t,Dt(e,n))}static linePoint(t,e,n){return yt(t,e,n)}static vectorPoint(t,e){return q(t.ref,R(t,e))}static lineStripPoint(t,e){e=(t.length-1)*e;let r=Math.floor(e);e=e%1;let[s,i]=[t[r],t[r+1]];return yt(s,i,e)}static polygonPoint(t,e){e=t.length*e;let r=Math.floor(e);e=e%1;let[s,i]=[t[r],t[(r+1)%t.length]];return yt(s,i,e)}static bezierPoint(t,e){return Ne(t,e)}static bezierSplinePoint(t,e,n){let r=Mn(t,e);n*=r;let s=Math.floor(n);n=n%1;let i=Pn(t,e,s);return Ne(i,n)}static curvePoint(t,e){let n=t.type;if(n===ct){let r=t,{center:s,rx:i,ry:c,rotation:l,startAngle:o,endAngle:a}=r;o>a&&(a+=2*Math.PI);let f=a-o,h=o+e*f,p=u.ellipsePoint(s,i,c,l,h);return N(p)}else if(n===J){let r=t,{center:s,r:i,startAngle:c,endAngle:l}=r;c>l&&(l+=2*Math.PI);let o=l-c,a=c+e*o;return N(u.circlePoint(s,i,a))}else if(n===Q){let r=t,{p0:s,p1:i}=r;return N(u.linePoint(s,i,e))}else if(n===$){let r=t;return N(u.vectorPoint(r,e))}else if(n===ut){let r=t,{points:s}=r;if(s.length<2)return X;e=(s.length-1)*e;let c=Math.floor(e);e=e%1;let[l,o]=[s[c],s[c+1]];return N(yt(l,o,e))}else if(n===ot){let r=t,{points:s}=r;return s.length<3?X:N(u.polygonPoint(s,e))}else if(n===pt){let r=t,{points:s}=r;return N(u.bezierPoint(s,e))}else if(n===mt){let r=t,{points:s,degree:i}=r;return N(u.bezierSplinePoint(s,i,e))}else throw new Error("Can't create point from given object")}compute(t){let{dependencies:e}=t;if(t.name==="obj"){let{t:n}=this,{obj:r,t:s}=e;return C(r),S(s)||(y(s,G),n=s.value),u.curvePoint(r,n)}else throw new Error("No suitable constructor")}},Dr=class u{constructor({t=0,normalize:e=!1,scale:n=1}={}){this.t=t,this.normalize=e,this.scale=n}static fromCurve({obj:t,t:e=b,normalize:n=b,scale:r=b}){return E.new("obj",{obj:t,t:e,normalize:n,scale:r})}static lineTangent(t,e){return I(e,t)}static circleTangent(t,e){return vt(-t*Math.sin(e),t*Math.cos(e))}static ellipseTangent(t,e,n,r){let s=vt(-t*Math.sin(r),e*Math.cos(r));return s=de(s,n),s}static bezierTangent(t,e){let n=mn(t);return Ne(n,e)}static lineStripTangent(t,e){e=(t.length-1)*e;let r=Math.floor(e);e=e%1;let[s,i]=[t[r],t[r+1]];return I(i,s)}static polygonTangent(t,e){e=t.length*e;let r=Math.floor(e);e=e%1;let[s,i]=[t[r],t[(r+1)%t.length]];return I(i,s)}static bezierSplineTangent(t,e,n){let r=Mn(t,e);n*=r;let s=Math.floor(n);n=n%1;let i=Pn(t,e,s),c=mn(i);return Ne(c,n)}static vectorTangent(t){return t}static curveTangentRef(t,e){let n=t.type;if(n===J){let r=t,{center:s,r:i,startAngle:c,endAngle:l}=r;c>l&&(l+=2*Math.PI);let o=l-c,a=c+e*o,f=Pt.circlePoint(s,i,a);return{v:u.circleTangent(i,a),ref:f}}else if(n===ct){let r=t,{center:s,rx:i,ry:c,rotation:l,startAngle:o,endAngle:a}=r;o>a&&(a+=2*Math.PI);let f=a-o,h=o+e*f,p=u.ellipseTangent(i,c,l,h),m=Pt.ellipsePoint(s,i,c,l,h);return{v:p,ref:m}}else if(n===Q){let r=t,{p0:s,p1:i}=r,c=Pt.linePoint(s,i,e);return{v:u.lineTangent(s,i),ref:c}}else if(n===$){let r=t,s=q(r.ref,R(r,e));return{v:u.vectorTangent(r),ref:s}}else if(n===ut){let r=t,{points:s}=r;if(s.length<2)return null;let i=Pt.lineStripPoint(s,e);return{v:u.lineStripTangent(s,e),ref:i}}else if(n===ot){let r=t,{points:s}=r;if(s.length<3)return null;let i=Pt.polygonPoint(s,e);return{v:u.polygonTangent(s,e),ref:i}}else if(n===pt){let r=t,{points:s}=r,i=Pt.bezierPoint(s,e);return{v:u.bezierTangent(s,e),ref:i}}else if(n===mt){let r=t,{points:s,degree:i}=r,c=Pt.bezierSplinePoint(s,i,e);return{v:u.bezierSplineTangent(s,i,e),ref:c}}else throw new Error("Can't compute tangent from given object")}compute(t){let{dependencies:e}=t,{t:n,normalize:r,scale:s}=this;if(t.name==="obj"){let{obj:i,t:c,normalize:l,scale:o}=e;C(i),S(c)||(y(c,G),n=c.value),S(l)||(y(l,it),r=l.value),S(o)||(y(o,G),s=o.value);let a=u.curveTangentRef(i,n),{v:f,ref:h}=a;return r&&(f=ze(f)),f=R(f,s),Rt({x:f.x,y:f.y,ref:h})}else throw new Error("No suitable constructor")}},Fr=class u{constructor({t=0,normalize:e=!1,scale:n=1}={}){this.t=t,this.normalize=e,this.scale=n}static fromCurve({obj:t,t:e=b,normalize:n=b,scale:r=b}){return E.new("obj",{obj:t,t:e,normalize:n,scale:r})}static circleNormal(t,e){let n=Dt(t,e);return R(n,2/(t*t))}static ellipseNormal(t,e,n,r){let s=vt(t*Math.cos(r),e*Math.sin(r)),i=vt(2*s.x/(t*t),2*s.y/(e*e));return i=de(i,n),i}static lineNormal(t,e){return gt(I(e,t))}static lineStripNormal(t,e){e=(t.length-1)*e;let r=Math.floor(e);e=e%1;let[s,i]=[t[r],t[r+1]];return gt(I(i,s))}static polygonNormal(t,e){e=t.length*e;let r=Math.floor(e);e=e%1;let[s,i]=[t[r],t[(r+1)%t.length]];return gt(I(i,s))}static bezierNormal(t,e){let n=mn(t),r=Ne(n,e);return gt(r)}static bezierSplineNormal(t,e,n){let r=Mn(t,e);n*=r;let s=Math.floor(n);n=n%1;let i=Pn(t,e,s),c=mn(i);return gt(Ne(c,n))}static normalRefFromObject(t,e){if(t.type===J){let n=t,{center:r,r:s,startAngle:i,endAngle:c}=n;i>c&&(c+=2*Math.PI);let l=c-i,o=i+e*l,a=u.circleNormal(s,o),f=Pt.circlePoint(r,s,o);return{n:a,ref:f}}else if(t.type===ct){let n=t,{center:r,rx:s,ry:i,rotation:c,startAngle:l,endAngle:o}=n;l>o&&(o+=2*Math.PI);let a=o-l,f=l+e*a,h=Pt.ellipsePoint(r,s,i,c,f);return{n:u.ellipseNormal(s,i,c,f),ref:h}}else if(t.type===Q){let n=t,{p0:r,p1:s}=n,i=Pt.linePoint(r,s,e);return{n:u.lineNormal(r,s),ref:i}}else if(t.type===$){let n=t,r=q(n.ref,R(n,e));return{n:gt(n),ref:r}}else if(t.type===ut){let n=t,{points:r}=n;if(r.length<2)return X;let s=Pt.lineStripPoint(r,e);return{n:u.lineStripNormal(r,e),ref:s}}else if(t.type===ot){let n=t,{points:r}=n;if(r.length<3)return X;let s=Pt.polygonPoint(r,e);return{n:u.polygonNormal(r,e),ref:s}}else if(t.type===pt){let n=t,{points:r}=n,s=Pt.bezierPoint(r,e);return{n:u.bezierNormal(r,e),ref:s}}else if(t.type===mt){let n=t,{points:r,degree:s}=n,i=Pt.bezierSplinePoint(r,s,e);return{n:u.bezierSplineNormal(r,s,e),ref:i}}else throw new Error("Can't compute tangent on given object")}compute(t){let{dependencies:e,params:n}=t,{t:r,normalize:s,scale:i}=this;if(t.name==="obj"){let{obj:c,t:l,normalize:o,scale:a}=e;C(c),S(l)||(y(l,G),r=l.value),S(o)||(y(o,it),s=o.value),S(a)||(y(a,G),i=a.value);let{n:f,ref:h}=u.normalRefFromObject(c,r,s);return s&&(f=ze(f)),f=R(f,i),Rt({x:f.x,y:f.y,ref:h})}else throw new Error("No suitable constructor")}},Vr=class{static fromPointArc(t,e){return E.new("pa",{p:t,arc:e})}static fromOuterTangents(t,e){return E.new("ot",{arc0:t,arc1:e})}static fromInnerTangents(t,e){return E.new("it",{arc0:t,arc1:e})}static fromPointEllipse(t,e){return E.new("pe",{p:t,ellipse:e})}compute(t){let{dependencies:e}=t;if(t.name==="pa"){let{p:n,arc:r}=e;C(n,r),y(n,O),y(r,J);let s=dn(n,r.center,r.r,{angleMin:r.startAngle,angleMax:r.endAngle});return!s||s.length===0?X:s.map(i=>N(i))}if(t.name==="pe"){let{p:n,ellipse:r}=e;C(n,r),y(n,O),y(r,ct);let{center:s,rx:i,ry:c,rotation:l,startAngle:o,endAngle:a}=r,[f]=Yt([n],s,l,i,c),h=dn(f,vt(0,0),1,{angleMin:o,angleMax:a});return!h||h.length===0?X:(h=Kt(h,s,l,i,c),h.map(p=>N(p)))}else if(t.name==="ot"){let{arc0:n,arc1:r}=e;C(n,r),y(n,J),y(r,J);let s=ys(n,r);return!s||s.length===0||s.length%2!==0?X:s.map(i=>N(i))}else if(t.name==="it"){let{arc0:n,arc1:r}=e;C(n,r),y(n,J),y(r,J);let s=gs(n,r);return!s||s.length===0||s.length%2!==0?X:s.map(i=>N(i))}else throw new Error("No suitable constructor")}},Yr=class{static fromPointArc(t,e,{leftOpen:n=!1,rightOpen:r=!1}={}){return E.new("pa",{p:t,arc:e},{leftOpen:n,rightOpen:r})}static fromPointEllipse(t,e,{leftOpen:n=!1,rightOpen:r=!1}={}){return E.new("pe",{p:t,ellipse:e},{leftOpen:n,rightOpen:r})}static fromOuterTangents(t,e,{leftOpen:n=!1,rightOpen:r=!1}={}){return E.new("ot",{arc0:t,arc1:e},{leftOpen:n,rightOpen:r})}static fromInnerTangents(t,e,{leftOpen:n=!1,rightOpen:r=!1}={}){return E.new("it",{arc0:t,arc1:e},{leftOpen:n,rightOpen:r})}compute(t){let{dependencies:e}=t,{params:n}=t;if(t.name==="pa"){let{p:r,arc:s}=e,{leftOpen:i,rightOpen:c}=n;C(r,s),y(r,O),y(s,J);let l=dn(r,s.center,s.r,{angleMin:s.startAngle,angleMax:s.endAngle});if(!l||l.length===0)return X;let o=[],a=N(r);for(let f of l){let h=N(f);o.push(Xt({p0:a,p1:h,leftOpen:i,rightOpen:c}))}return o}if(t.name==="pe"){let{p:r,ellipse:s}=e,{leftOpen:i,rightOpen:c}=n;C(r,s),y(r,O),y(s,ct);let{center:l,rx:o,ry:a,rotation:f,startAngle:h,endAngle:p}=s,[m]=Yt([r],l,f,o,a),w=dn(m,vt(0,0),1,{angleMin:h,angleMax:p});if(!w||w.length===0)return X;w=Kt(w,l,f,o,a);let A=[],x=N(r);for(let v of w){let M=N(v);A.push(Xt({p0:x,p1:M,leftOpen:i,rightOpen:c}))}return A}else if(t.name==="ot"){let{arc0:r,arc1:s}=e,{leftOpen:i,rightOpen:c}=n;C(r,s),y(r,J),y(s,J);let l=ys(r,s);if(!l||l.length===0||l.length%2!==0)return X;let o=[];for(let a=0;a<l.length;a+=2){let f=l[a+0],h=l[a+1];o.push(Xt({p0:f,p1:h,leftOpen:i,rightOpen:c}))}return o}else if(t.name==="it"){let{arc0:r,arc1:s}=e,{leftOpen:i,rightOpen:c}=n;C(r,s),y(r,J),y(s,J);let l=gs(r,s);if(!l||l.length===0||l.length%2!==0)return X;let o=[];for(let a=0;a<l.length;a+=2){let f=l[a+0],h=l[a+1];o.push(Xt({p0:f,p1:h,leftOpen:i,rightOpen:c}))}return o}else throw new Error("No suitable constructor")}},Wr=class{static fromObject(t){return E.new("o",{obj:t})}static fromPoints(...t){return E.new("p",[...t])}computeMidpointPoints(t){let e=0,n=0;if(t.length<1)return{x:1/0,y:1/0};for(let r=0;r<t.length;r++){let s=t[r];e+=s.x,n+=s.y}return e/=t.length,n/=t.length,L.new(e,n)}compute(t){let{dependencies:e}=t;if(t.name==="o"){let{obj:n}=e;if(C(n),Array.isArray(n)){for(let r=0;r<n.length;r++){let s=n[r];y(s,O)}return N(this.computeMidpointPoints(n))}else{if(n.type===O)return n;if(n.type===Q){let r=n.p0.x+n.p1.x,s=n.p0.y+n.p1.y;return r*=.5,s*=.5,N({x:r,y:s})}else{if(n.type===$)return N(q(n.ref,R(n,.5)));if(n.type===J)return N(n.center);if(n.type===ct)return N(n.center);if(n.type===ot)return N(this.computeMidpointPoints(n.points))}}throw new Error("Object type not supported")}else if(t.name==="p"){if(!Array.isArray(e))throw new Error("Expected array");let n=0,r=0;for(let s=0;s<e.length;s++){let i=e[s];y(i,O),n+=i.x,r+=i.y}return n/=e.length,r/=e.length,N({x:n,y:r})}throw new Error("No suitable constructor available")}},Ur=class{static fromEllipse(t){return E.new("eli",{ellipse:t})}compute(t){let{dependencies:e}=t;if(t.name==="eli"){let{ellipse:n}=e;C(n),y(n,ct);let{center:r,rx:s,ry:i,rotation:c}=n;if(Math.abs(s,i)<1e-10)return[N(r)];let l=Math.max(s,i),o=Math.min(s,i),a=Math.sqrt(l*l-o*o),f=[];return s>=i?(f.push(vt(a,0)),f.push(vt(-a,0))):(f.push(vt(0,a)),f.push(vt(0,-a))),f=f.map(h=>de(h,c)),f=f.map(h=>q(h,r)),f.map(h=>N(h))}else throw new Error("No suitable constructor available")}},jr=class{constructor(t){this.f=t}static from(t={},e={},n=!1){return E.new("f",t,e,n)}compute(t){let{dependencies:e,params:n}=t;if(t.name==="f")return this.f(e,n);throw new Error("No suitable constructor")}},Gr=class{constructor({p0:t={x:0,y:0},p1:e={x:0,y:0},leftOpen:n=!1,rightOpen:r=!1}={}){this.p0=t,this.p1=e,this.leftOpen=n,this.rightOpen=r}static fromVector(t){return E.new("v",{v:t})}static fromPointVector(t,e){return E.new("pv",{p:t,v:e})}static fromPoints(t,e){return E.new("pp",{p0:t,p1:e})}compute(t){let{dependencies:e}=t,{p0:n,p1:r,leftOpen:s,rightOpen:i}=this;if(t.name==="v"){let{v:c}=e;if(c.type!==$)throw new Error(`Require vector, got ${c.type} `);n=c.ref,r=q(n,c)}else if(t.name==="pv"){let{p:c,v:l}=e;if(c.type!==O)throw new Error(`Require point, got ${c.type} `);if(l.type!==$)throw new Error(`Require vector, got ${l.type} `);n=c,r=q(n,l)}else if(t.name==="pp"){let{p0:c,p1:l}=e;if(c.type!==O)throw new Error(`Require point, got ${c.type} `);if(l.type!==O)throw new Error(`Require vector, got ${l.type} `);n=c,r=l}else if(t!==dt)throw new Error("No suitable LineSegment constructor found");return Xt({p0:n,p1:r,leftOpen:s,rightOpen:i})}},Jr=class{constructor(t=[]){this.points=t}static fromPoints(t,e=!1){return E.new("p",t,{attach:e})}static fromPointArray(t,e=!1){return E.new("pa",{pointArray:t},{attach:e})}static fromPolygon(t,e=!1){return E.new("poly",{poly:t},{attach:e})}compute(t){let{dependencies:e}=t,{points:n}=this,{attach:r}=t.params;if(t.name==="p"){r?n=[...n]:n=[];for(let s of e)C(s),y(s,O),n.push(s)}else if(t.name==="poly"){let{poly:s}=e;C(s),y(s,ot),r?n.push(...s.points):n=[...s.points]}else if(t.name==="pa"){let{pointArray:s}=e;if(C(s),!Array.isArray(s))throw new Error("Expected array");for(let i of s)C(i),y(i,O);r?n=[...n,...s]:n=s}else if(t!==dt)throw new Error("No suitable constructor");return Jn({points:n})}},Qr=class{constructor(t=[]){this.points=t}static fromPoints(t,e=!1){return E.new("p",t,{attach:e})}static fromPointArray(t,e=!1){return E.new("pa",{pointArray:t},{attach:e})}static fromLineStrip(t,e=!1){return E.new("ls",{lineStrip:t},{attach:e})}static fromClipLine(t,e){return E.new("cl",{poly:t,line:e})}static fromClipPointNormal(t,{p:e=b,n}={}){return E.new("cpn",{poly:t,p:e,n})}static fromClipPoly(t,e){return E.new("clp",{poly:t,clipPoly:e})}static fromConvexHull(t){return Array.isArray(t)||(t=[t]),E.new("cnv",t)}compute(t){let{dependencies:e}=t,{points:n}=this,{attach:r}=t.params;if(t.name==="p"){r?n=[...n]:n=[];for(let s of e)C(s),y(s,O),n.push(s)}else if(t.name==="ls"){let{lineStrip:s}=e;C(s),y(s,ut),r?n.push(...n):n=[...s.points]}else if(t.name==="pa"){let{pointArray:s}=e;if(C(s),!Array.isArray(s))throw new Error("Expected array");for(let i of s)C(i),y(i,O);r?n=[...n,...s]:n=s}else if(t.name==="cl"){let{poly:s,line:i}=e;C(s,i),y(s,ot),y(i,Q);let{p0:c,p1:l}=i,o=L.sub(l,c),a=L.normal2D(o),f=Fn(c,a);n=Vn(s.points,f)}else if(t.name==="cpn"){let{poly:s,p:i,n:c}=e;C(s,c),y(s,ot),y(c,$);let l=c.ref;S(i)||(y(i,O),l=i);let o=Fn(l,c);n=Vn(s.points,o)}else if(t.name==="clp"){let{poly:s,clipPoly:i}=e;C(s,i),y(s,ot),y(i,ot),n=js(s.points,i.points)}else if(t.name==="cnv"){let s=e;if(C(s),!Array.isArray(s))return X;let i=[];for(let c=0;c<s.length;c++){let l=s[c];if(Array.isArray(l))for(let o=0;o<l.length;o++){let a=l[o];C(a),y(a,O),i.push(a)}else C(l),y(l,O),i.push(l)}if(n=Ys(i),n.length<3)return X}else if(t!==dt)throw new Error("No suitable constructor");return Qn({points:n})}},Yn=class u{constructor(t=[]){this.points=t}static fromPoints(t,e=!1){return E.new("p",t,{attach:e})}static fromPointArray(t,e=!1){return E.new("pa",{pointArray:t},{attach:e})}static fromHermite(t,e,n,r){return E.new("hm",{p0:t,t0:e,p1:n,t1:r})}static hermiteToCubic(t,e,n,r){let s=t,i=L.add(t,L.scale(e,1/3)),c=L.sub(n,L.scale(r,1/3));return[s,i,c,n]}compute(t){let{dependencies:e}=t,{points:n}=this,{attach:r}=t.params;if(t.name==="p"){r?n=[...n]:n=[];for(let s of e)C(s),y(s,O),n.push(s)}else if(t.name==="pa"){let{pointArray:s}=e;if(C(s),!Array.isArray(s))throw new Error("Expected array");for(let i of s)C(i),y(i,O);r?n=[...n,...s]:n=s}else if(t.name==="hm"){let{p0:s,t0:i,p1:c,t1:l}=e;C(s,i,c,l),y(s,O),y(i,$),y(c,O),y(l,$),n=u.hermiteToCubic(s,i,c,l)}else if(t!==dt)throw new Error("No suitable constructor");return Zn({points:n})}},Zr=class{constructor({points:t=[],degree:e=1}={}){this.points=t,this.degree=e}static fromPoints(t,e=!1){return E.new("p",t,{attach:e})}static fromPointArray(t,e=!1){return E.new("pa",{pointArray:t},{attach:e})}static fromCatmullRom(t){return Array.isArray(t)||(t=[t]),E.new("cm",t)}compute(t){let{dependencies:e}=t,{points:n}=this,{degree:r}=this,{attach:s}=t.params;if(t.name==="p"){s?n=[...n]:n=[];for(let i of e)C(i),y(i,O),n.push(i)}else if(t.name==="pa"){let{pointArray:i}=e;if(C(i),!Array.isArray(i))throw new Error("Expected array");for(let c of i)C(c),y(c,O);s?n=[...n,...i]:n=i}else if(t.name==="cm"){let i=e;i.length===1&&Array.isArray(i[0])&&(i=i[0]);for(let l of i)C(l),y(l,O);if(i.length<2)throw new Error("Need at least two points for Catmull-Rom spline");let c=[];for(let l=0;l<i.length;l++){let o=Math.max(0,l-1),a=Math.min(i.length-1,l+1),f=L.scale(L.sub(i[a],i[o]),.5);c.push(f)}r=3,n=[i[0]];for(let l=0;l<i.length-1;l++){let o=i[l],a=c[l],f=i[l+1],h=c[l+1],[p,m,w,A]=Yn.hermiteToCubic(o,a,f,h);n.push(m,w,A)}}else if(t!==dt)throw new Error("No suitable constructor");return Kn({points:n,degree:r})}},Kr=class u{static fromArc(t){return E.new("arc",{arc:t})}static fromValues(t,e,n){return E.new("v",{r:t,startAngle:e,endAngle:n})}static calcArcLength(t,e,n){return e=at(e),n=at(n),n<e&&(n+=2*Math.PI),(n-e)*t}compute(t){let{dependencies:e}=t;if(t.name==="arc"){let{arc:n}=e;C(n),y(n,J);let{r,startAngle:s,endAngle:i}=n;return ye(u.calcArcLength(r,s,i))}else if(t.name==="v"){let{r:n,startAngle:r,endAngle:s}=e;return ye(u.calcArcLength(n,r,s))}else throw new Error("No suitable constructor")}},je=class{static fromVectorOrLine(t){return E.new("vl",{v:t})}static fromPoints(t,e){return E.new("pp",{p0:t,p1:e})}compute(t){let e=0,n=0,{dependencies:r}=t;if(t.name==="vl"){let{v:s}=r;if(C(s),y(s,$,Q),s.type===$)e=s.x,n=s.y;else if(s.type===Q){let{p0:i,p1:c}=s;e=c.x-i.x,n=c.y-i.y}}else if(t.name==="pp"){let{p0:s,p1:i}=r;C(s,i),y(s,O),y(i,O),e=i.x-s.x,n=i.y-s.y}else throw new Error("No suitable constructor found");return ye(e*e+n*n)}},Xr=class{constructor(){this.ds=new je}static fromVectorOrLine(t){return je.fromVectorOrLine(t)}static fromPoints(t,e){return je.fromPoints(t,e)}compute(t){let e=this.ds.compute(t);return e.value=Math.sqrt(e.value),e}},Hr=class{constructor(t){this.key=t}static fromObject(t,e=null){return E.new("o",{obj:t},{transform:e})}compute(t){let{dependencies:e}=t;if(t.name==="o"){let{obj:n}=e,{transform:r}=t.params;C(n);let s=n[this.key];return s===void 0?X:(r&&r instanceof Function&&(s=r(s)),s)}else throw new Error("No suitable constructor found")}},_r=class{constructor(...t){this.chain=[...t]}compute(t){let e=this.chain,n=t;for(let r=0;r<e.length;r++){let s=e[r];s instanceof Function?n=s(n):n=e[r].compute(n)}return n}},ts=class{constructor(t){this.f=t}static fromArray(t){return E.new("a",t)}static fromValues(...t){return E.new("v",[...t])}compute(t){let{dependencies:e}=t,n=new Array(e.length),{f:r}=this;for(let s=0;s<e.length;s++)r instanceof Function?n[s]=r(e[s]):n[s]=r.compute(e[s]);return n}},es=class u{constructor({r:t=1,center:e={x:0,y:0},startAngle:n=0,endAngle:r=2*Math.PI}={}){this.r=t,this.center=e,this.startAngle=n,this.endAngle=r}static fromValues({r:t=b,center:e=b,startAngle:n=b,endAngle:r=b}){return E.new("v",{r:t,center:e,startAngle:n,endAngle:r})}static fromPoints({p0:t,p1:e,p2:n,fullCircle:r=!1}){return E.new("ppp",{p0:t,p1:e,p2:n},{fullCircle:r})}static fromCenterAndPoints(t,e,n,r=Ue.USE_COMPUTED_ANGLE){return E.new("cap",{center:t,p0:e,p1:n},{useAngle:r})}static computeParametersFromPoints(t,e,n,r){let s=[t.x,t.y],i=[e.x,e.y],c=[n.x,n.y];if(Nn(s,i)||Nn(i,c)||Nn(c,s))return null;let l=Bn(Ct(c,s),Ct(i,s));if(Math.abs(l[1])<this.eps)return null;let o=qt(l,as(l)),a=un(Bn(qt(Ct(i,s),Ct(l,o)),qt([0,2],[Ht(l),0])),s),f=Un(Ct(s,a));if(r)return{r:f,center:{x:ne(a),y:Ht(a)},startAngle:0,endAngle:2*Math.PI};{let h={x:ne(a),y:Ht(a)},p=[$t(t.x-h.x,t.y-h.y),$t(e.x-h.x,e.y-h.y),$t(n.x-h.x,n.y-h.y)],m=Math.min(...p),w=Math.max(...p);return{r:f,center:h,startAngle:m,endAngle:w}}}compute(t){let{r:e,center:n,startAngle:r,endAngle:s}=this,{dependencies:i,params:c}=t;if(t.name==="v"){let{r:l,center:o,startAngle:a,endAngle:f}=i;S(l)||(y(l,G),e=l.value),S(o)||(y(o,O),n=o),S(a)||(y(a,G),r=a.value),S(f)||(y(f,G),s=f.value)}else if(t.name==="ppp"){let{p0:l,p1:o,p2:a}=i;C(l,o,a),y(l,O),y(o,O),y(a,O);let{fullCircle:f}=t.params,h=u.computeParametersFromPoints(l,o,a,f);if(!h)return X;({r:e,center:n,startAngle:r,endAngle:s}=h)}else if(t.name==="cap"){let{center:l,p0:o,p1:a}=i;C(l,o,a),y(l,O),y(o,O),y(a,O);let f=o.x-l.x,h=o.y-l.y,p=f*f+h*h,m=Math.sqrt(p),w=a.x-l.x,A=a.y-l.y,x=w*w+A*A;if(Math.abs(p-x)>1e-7)return X;r=$t(o.x-l.x,o.y-l.y),s=$t(a.x-l.x,a.y-l.y);let v=r,M=s;M<v&&(M+=2*Math.PI);let{useAngle:P}=c,T=M-v;P===Ue.USE_SMALLER_ANGLE?T>Math.PI&&([v,M]=[M,v]):P===Ue.USE_LARGER_ANGLE&&T<Math.PI&&([v,M]=[M,v]),r=v,s=M,n=l,e=m}else if(t!==dt)throw new Error("No suitable constructor found");return ue({r:e,center:n,startAngle:r,endAngle:s})}},ns=class{constructor({center:t={x:0,y:0},rx:e=1,ry:n=1,startAngle:r=0,endAngle:s=2*Math.PI,rotation:i=0}={}){this.center=t,this.rx=e,this.ry=n,this.startAngle=r,this.endAngle=s,this.rotation=i}static fromValues({center:t=b,rx:e=b,ry:n=b,startAngle:r=b,endAngle:s=b,rotation:i=b}){return E.new("v",{center:t,rx:e,ry:n,startAngle:r,endAngle:s,rotation:i})}compute(t){let{center:e,rx:n,ry:r,startAngle:s,endAngle:i,rotation:c}=this,{dependencies:l}=t;if(t.name==="v"){let{center:o,rx:a,ry:f,startAngle:h,endAngle:p,rotation:m}=l;S(o)||(y(o,O),e=o),S(a)||(y(a,G),n=a.value),S(f)||(y(f,G),r=f.value),S(h)||(y(h,G),s=h.value),S(p)||(y(p,G),i=p.value),S(m)||(y(m,G),c=m.value)}else if(t!==dt)throw new Error("No suitable constructor");return Xn({center:e,rx:n,ry:r,startAngle:s,endAngle:i,rotation:c})}},rs=class{static fromObject(t,e){return E.new("o",{p:t,obj:e})}static fromCollection(t,e){let n=[t];if(Array.isArray(e))n.push(...e);else for(let r of Object.keys(e))n.push(e[r]);return E.new("mo",n)}compute(t){let{dependencies:e}=t,n=null;if(t.name==="o"){let{p:r,obj:s}=e;C(r,s),y(r,O),n=gn.closestPoint(r,s)}else if(t.name==="mo"){let[r,...s]=e;C(r,...s),y(r,O);let i=1/0;for(let c of s){C(c);let l=gn.closestPoint(r,c);if(!l)continue;let o=Wt(I(l,r));o<i&&(i=o,n=l)}}else throw new Error("No suitable constructor found");return n||X}},ss=class{static fromObjects(t,e,{takeIndex:n=-1}={}){return E.new("o",{obj0:t,obj1:e},{takeIndex:n})}compute(t){let{dependencies:e,params:n}=t;if(t.name==="o"){let{obj0:r,obj1:s}=e,{takeIndex:i}=n;C(r,s);let c=Dn.intersect(r,s);return c?(Array.isArray(c)||(c=[c]),i>=0?i>=c.length?X:c[i]:c):X}else throw new Error("No suitable constructor found")}},os=class{static fromObjects(t,{filterOutInvalid:e=!0,filterOutEmpty:n=!0,filterOutNull:r=!0,appendArrayDependencies:s=!1,ignoreInvalids:i=!1}={}){return E.new("o",t,{filterOutInvalid:e,filterOutEmpty:n,filterOutNull:r,appendArrayDependencies:s},i)}compute(t){let{dependencies:e}=t,{params:n}=t;if(t.name==="o"){let{filterOutInvalid:r,filterOutEmpty:s,filterOutNull:i,appendArrayDependencies:c}=n,l=[];for(let o of Object.keys(e)){let a=e[o];a===null&&i||a===b&&s||a===X&&r||(c&&Array.isArray(a)?l.push(...a):l.push(a))}return l}else throw new Error("No suitable constructor")}},is=class{constructor(t=.5){this.t=t}static fromObjects(t,e,n=b){return E.new("o",{obj0:t,obj1:e,t:n})}static fromAngle(t,e=b){return E.new("ang",{angle:t,t:e})}compute(t){let{dependencies:e}=t,{t:n}=this;if(t.name==="o"){let{obj0:r,obj1:s,t:i}=e;if(C(r,s),S(i)||(y(i,G),n=i.value),r.type!==s.type)throw new Error("Interpolation only defined for objects of same type");let c=r.type,l=1-n;if(c===G)return ye(l*r.value+n*s.vallue);if(c===O){let o=yt(r,s,n);return N(o)}else if(c===$){let o=yt(r,s,n),a=yt(r.ref,s.ref,n);return Rt({x:o.x,y:o.y,ref:a})}else if(c===Xe){let o=l*r.r+n*s.r,a=l*r.alpha+n*s.alpha;return fs({r:o,alpha:a})}else if(c===Me){let o=l*r.value+n*s.value,a=l*r.start+n*s.start,f=yt(r.ref,s.ref,n);return We({value:o,start:a,ref:f})}else if(c===J){let o=l*r.r+n*s.r,a=l*r.startAngle+n*s.startAngle,f=l*r.endAngle+n*s.endAngle,h=yt(r.center,s.center,n);return ue({r:o,startAngle:a,endAngle:f,center:h})}else if(c===ct){let o=l*r.rx+n*s.rx,a=l*r.ry+n*s.ry,f=l*r.rotation+n*s.rotation,h=l*r.startAngle+n*s.startAngle,p=l*r.endAngle+n*s.endAngle,m=yt(r.center,s.center,n);return Xn({center:m,rx:o,ry:a,startAngle:h,endAngle:p,rotation:f})}else if(c===Q){let o=yt(r.p0,s.p0,n),a=yt(r.p1,s.p1,n);return Xt({p0:o,p1:a,leftOpen:r.leftOpen||s.leftOpen,rightOpen:r.rightOpen||s.rightOpen})}else if(c===ut){let o=r.points,a=s.points;if(o.length!==a.length)throw new Error("Interpolated points number must be the same");let f=new Array(o.length);return o.forEach((h,p)=>{f[p]=yt(h,a[p])}),Jn({points:f})}else if(c===ot){let o=r.points,a=s.points;if(o.length!==a.length)throw new Error("Interpolated points number must be the same");let f=new Array(o.length);return o.forEach((h,p)=>{f[p]=yt(h,a[p])}),Qn({points:f})}else if(c===pt){let o=r.points,a=s.points;if(o.length!==a.length)throw new Error("Interpolated points number must be the same");let f=new Array(o.length);return o.forEach((h,p)=>{f[p]=yt(h,a[p])}),Zn({points:f})}else if(c===mt){let o=r.points,a=s.points;if(o.length!==a.length)throw new Error("Interpolated points number must be the same");if(r.degree!==s.degree)throw new Error("Interpolation of Bezier splines requires same degree");let f=new Array(o.length);return o.forEach((h,p)=>{f[p]=yt(h,a[p])}),Kn({points:f,degree:r.degree})}else throw new Error(`Interpolation of given type ${c} not supported`)}else if(t.name==="ang"){let{angle:r,t:s}=e;C(r),y(r,Me),S(s)||(y(s,G),n=s.value);let{start:i,value:c,ref:l}=r,o=n*c;return We({value:o,start:i,ref:l})}else throw new Error("No suitable construcotr")}},te,Ke,Ge=class{constructor(t){U(this,te);U(this,Ke);this.name=t,z(this,te,[]),z(this,Ke,0)}addCallback(t){let e=hr(this,Ke)._++;return g(this,te).push({cb:t,id:e}),e}removeCallback(t){let e=g(this,te).findIndex(n=>n.id===t);e>=0&&g(this,te).splice(e,1)}notify(t){for(let e=0;e<g(this,te).length;e++){let{cb:n}=g(this,te)[e];if(n(t))break}}};te=new WeakMap,Ke=new WeakMap;var wn=class{constructor(t,e){this.scene=t,this.index=e}},cs=class{constructor(t,e){this.scene=t,this.index=e}},xn=class{constructor(t,e){this.scene=t,this.index=e}},Bt,lt,kt,Jt,he,Qt,Ee,Zt,rt,Ye,Ae,xs,vs,fn,hn,Wn,Vt=class Vt{constructor(){U(this,rt);U(this,Bt);U(this,lt);U(this,kt);U(this,Jt);U(this,he);U(this,Qt);U(this,Ee);U(this,Zt);z(this,Bt,[]),z(this,lt,[]),z(this,kt,[]),z(this,Jt,[]),z(this,he,[]),z(this,Qt,[]),z(this,Ee,[]),z(this,Zt,{}),g(this,Zt)[Vt.EVENT_UPDATE]=new Ge(Vt.EVENT_UPDATE),g(this,Zt)[Vt.EVENT_PROPERTY]=new Ge(Vt.EVENT_PROPERTY),g(this,Zt)[Vt.EVENT_REMOVE]=new Ge(Vt.EVENT_REMOVE),this.validateLoopFree=!0}get validateLoopFree(){return this._validateLoopFree}set validateLoopFree(t){this._validateLoopFree=t}registerCallback(t,e){let n=g(this,Zt)[t];return n?n.addCallback(e):-1}removeCallback(t,e){let n=g(this,Zt)[t];n&&n.removeCallback(e)}add(t,e=null,n={}){let r=g(this,lt).length;return g(this,Ee).length>0&&(r=g(this,Ee).pop()),this.set(r,t,e,n)}get(t){if(t>=g(this,lt).length)return null;let e=g(this,Bt)[t],n=g(this,lt)[t],r=g(this,kt)[t],s=g(this,Qt)[t];return{value:e,definition:n,createInfo:r,index:t,properties:s}}set(t,e,n=null,r={}){var c;if(n||(n=dt),g(this,kt)[t]){if(this.validateLoopFree&&D(this,rt,xs).call(this,t,n))throw new Error(`Adding element ${t} with dependencies[${JSON.stringify(n)}] would create a loop`);D(this,rt,Wn).call(this,t)}D(this,rt,Ae).call(this,g(this,lt),t),D(this,rt,Ae).call(this,g(this,kt),t),D(this,rt,Ae).call(this,g(this,Jt),t),D(this,rt,Ae).call(this,g(this,he),t),D(this,rt,Ae).call(this,g(this,Bt),t),D(this,rt,Ae).call(this,g(this,Qt),t),g(this,kt)[t]=n,g(this,lt)[t]=e,g(this,Qt)[t]=r;let i=n.dependencies;for(let l of Object.keys(i)){let o=i[l];if(o===b||o<0)continue;let a=(c=g(this,Jt)[o])!=null?c:[];a.push(t),g(this,Jt)[o]=a}return D(this,rt,hn).call(this,t),D(this,rt,fn).call(this,t),t}update(t,e){if(t>=g(this,lt).length||!g(this,lt)[t])throw new Error(`Trying to update non - existent definition at index ${t} `);g(this,lt)[t]=e,D(this,rt,fn).call(this,t)}setProperties(t,e){if(t>=g(this,lt).length||!g(this,lt)[t])throw new Error(`Trying to update non - existent property at index ${t} `);g(this,Qt)[t]=e,D(this,rt,Ye).call(this,"property",new xn(this,t))}updateProperties(t,e){if(t>=g(this,lt).length||!g(this,lt)[t])throw new Error(`Trying to update non - existent property at index ${t} `);zn(g(this,Qt)[t],e),D(this,rt,Ye).call(this,"property",new xn(this,t))}remove(t){if(t>=g(this,lt).length)throw new Error(`Trying to delete non - existent definition at index ${t} `);if(!g(this,lt)[t])throw new Error(`Trying to delete non - existent definition at index ${t} `);D(this,rt,Ye).call(this,"remove",new wn(this,t)),D(this,rt,Wn).call(this,t),g(this,kt)[t]=null,g(this,he)[t]=null,g(this,lt)[t]=null,g(this,Qt)[t]=null,g(this,Ee).push(t)}view({skipInvalidValues:t=!0}={}){let e=0,n=g(this,lt),r=g(this,Bt),s=this;return{*[Symbol.iterator](){for(;e<n.length;){for(;(!n[e]||t&&!dr(r[e]))&&e<n.length;)e++;e<n.length&&(yield s.get(e),e++)}}}}};Bt=new WeakMap,lt=new WeakMap,kt=new WeakMap,Jt=new WeakMap,he=new WeakMap,Qt=new WeakMap,Ee=new WeakMap,Zt=new WeakMap,rt=new WeakSet,Ye=function(t,e){let n=g(this,Zt)[t];if(!n)throw"Trying to notify events that do not exist";n.notify(e)},Ae=function(t,e){let n=t.length;e>=n&&(t.length=e+1)},xs=function(t,e){let n=[],r=e.dependencies;for(Object.keys(r).forEach(s=>n.push(r[s]));n.length>0;){let s=n.pop();if(s===b||s<0)continue;if(s===t)return!0;let i=g(this,kt)[s].dependencies;Object.keys(i).forEach(c=>n.push(i[c]))}return!1},vs=function(t){var l,o,a;let e=[t],n={};n[t]={idx:t,entries:{}};let r=[t];for(;r.length>0;){let f=r.shift(),h=(l=g(this,Jt)[f])!=null?l:[],p=(o=n[f])!=null?o:{idx:f,entries:{}};for(let m of h)p.entries[m]=m;r.push(...h),n[f]=p}let s={};s[t]=0;for(let f of Object.keys(n)){let{idx:h,entries:p}=n[f];for(let m of Object.keys(p)){let w=(a=s[m])!=null?a:0;s[m]=w+1}}let i=[];for(let f of Object.keys(s))s[f]===0&&i.push(f);let c=[];for(;i.length>0;){let f=i.shift(),{idx:h,entries:p}=n[f];c.push(h);for(let m of Object.keys(p)){let w=s[m];w--,w<1&&i.push(m),s[m]=w}}return c},fn=function(t){let e=g(this,he)[t];for(let n of e){let r=g(this,kt)[n],s=g(this,lt)[n];if(g(this,Bt)[n]=X,s)if(r===dt)g(this,Bt)[n]=s.compute(dt);else{let{dependencies:i}=r,c={name:r.name,dependencies:Array.isArray(i)?[]:{},params:r.params,ignoreInvalids:r.ignoreInvalids},l=c.dependencies,o=!0;for(let a of Object.keys(i)){let f=i[a];if(f===b||f<0)l[a]=b;else{let h=g(this,Bt)[f];if(!dr(h))if(r.ignoreInvalids)h=X;else{o=!1;break}l[a]=h}}o?g(this,Bt)[n]=s.compute(c):g(this,Bt)[n]=X}D(this,rt,Ye).call(this,"update",new wn(this,n))}},hn=function(t){g(this,he)[t]=D(this,rt,vs).call(this,t);let e=g(this,kt)[t].dependencies;for(let n of Object.keys(e)){let r=e[n];r===b||r<0||D(this,rt,hn).call(this,r)}},Wn=function(t){var s;let n=g(this,kt)[t].dependencies;g(this,kt)[t]=null,g(this,Bt)[t]=X;let r=(s=g(this,Jt)[t])!=null?s:[];for(let i of r)D(this,rt,fn).call(this,i);for(let i of Object.keys(n)){let c=n[i];if(c===b||c<0)continue;let l=g(this,Jt)[c];if(l===void 0)throw new Error(`Trying to remove dependency ${t} from ${c} `);let o=l.findIndex(a=>a===t);if(o<0)throw new Error(`Trying to remove dependency ${t} from ${c} `);l.splice(o,1),D(this,rt,hn).call(this,c)}},ht(Vt,"EVENT_UPDATE","update"),ht(Vt,"EVENT_PROPERTY","property"),ht(Vt,"EVENT_REMOVE","remove");var re=Vt;var Nt={primitives:{line:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0},text:{font:"10px sans-serif",textAlign:"start",textBaseline:"alphabetic",direction:"inherit",fontKerning:"auto"}},geo:{point:{r:4,fillStyle:"rgb(255,0,0)",strokeStyle:"rgb(0,0,0)",outline:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}},text:{fillStyle:"rgb(0,0,0)",strokeStyle:"rgba(0,0,0,0)",outline:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0},textStyle:{font:"10px sans-serif",textAlign:"start",textBaseline:"alphabetic",direction:"inherit",fontKerning:"auto"},offset:{x:0,y:0}},angle:{r:20,toDeg:!0,arc:{showDirection:!0,fillStyle:"rgba(255,0,0,0.25)",strokeStyle:"rgb(0,0,0)",outline:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}},text:{show:!0,fillStyle:"rgb(0,0,0)",strokeStyle:"rgba(0,0,0,0)",radius:1.5,textStyle:{font:"10px sans-serif",textAlign:"start",textBaseline:"alphabetic",direction:"inherit",fontKerning:"auto"},outline:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0},transform:(u,t)=>{let n=new Intl.NumberFormat("en-US",{minimumFractionDigits:0,maximumFractionDigits:0}).format(u);return t?`${n}\xB0`:`${n}`}}},arc:{fillStyle:"rgba(0,0,0,0)",strokeStyle:"rgb(0,0,0)",outline:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0},closeArc:!1},line:{strokeStyle:"rgb(0,0,0)",lineStyle:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}},vector:{shaft:{fillStyle:"rgb(0,0,0)",strokeStyle:"rgb(0,0,0)",lineStyle:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}},arrow:{length:.2,width:.05,sizeRelative:!0,fillStyle:"rgb(0,0,0)",strokeStyle:"rgb(0,0,0)",lineStyle:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}}},coordinateSystem:{origin:{r:2,fillStyle:"rgb(0,0,0)",strokeStyle:"rgb(0,0,0)",outline:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}},u:{shaft:{fillStyle:"rgb(255,0,0)",strokeStyle:"rgb(255,0,0)",lineStyle:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}},arrow:{length:.2,width:.05,sizeRelative:!0,fillStyle:"rgb(255,0,0)",strokeStyle:"rgb(255,0,0)",lineStyle:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}}},v:{shaft:{fillStyle:"rgb(0,0,255)",strokeStyle:"rgb(0,0,255)",lineStyle:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}},arrow:{length:.2,width:.05,sizeRelative:!0,fillStyle:"rgb(0,0,255)",strokeStyle:"rgb(0,0,255)",lineStyle:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}}}},polygon:{strokeStyle:"rgb(0,0,255)",fillStyle:"rgba(0,0,255,0.25)",lineStyle:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}}}};function He(u,t,e){let n=e.getBoundingClientRect(),r=u-n.left,s=t-n.top;return{x:r,y:s}}function Sn(u){return He(u.clientX,u.clientY,u.target)}var cr={grid:{show:!1},axes:{show:!1}},fo={grid:{strokeStyle:"rgb(192,192,192)",lineStyle:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0},xticks:1,yticks:1,show:!0},axes:{show:!0,x:{strokeStyle:"rgb(0,0,0)",lineStyle:{lineWidth:2,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0},ticks:{show:!0,spacing:1,size:.1,strokeStyle:"rgb(0,0,0)",lineStyle:{lineWidth:2,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}},labels:{show:!0,strokeStyle:"rgb(192,192,192)",fillStyle:"rgb(192,192,192)",textStyle:{font:"10px sans-serif",textAlign:"center",textBaseline:"hanging",direction:"inherit",fontKerning:"auto"}},show:!0},y:{strokeStyle:"rgb(0,0,0)",lineStyle:{lineWidth:2,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0},ticks:{show:!0,spacing:1,size:.1,strokeStyle:"rgb(0,0,0)",lineStyle:{lineWidth:2,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}},labels:{show:!0,strokeStyle:"rgb(192,192,192)",fillStyle:"rgb(192,192,192)",textStyle:{font:"10px sans-serif",textAlign:"right",textBaseline:"middle",direction:"inherit",fontKerning:"auto"}},show:!0},numberFormatter:null}};function bn(u,t,e,n,r,s){let i=u*Math.ceil(t/u),c=(i-t)/e,l=u/e,o=e/u,a=[];for(let f=0;f<o;f++){let h=c+f*l,p=i+f*u;n&&(h=1-h),h=h*s+r,a.push([p,h])}return a}var Ut,Pe,St,H,tt,se,Hn,Ss,bs,Ts,Os,_n,Ls,ks,Cs,Ns,wt=class wt{constructor(t,e,n,r){U(this,tt);U(this,St);U(this,H);this.scene=t,this.writePoints=[],this.readPoints=[],this.handlers={};for(let s of r){let{write:i,read:c,radius:l}=s;this.writePoints.push(i),this.readPoints.push({index:c,radius:l})}z(this,St,0),z(this,H,{}),this.attach(n,e)}detach(){for(let t of Object.keys(this.handlers))D(this,tt,Hn).call(this,t);g(this,H).down=!1,g(this,H).lastPos=null,g(this,H).lastDownPos=null,z(this,St,g(wt,Ut))}attach(t,e){this.detach(),this.handlers={},this.canvas=t,this.coordinateMapper=e,D(this,tt,se).call(this,"mousedown",n=>D(this,tt,Ls).call(this,n)),D(this,tt,se).call(this,"mouseup",n=>D(this,tt,ks).call(this,n)),D(this,tt,se).call(this,"mouseleave",n=>D(this,tt,Cs).call(this,n)),D(this,tt,se).call(this,"mousemove",n=>D(this,tt,Ns).call(this,n)),D(this,tt,se).call(this,"touchstart",n=>D(this,tt,Ss).call(this,n)),D(this,tt,se).call(this,"touchend",n=>D(this,tt,bs).call(this,n)),D(this,tt,se).call(this,"touchmove",n=>D(this,tt,Ts).call(this,n)),D(this,tt,se).call(this,"touchcancel",n=>D(this,tt,Os).call(this,n))}static createForPoints(t,e,n,r,s){let i=[];for(let c of r)i.push({read:c,write:c,radius:s});return new wt(t,e,n,i)}static createForPointsAndHandles(t,e,n,r,s){let i=[];for(let c=0;c<r.length;c++){let l=r[c],o,a;Array.isArray(l)&&l.length===2?l.length===2?[o,a]=l:(o=l[0],a=o):(o=l,a=o),i.push({read:o,write:a,radius:s})}return new wt(t,e,n,i)}};Ut=new WeakMap,Pe=new WeakMap,St=new WeakMap,H=new WeakMap,tt=new WeakSet,se=function(t,e){D(this,tt,Hn).call(this,t),this.canvas.addEventListener(t,e),this.handlers[t]=e},Hn=function(t){let e=this.handlers[t];e&&(this.canvas.removeEventListener(t,e),delete this.handlers[t])},Ss=function(t){if(!t.touches[0])return;let e=t.touches[0],n=He(e.clientX,e.clientY,this.canvas);if(g(this,H).down=!0,g(this,H).lastPos=n,g(this,H).lastDownPos=n,g(this,St)===g(wt,Ut)){let r=this.coordinateMapper.convertSurfaceToLocal(n.x,n.y),s=D(this,tt,_n).call(this,r);s>=0&&(z(this,St,g(wt,Pe)),g(this,H).idx=s),g(this,H).lastTime=new Date().getTime()}},bs=function(t){let e=t.changedTouches[0],n=He(e.clientX,e.clientY,this.canvas);g(this,H).down=!1,g(this,H).lastPos=n,g(this,H).lastDownPos=null,z(this,St,g(wt,Ut))},Ts=function(t){let e=t.touches[0],n=He(e.clientX,e.clientY,this.canvas),r=this.coordinateMapper.convertSurfaceToLocal(n.x,n.y);if(g(this,St)===g(wt,Pe)){if(new Date().getTime()-g(this,H).lastTime<40){g(this,H).down=!1,g(this,H).lastDownPos=null,z(this,St,g(wt,Ut));return}if(t.preventDefault(),!t.touches[0])return;let{idx:c}=g(this,H),l=this.writePoints[c];r.x=Math.max(this.coordinateMapper.x0,Math.min(r.x,this.coordinateMapper.x1)),r.y=Math.max(this.coordinateMapper.y0,Math.min(r.y,this.coordinateMapper.y1)),this.scene.update(l,new Ze(r.x,r.y))}g(this,H).lastPos=n},Os=function(t){let e=t.changedTouches[0],n=He(e.clientX,e.clientY,this.canvas);g(this,H).down=!1,g(this,H).lastPos=n,g(this,H).lastDownPos=null,z(this,St,g(wt,Ut))},_n=function(t){let e=this.scene,n=-1,r=1/0;for(let s=0;s<this.readPoints.length;s++){let i=this.readPoints[s],c=e.get(i.index).value;y(c,O);let l=L.len2(L.sub(c,t)),o=i.radius/this.coordinateMapper.scalingLocalToSurface(),a=o*o;l<a&&l<r&&(r=l,n=s)}return n},Ls=function(t){let e=Sn(t);if(g(this,H).down=!0,g(this,H).lastPos=e,g(this,H).lastDownPos=e,g(this,St)===g(wt,Ut)){let n=this.coordinateMapper.convertSurfaceToLocal(e.x,e.y),r=D(this,tt,_n).call(this,n);r>=0&&(z(this,St,g(wt,Pe)),g(this,H).idx=r)}},ks=function(t){let e=Sn(t);g(this,H).down=!1,g(this,H).lastPos=e,g(this,H).lastDownPos=null,z(this,St,g(wt,Ut))},Cs=function(t){let e=Sn(t);g(this,H).down=!1,g(this,H).lastPos=e,g(this,H).lastDownPos=null,z(this,St,g(wt,Ut))},Ns=function(t){let e=Sn(t),n=this.coordinateMapper.convertSurfaceToLocal(e.x,e.y);if(g(this,St)===g(wt,Pe)){let{idx:r}=g(this,H),s=this.writePoints[r];this.scene.update(s,new Ze(n.x,n.y))}g(this,H).lastPos=e},U(wt,Ut,0),U(wt,Pe,1);var As=wt;function Gs(u,t,e,n,r,s,i){let c=u,l=c.viewportCorners,o=c.viewportSides,a=n-t,f=r-e,h={x:t,y:e},p={x:n,y:r},m=s?-1/0:0,w=i?1/0:1;for(let P=0;P<o.length;P++){let T=o[P],k=Tt(h,p,T.p0,T.p1);if(!k)continue;T.n.x*a+T.n.y*f<0?m=Math.max(m,k.ua):w=Math.min(w,k.ua)}let A=t+m*a,x=e+m*f,v=t+w*a,M=e+w*f;return{p0:{x:A,y:x},p1:{x:v,y:M}}}var At=class At{constructor(){this.elements=[]}static new(){return new At}reset(){return this.elements=[],this}moveTo(t,e){return this.elements.push({type:At.MOVE,x:t,y:e}),this}lineTo(t,e){return this.elements.push({type:At.LINE_TO,x:t,y:e}),this}close(){return this.elements.push({type:At.CLOSE}),this}arc(t,e,n,r,s,i=!1){return this.elements.push({type:At.ARC,x:t,y:e,radius:n,startAngle:r,endAngle:s,counterclockwise:i}),this}ellipse(t,e,n,r,s,i,c,l=!1){return this.elements.push({type:At.ELLIPSE,x:t,y:e,radiusX:n,radiusY:r,rotation:s,startAngle:i,endAngle:c,counterclockwise:l}),this}quadraticBezier(t,e,n,r){return this.elements.push({type:At.QUAD_BEZIER,x1:t,y1:e,x2:n,y2:r}),this}cubicBezier(t,e,n,r,s,i){return this.elements.push({type:At.CUBIC_BEZIER,x1:t,y1:e,x2:n,y2:r,x3:s,y3:i}),this}};ht(At,"MOVE",1),ht(At,"LINE_TO",2),ht(At,"ARC",3),ht(At,"ELLIPSE",4),ht(At,"CLOSE",5),ht(At,"QUAD_BEZIER",6),ht(At,"CUBIC_BEZIER",7);var _=At,On=class{begin(){}end(){}get width(){return 0}get height(){return 0}drawPath(t,{fill:e=!0,stroke:n=!0,style:r={}}={}){}drawRect(t,e,n,r,{fill:s=!0,stroke:i=!0,style:c={}}={}){let l=new _;l.moveTo(t,e),l.lineTo(t+n,e),l.lineTo(t+n,e+r),l.lineTo(t,e+r),l.close(),this.drawPath(l,{fill:s,stroke:i,style:c})}drawLine(t,e,n,r,{fill:s=!0,stroke:i=!0,style:c={}}={}){let l=new _;l.moveTo(t,e),l.lineTo(n,r),this.drawPath(l,{fill:s,stroke:i,style:c})}drawText(t,{fill:e=!0,stroke:n=!0,style:r={}}={}){}beginGroup(){}endGroup(){}},ge,_t,_e,er,tr=class extends On{constructor(e){super();U(this,_e);U(this,ge);U(this,_t);z(this,ge,e),z(this,_t,e.getContext("2d"))}get width(){return g(this,ge).width}get height(){return g(this,ge).height}set width(e){g(this,ge).width=e}set height(e){g(this,ge).height=e}begin(){g(this,_t).clearRect(0,0,g(this,_t).canvas.width,g(this,_t).canvas.height)}drawPath(e,{fill:n=!0,stroke:r=!0,style:s={}}={}){if(!e)return;let i=g(this,_t);i.save(),D(this,_e,er).call(this,s),i.beginPath();for(let c of e.elements){let l=c.type;l===_.MOVE?i.moveTo(c.x,c.y):l===_.LINE_TO?i.lineTo(c.x,c.y):l===_.ARC?i.arc(c.x,c.y,c.radius,c.startAngle,c.endAngle,c.counterclockwise):l===_.ELLIPSE?i.ellipse(c.x,c.y,c.radiusX,c.radiusY,c.rotation,c.startAngle,c.endAngle,c.counterclockwise):l===_.CLOSE?i.closePath():l===_.QUAD_BEZIER?i.quadraticCurveTo(c.x1,c.y1,c.x2,c.y2):l===_.CUBIC_BEZIER&&i.bezierCurveTo(c.x1,c.y1,c.x2,c.y2,c.x3,c.y3)}n&&i.fill(),r&&i.stroke(),i.restore()}drawText(e,n,r,{fill:s=!0,stroke:i=!1,style:c={}}={}){let l=g(this,_t);l.save(),D(this,_e,er).call(this,c),typeof e!="string"&&(e=""+e);let o=e.split(`
`),a=l.measureText(e),f=a.actualBoundingBoxAscent+a.actualBoundingBoxDescent;for(let h of o)i&&l.strokeText(h,n,r),s&&l.fillText(h,n,r),r+=f;l.restore()}};ge=new WeakMap,_t=new WeakMap,_e=new WeakSet,er=function(e){let n=g(this,_t);n.fillStyle=e.fillStyle?e.fillStyle:n.fillStyle,n.strokeStyle=e.strokeStyle?e.strokeStyle:n.strokeStyle,n.font=e.font?e.font:n.font,n.lineWidth=e.lineWidth?e.lineWidth:n.lineWidth,n.textAlign=e.textAlign?e.textAlign:n.textAlign,n.textBaseline=e.textBaseline?e.textBaseline:n.textBaseline,n.wordSpacing=e.wordSpacing?e.wordSpacing:n.wordSpacing,n.miterLimit=e.miterLimit?e.miterLimit:n.miterLimit,n.lineJoin=e.lineJoin?e.lineJoin:n.lineJoin,n.lineDashOffset=e.lineDashOffset?e.lineDashOffset:n.lineDashOffset,n.lineCap=e.lineCap?e.lineCap:n.lineCap,n.letterSpacing=e.letterSpacing?e.letterSpacing:n.letterSpacing,n.fontKerning=e.fontKerning?e.fontKerning:n.fontKerning,n.direction=e.direction?e.direction:n.direction,e.lineDash&&n.setLineDash(e.lineDash)};var tn,en,It,Se,nn,le,nr,Tn,Es=class extends On{constructor(e=100,n=1){super();U(this,le);U(this,tn);U(this,en);U(this,It);U(this,Se);U(this,nn);z(this,tn,e),z(this,en,e/n),z(this,It,""),z(this,Se,document.createElement("canvas")),g(this,Se).width=1,g(this,Se).height=1,z(this,nn,g(this,Se).getContext("2d"))}begin(){z(this,It,`<svg version="1.1"
        width="${this.width}" height="${this.height}"
        xmlns="http://www.w3.org/2000/svg">
`)}end(){z(this,It,g(this,It)+"</svg>")}get width(){return g(this,tn)}get height(){return g(this,en)}get document(){return g(this,It)}beginGroup(){z(this,It,g(this,It)+`<g>
`)}endGroup(){z(this,It,g(this,It)+`</g>
`)}drawPath(e,{fill:n=!0,stroke:r=!0,style:s={}}={}){if(!e)return;let i=[];for(let o of e.elements){let a=o.type;if(a===_.MOVE)i.push(`M ${o.x} ${o.y}`);else if(a===_.LINE_TO)i.push(`L ${o.x} ${o.y}`);else if(a===_.ARC){let f=Math.abs((o.endAngle-o.startAngle)/(2*Math.PI)),h=at(o.startAngle),p=at(o.endAngle),m=o.counterclockwise;Math.abs(h-p)<1e-7&&f>=1&&(p+=(m?-1:1)*2*Math.PI);let w=p-h,A=3;m&&p>h?(h+=2*Math.PI,w=p-h):!m&&p<h&&(p+=2*Math.PI,w=p-h);let x=[];for(let v=0;v<=A;v++){let M=h+w*v/A;x.push({x:Math.cos(M)*o.radius+o.x,y:Math.sin(M)*o.radius+o.y})}i.push(`M ${x[0].x} ${x[0].y}`);for(let v=1;v<x.length;v++)i.push(`A ${o.radius} ${o.radius} 0 0 ${m?0:1} ${x[v].x} ${x[v].y}`)}else if(a===_.ELLIPSE){let f=Math.abs((o.endAngle-o.startAngle)/(2*Math.PI)),h=at(o.startAngle),p=at(o.endAngle),m=o.counterclockwise;Math.abs(h-p)<1e-7&&f>=1&&(p+=(m?-1:1)*2*Math.PI);let w=p-h;m&&p>h?(h+=2*Math.PI,w=p-h):!m&&p<h&&(p+=2*Math.PI,w=p-h);let A=3,x=[];for(let v=0;v<=A;v++){let M=o.startAngle+w*v/A;x.push(L.add(o,L.rotate(L.new(Math.cos(M)*o.radiusX,Math.sin(M)*o.radiusY),o.rotation)))}i.push(`M ${x[0].x} ${x[0].y}`);for(let v=1;v<x.length;v++)i.push(`A ${o.radiusX} ${o.radiusY} ${ke(o.rotation)} 0 ${m?0:1} ${x[v].x} ${x[v].y}`)}else a===_.CLOSE?i.push("Z"):a===_.QUAD_BEZIER?i.push(`Q ${o.x1} ${o.y1}, ${o.x2} ${o.y2}`):a===_.CUBIC_BEZIER&&i.push(`C ${o.x1} ${o.y1}, ${o.x2} ${o.y2}, ${o.x3} ${o.y3}`)}let c=i.join(" "),l=D(this,le,Tn).call(this,s,n,r);z(this,It,g(this,It)+`<path d="${c}" ${l}/>
`)}drawText(e,n,r,{fill:s=!0,stroke:i=!1,style:c={}}={}){typeof e!="string"&&(e=""+e);let l=e.split(`
`),o=g(this,nn);o.save(),c.font&&(o.font=c.font),c.lineWidth&&(o.lineWidth=c.lineWidth),c.textAlign&&(o.textAlign=c.textAlign),c.textBaseline&&(o.textBaseline=c.textBaseline),c.direction&&(o.direction=c.direction),c.fontKerning&&(o.fontKerning=c.fontKerning);let a=o.measureText(e);o.restore();let f=a.actualBoundingBoxAscent+a.actualBoundingBoxDescent;z(this,It,g(this,It)+`<g>
`);let h=D(this,le,Tn).call(this,c,!1,i),p=D(this,le,Tn).call(this,c,s,!1),m=e;if(l.length>1){let w=r,A=[];for(let x of l)A.push(`<tspan x="${n}" y="${w}">${x}</tspan>`),w+=f;m=`
`+A.join(`
`)}z(this,It,g(this,It)+`<text x="${n}" y="${r}" ${h}>${m}</text>
`),z(this,It,g(this,It)+`<text x="${n}" y="${r}" ${p}>${m}</text>
`),z(this,It,g(this,It)+`</g>
`)}};tn=new WeakMap,en=new WeakMap,It=new WeakMap,Se=new WeakMap,nn=new WeakMap,le=new WeakSet,nr=function(e){let n=/([\.\d]+)/g,r=e.match(n),s={r:0,g:0,b:0,a:1};return r.length>2&&(s.r=parseInt(r[0])||0,s.g=parseInt(r[1])||0,s.b=parseInt(r[2])||0,r.length>3&&(s.a=parseFloat(r[3])||0)),s},Tn=function(e,n,r){let s=document.createElement("div");s.style.color=e.fillStyle,s.style.font=e.font,document.body.appendChild(s);let i=window.getComputedStyle(s),c=D(this,le,nr).call(this,i.color);s.style.color=e.strokeStyle;let l=D(this,le,nr).call(this,i.color);document.body.removeChild(s);let o=[];if(r?(o.push(`stroke="rgb(${l.r},${l.g},${l.b})"`),o.push(`stroke-opacity="${l.a}"`)):o.push('stroke="none"'),n?(o.push(`fill="rgb(${c.r},${c.g},${c.b})"`),o.push(`fill-opacity="${c.a}"`)):o.push('fill="none"'),e.lineWidth&&o.push(`stroke-width="${e.lineWidth}"`),e.lineCap&&o.push(`stroke-linecap="${e.lineCap}"`),e.lineDash&&o.push(`stroke-dasharray="${e.lineDash.join(",")}"`),e.miterLimit&&o.push(`stroke-miterlimit="${e.miterLimit}"`),e.lineDashOffset&&o.push(`stroke-dashoffset="${e.lineDashOffset}"`),e.lineJoin&&o.push(`stroke-linejoin="${e.lineJoin}"`),e.textAlign){let h={start:"start",center:"middle",end:"end",left:"start",right:"end"}[e.textAlign];h&&o.push(`text-anchor="${h}"`)}if(e.textBaseline){let h={top:"text-top",hanging:"hanging",middle:"central",alphabetic:"alphabetic",ideographic:"ideographic",bottom:"text-bottom"}[e.textBaseline];h&&o.push(`dominant-baseline="${h}"`)}let a=[];return e.font&&a.push(`font: ${e.font}`),a&&o.push(`style="${a.join(";")}"`),o.join(" ")};var rn,sr,rr=class{constructor({x0:t=0,y0:e=0,x1:n=1,y1:r=1,flipY:s=!0,width:i,height:c}){U(this,rn);this.surface={width:i,height:c},this.flipY=s,this.updateViewport({x0:t,y0:e,x1:n,y1:r})}updateSurface(t,e){this.surface={width:t,height:e},D(this,rn,sr).call(this)}updateViewport({x0:t,y0:e,x1:n,y1:r}={}){this.requestedViewport={x0:t,y0:e,x1:n,y1:r},D(this,rn,sr).call(this)}convertLocalToSurface(t,e){let{x0:n,y0:r,x1:s,y1:i}=this,c=s-n,l=i-r;return t=(t-n)/c,e=(e-r)/l,this.flipY&&(e=1-e),t=t*this.surface.width,e=e*this.surface.height,{x:t,y:e}}convertSurfaceToLocal(t,e){t=t/this.surface.width,e=e/this.surface.height,this.flipY&&(e=1-e);let{x0:n,y0:r,x1:s,y1:i}=this,c=s-n,l=i-r;return t=t*c+n,e=e*l+r,{x:t,y:e}}scalingLocalToSurface(){return this.surface.width/(this.x1-this.x0)}scalingSurfaceToLocal(){return 1/this.scalingLocalToSurface()}convertLocalAngleToSurface(t){return this.flipY?-t:t}isCounterClockwise(){return this.flipY}};rn=new WeakSet,sr=function(){let{surface:t}=this;{let h=t.width/t.height,{x0:p,y0:m,x1:w,y1:A}=this.requestedViewport,x=w-p,v=A-m,M=x/v,P,T;h>M?(T=v,P=T*h):(P=x,T=P/h);let k=(p+w)*.5,B=(m+A)*.5;this.x0=k-.5*P,this.y0=B-.5*T,this.x1=k+.5*P,this.y1=B+.5*T}let{x0:e,y0:n,x1:r,y1:s}=this,a=[{x:e,y:n},{x:r,y:n},{x:r,y:s},{x:e,y:s}],f=[];for(let h=0;h<a.length;h++){let p=(h+1)%a.length,m=a[h],w=a[p],A=w.x-m.x,x=w.y-m.y;f.push({p0:m,p1:w,n:{x,y:-A}})}this.viewportCorners=a,this.viewportSides=f};var Ln,Js,Qs,Ms=class{constructor({x0:t=0,y0:e=0,x1:n=1,y1:r=1,flipY:s=!0,canvas:i}={}){U(this,Ln);this.flipY=s,this.output=i instanceof HTMLCanvasElement?new tr(i):i,this.coordinateMapper=new rr({x0:t,y0:e,x1:n,y1:r,flipY:s,width:this.output.width,height:this.output.height}),this.subdivisionThreshold=4}updateViewport({x0:t,y0:e,x1:n,y1:r}={}){this.coordinateMapper.updateViewport({x0:t,y0:e,x1:n,y1:r})}notifyCanvasSizeChanged(){this.coordinateMapper.updateSurface(this.output.width,this.output.height)}begin({fillAlpha:t=!0}={}){this.output.begin(),t&&this.output.drawRect(0,0,this.output.width,this.output.height,{stroke:!1,fill:!0,style:{fillStyle:"rgb(255,255,255)"}})}end(){this.output.end()}drawBackground(t=cr){let{axes:e={},grid:n={},numberFormatter:r=m=>m}=t,{x0:s,y0:i,x1:c,y1:l,flipY:o}=this.coordinateMapper,a=c-s,f=l-i,{output:h}=this;h.beginGroup();let p=this.coordinateMapper;if(n.show){let{strokeStyle:m,lineStyle:w}=n,A=Object.assign({strokeStyle:m},w),{xticks:x,yticks:v}=n,M=[];typeof x=="number"?M=bn(x,s,a,!1,0,h.width):Array.isArray(x)&&(M=x.map(k=>[k,(k-s)/a*h.width]));let P=[];typeof v=="number"?P=bn(v,i,f,o,0,h.height):Array.isArray(v)&&(P=v.map(k=>[k,(k-i)/f*h.height]));let T=_.new();for(let k of M){let[,B]=k;T.moveTo(B,0),T.lineTo(B,h.height)}for(let k of P){let[,B]=k;T.moveTo(0,B),T.lineTo(h.width,B)}h.drawPath(T,{fill:!1,stroke:!0,style:A})}if(e.show){let m=p.convertLocalToSurface(0,0),{x:w,y:A}=e;if(w.show){{let{strokeStyle:v,lineStyle:M}=w,P=Object.assign(Object.assign({},v),M),T=_.new();T.moveTo(0,m.y),T.lineTo(h.width,m.y),h.drawPath(T,{fill:!1,stroke:!0,style:P})}let{ticks:x}=w;if(x.show){let v=bn(x.spacing,s,a,!1,0,h.width),{strokeStyle:M={},lineStyle:P={}}=x,T=Object.assign(Object.assign({},M),P),{size:k}=x,B=k*p.scalingLocalToSurface();{let Y=_.new();for(let j of v){let[,W]=j;Y.moveTo(W,m.y-B),Y.lineTo(W,m.y+B)}h.drawPath(Y,{fill:!1,stroke:!0,style:T})}let{labels:V}=w;if(V.show){let Y=Object.assign(T,V.textStyle),j=B*1.5;for(let W of v){let[nt,Z]=W,st=r(nt),xt=j;h.drawText(st,Z+0,m.y+xt,{stroke:!1,fill:!0,style:Y})}}}}if(A.show){{let{strokeStyle:M,lineStyle:P}=A,T=Object.assign(Object.assign({},M),P),k=_.new();k.moveTo(m.x,0),k.lineTo(m.x,h.height),h.drawPath(k,{fill:!1,stroke:!0,style:T})}let{ticks:x,labels:v}=A;if(x.show){let M=bn(x.spacing,i,f,this.flipY,0,h.height),{strokeStyle:P={},lineStyle:T={}}=x,k=Object.assign(Object.assign({},P),T),{size:B}=x,V=B*p.scalingLocalToSurface();{let Y=_.new();for(let j of M){let[,W]=j;Y.moveTo(m.x-V,W),Y.lineTo(m.x+V,W)}h.drawPath(Y,{fill:!1,stroke:!0,style:k})}if(v.show){let Y=Object.assign(k,v.textStyle),j=-V*1.5;for(let W of M){let[nt,Z]=W,st=r(nt),xt=0,zt=j;h.drawText(st,m.x+zt,Z+xt,{stroke:!1,fill:!0,style:Y})}}}}}h.endGroup()}drawPoint(t,e,n={}){n=Ot(Nt.geo.point,n);let{r,fillStyle:s,strokeStyle:i,outline:c}=n,l=this.context,o=Object.assign({fillStyle:s,strokeStyle:i},c);({x:t,y:e}=this.coordinateMapper.convertLocalToSurface(t,e));let a=_.new();a.arc(t,e,r,0,2*Math.PI),this.output.drawPath(a,{fill:!0,stroke:!0,style:o})}drawText(t,e,n,r={}){r=Ot(Nt.geo.text,r);let{fillStyle:s,strokeStyle:i,outline:c,textStyle:l,offset:o}=r;({x:t,y:e}=this.coordinateMapper.convertLocalToSurface(t+o.x,e+o.y));let a=this.output,f=Object.assign({fillStyle:s,strokeStyle:i},c,l);a.drawText(n,t,e,{fill:!0,stroke:!0,style:f})}drawAngle(t,e,n,r,s={}){s=Ot(Nt.geo.angle,s);let{r:i,toDeg:c,arc:l,text:o}=s,a=this.coordinateMapper,f=i/a.scalingLocalToSurface(),h=r+n,p=r+.5*n,m=t+f*o.radius*Math.cos(p),w=e+f*o.radius*Math.sin(p),{x:A,y:x}=a.convertLocalToSurface(t,e);({x:m,y:w}=a.convertLocalToSurface(m,w));let v=this.output;v.beginGroup();let M=Object.assign({fillStyle:l.fillStyle,strokeStyle:l.strokeStyle},l.outline);{let P=_.new();P.arc(A,x,i,a.convertLocalAngleToSurface(r),a.convertLocalAngleToSurface(h),a.isCounterClockwise()),P.lineTo(A,x),P.close(),v.drawPath(P,{fill:!0,stroke:!0,style:M})}if(l.showDirection){let P={x:Math.cos(h),y:Math.sin(h)},T={x:P.y,y:-P.x},k=t+f*P.x,B=e+f*P.y,V=k+.6*f*T.x,Y=B+.6*f*T.y,j=V+.2*f*P.x,W=Y+.2*f*P.y;({x:k,y:B}=a.convertLocalToSurface(k,B)),{x:V,y:Y}=a.convertLocalToSurface(V,Y),{x:j,y:W}=a.convertLocalToSurface(j,W);let nt=Object.assign({},M);nt.fillStyle=nt.strokeStyle;let Z=_.new();Z.moveTo(k,B),Z.lineTo(V,Y),Z.lineTo(j,W),Z.close(),v.drawPath(Z,{fill:!0,stroke:!0,style:nt})}if(o.show){let P=c?ke(n):n,T=o.transform?o.transform(P,c):"",k=Object.assign({fillStyle:o.fillStyle,strokeStyle:o.strokeStyle},o.textStyle,o.outline);v.drawText(T,m,w,{fill:!0,stroke:!0,style:k})}v.endGroup()}drawArc(t,e,n,r=0,s=2*Math.PI,i={}){i=Ot(Nt.geo.arc,i);let{fillStyle:c,strokeStyle:l,outline:o,closeArc:a}=i,f=this.context,h=this.coordinateMapper,p=Object.assign({fillStyle:c,strokeStyle:l},o),m=h.convertLocalToSurface(t+Math.cos(r)*n,e+Math.sin(r)*n);({x:t,y:e}=h.convertLocalToSurface(t,e)),n*=h.scalingLocalToSurface();let w=_.new();w.arc(t,e,n,h.convertLocalAngleToSurface(r),h.convertLocalAngleToSurface(s),h.isCounterClockwise()),a&&(w.lineTo(t,e),w.close()),this.output.drawPath(w,{fill:!0,stroke:!0,style:p})}drawEllipse(t,e,n,r,s,i,c,l={}){l=Ot(Nt.geo.arc,l);let{fillStyle:o,strokeStyle:a,outline:f,closeArc:h}=l,{output:p}=this,m=this.coordinateMapper,w=Object.assign({fillStyle:o,strokeStyle:a},f);({x:t,y:e}=m.convertLocalToSurface(t,e)),n*=m.scalingLocalToSurface(),r*=m.scalingLocalToSurface();let A=_.new();h&&A.moveTo(t,e),A.ellipse(t,e,n,r,m.convertLocalAngleToSurface(c),m.convertLocalAngleToSurface(s),m.convertLocalAngleToSurface(i),m.isCounterClockwise()),h&&A.closePath(),p.drawPath(A,{fill:!0,stroke:!0,style:w})}drawLine(t,e,n,r,s,i,c={}){c=Ot(Nt.geo.line,c);let{strokeStyle:l="rgb(0,0,0)",lineStyle:o}=c,{output:a}=this,f=this.coordinateMapper,h=Object.assign({strokeStyle:l},o),{p0:p,p1:m}=Gs(this.coordinateMapper,t,e,n,r,s,i);({x:t,y:e}=f.convertLocalToSurface(p.x,p.y)),{x:n,y:r}=f.convertLocalToSurface(m.x,m.y),a.drawLine(t,e,n,r,{fill:!1,stroke:!0,style:h})}drawBezier(t,e={}){if(t.length<2)throw new Error("Bezier curve must have degree of at least 1");e=Ot(Nt.geo.line,e);let{strokeStyle:n="rgb(0,0,0)",lineStyle:r}=e,{output:s}=this,i=this.coordinateMapper,c=Object.assign({strokeStyle:n},r),l=t.map(a=>i.convertLocalToSurface(a.x,a.y)),o=_.new();if(l.length===2){let[a,f]=l;o.moveTo(a.x,a.y),o.lineTo(f.x,f.y)}else if(l.length===3){let[a,f,h]=l;o.moveTo(a.x,a.y),o.quadraticBezier(f.x,f.y,h.x,h.y)}else if(l.length===4){let[a,f,h,p]=l;o.moveTo(a.x,a.y),o.cubicBezier(f.x,f.y,h.x,h.y,p.x,p.y)}else{let a=Math.max(1,this.subdivisionThreshold),f=Gn(l,a);o.moveTo(f[0].x,f[0].y);for(let h=1;h<f.length;h++){let p=f[h];o.lineTo(p.x,p.y)}}s.drawPath(o,{fill:!1,stroke:!0,style:c})}drawBezierSpline(t,e,n={}){if(e<1)throw new Error(`Drawing bezier curves only supported starting from degree 1, got ${e}`);if((t.length-(e+1))%e!==0)throw new Error("Wrong number of input points");n=Ot(Nt.geo.line,n);let{strokeStyle:r="rgb(0,0,0)",lineStyle:s}=n,i=Object.assign({strokeStyle:r},s),{output:c}=this,l=this.coordinateMapper,o=t.map(f=>l.convertLocalToSurface(f.x,f.y)),a=_.new();a.moveTo(o[0].x,o[0].y);for(let f=1;f<o.length;f+=e)if(e===1){let[h]=[o[f]];a.lineTo(h.x,h.y)}else if(e===2){let[h,p]=[o[f],o[f+1]];a.quadraticBezier(h.x,h.y,p.x,p.y)}else if(e===3){let[h,p,m]=[o[f],o[f+1],o[f+2]];a.cubicBezier(h.x,h.y,p.x,p.y,m.x,m.y)}else{let h=[];for(let w=0;w<=e;w++)h.push(o[f-1+w]);let p=Math.max(1,this.subdivisionThreshold),m=Gn(h,p);for(let w=1;w<m.length;w++){let A=m[w];a.lineTo(A.x,A.y)}}c.drawPath(a,{fill:!1,stroke:!0,style:i})}drawLineStrip(t,e={}){if(t.length<2)return;e=Ot(Nt.geo.line,e);let{strokeStyle:n="rgb(0,0,0)",lineStyle:r}=e,s=Object.assign({strokeStyle:n},r),{output:i}=this,c=this.coordinateMapper,l=_.new(),o=c.convertLocalToSurface(t[0].x,t[0].y);l.moveTo(o.x,o.y);for(let a=1;a<t.length;a++){let f=t[a];f=c.convertLocalToSurface(f.x,f.y),l.lineTo(f.x,f.y)}i.drawPath(l,{fill:!1,stroke:!0,style:s})}drawPolygon(t,e={}){if(t.length<2)return;e=Ot(Nt.geo.polygon,e);let{strokeStyle:n,fillStyle:r,lineStyle:s}=e,i=Object.assign({strokeStyle:n,fillStyle:r},s),{output:c}=this,l=this.coordinateMapper,o=_.new(),a=l.convertLocalToSurface(t[0].x,t[0].y);o.moveTo(a.x,a.y);for(let f=1;f<t.length;f++){let h=t[f];h=l.convertLocalToSurface(h.x,h.y),o.lineTo(h.x,h.y)}o.close(),c.drawPath(o,{fill:!0,stroke:!0,style:i})}drawVector(t,e,n,r,s={}){s=Ot(Nt.geo.vector,s);let{shaft:i,arrow:c}=s,{output:l}=this;l.beginGroup();let o=this.coordinateMapper;({x:t,y:e}=o.convertLocalToSurface(t,e)),{x:n,y:r}=o.convertLocalToSurface(n,r);let a=n-t,f=r-e,h=a*a+f*f;if(h<1)return;let p=Math.sqrt(h),m,w;c.sizeRelative?(m=-c.width*f,w=c.width*a):(m=-c.width*f/p,w=c.width*a/p);let A,x;if(c.sizeRelative){let v=1-c.length;A=t+v*a,x=e+v*f}else A=n-c.length*a/p,x=r-c.length*f/p;{let v=Object.assign({strokeStyle:i.strokeStyle},i.lineStyle);l.drawLine(t,e,A,x,{fill:!1,stroke:!0,style:v})}{let v=Object.assign({strokeStyle:i.strokeStyle,fillStyle:c.fillStyle},i.lineStyle),M=_.new();M.moveTo(n,r),M.lineTo(A+m,x+w),M.lineTo(A-m,x-w),M.close(),l.drawPath(M,{fill:!0,stroke:!0,style:v})}l.endGroup()}};Ln=new WeakSet,Js=function(t){let e=this.context,{lineWidth:n,lineCap:r,lineJoin:s,miterLimit:i,lineDash:c,lineDashOffset:l}=t;e.lineWidth=n,e.lineCap=r,e.lineJoin=s,e.miterLimit=i,e.setLineDash(c),e.lineDashOffset=l},Qs=function(t){let e=this.context,{font:n,textAlign:r,textBaseline:s,direction:i,fontKerning:c}=t;e.font=n,e.textAlign=r,e.textBaseline=s,e.direction=i,e.fontKerning=c};var oe,ie,ce,we,qe,Be,$e,xe,or=class{constructor(t,e=null){U(this,oe,[]);U(this,ie,[]);U(this,ce,[]);U(this,we);U(this,qe,-1);U(this,Be,-1);U(this,$e,-1);U(this,xe,-1);this.drawFunc=e,this.scene=t,z(this,we,!1),this.stopped=!1,z(this,oe,[]),z(this,ie,[]),z(this,ce,[]),z(this,qe,this.scene.registerCallback(re.EVENT_UPDATE,n=>{g(this,oe).push(n.index),this.requestDraw()})),z(this,Be,this.scene.registerCallback(re.EVENT_REMOVE,n=>{g(this,ie).push(n.index),this.requestDraw()})),z(this,$e,this.scene.registerCallback(re.EVENT_PROPERTY,n=>{g(this,ce).push(n.index),this.requestDraw()})),this.requestDraw()}setDrawFunc(t){this.drawFunc=t}stop(){this.stopped=!0}start(){this.start=!0,this.requestDraw()}requestDraw(){this.stopped||g(this,we)||(z(this,we,!0),z(this,xe,window.requestAnimationFrame(()=>{this.drawFunc&&this.drawFunc(this.scene,[...g(this,oe)],[...g(this,ie)],[...g(this,ce)]),z(this,xe,-1),z(this,we,!1),z(this,oe,[]),z(this,ie,[]),z(this,ce,[])})))}draw(){this.drawFunc&&this.drawFunc(this.scene,[...g(this,oe)],[...g(this,ie)],[...g(this,ce)]),z(this,we,!1),z(this,oe,[]),z(this,ie,[]),z(this,ce,[])}disconnect(){g(this,xe)>=0&&(window.cancelAnimationFrame(g(this,xe)),z(this,xe,-1)),this.scene.removeCallback(re.EVENT_UPDATE,g(this,qe)),this.scene.removeCallback(re.EVENT_REMOVE,g(this,Be)),this.scene.removeCallback(re.EVENT_PROPERTY,g(this,$e)),z(this,qe,-1),z(this,Be,-1),z(this,$e,-1)}};oe=new WeakMap,ie=new WeakMap,ce=new WeakMap,we=new WeakMap,qe=new WeakMap,Be=new WeakMap,$e=new WeakMap,xe=new WeakMap;function Zs(u){let t=[];for(let e of u.view({skipInvalidValues:!0})){let{value:n,properties:r={}}=e;if(r.invisible)continue;let{z:s=0}=r;if(n.type===jn){let{objects:i,properties:c=[]}=n;for(let l=0;l<i.length;l++){let o=c[l]?c[l]:r,{zo:a=s}=o;t.push({value:i[l],z:a,properties:o})}}else t.push({value:n,z:s,properties:r})}return t.sort((e,n)=>n.z-e.z),t}var ir=class{constructor({typedDrawFuncs:t={},defaultDrawFunc:e=()=>{},untypedDrawFunc:n=()=>{}}={}){this.typedDrawFuncs=t,this.defaultDrawFunc=e,this.untypedDrawFunc=n}draw(t,e,n){let r=e.type;if(r!==void 0){let s=this.typedDrawFuncs[r];s!==void 0?s(t,e,n):this.defaultDrawFunc(t,e,n)}else this.untypedDrawFunc(t,e,n)}};function Is(){let u={};return u[O]=(e,n,r)=>e.drawPoint(n.x,n.y,r.style),u[Q]=(e,n,r)=>{let{p0:s,p1:i,leftOpen:c,rightOpen:l}=n;e.drawLine(s.x,s.y,i.x,i.y,c,l,r.style)},u[$]=(e,n,r)=>{let{ref:s,x:i,y:c}=n;e.drawVector(s.x,s.y,s.x+i,s.y+c,r.style)},u[ee]=(e,n,r)=>{let{origin:s,u:i,v:c}=n,{style:l={}}=r,o=Ot(Nt.geo.coordinateSystem.origin,l.origin),a=Ot(Nt.geo.coordinateSystem.u,l.u),f=Ot(Nt.geo.coordinateSystem.v,l.v);e.drawPoint(s.x,s.y,o),e.drawVector(s.x,s.y,s.x+i.x,s.y+i.y,a),e.drawVector(s.x,s.y,s.x+c.x,s.y+c.y,f)},u[J]=(e,n,r)=>{let{center:s,r:i,startAngle:c,endAngle:l}=n;e.drawArc(s.x,s.y,i,c,l,r.style)},u[Me]=(e,n,r)=>{let{ref:s,value:i,start:c}=n;e.drawAngle(s.x,s.y,i,c,r.style)},u[En]=(e,n,r)=>{let{text:s,ref:i}=n;e.drawText(i.x,i.y,s,r.style)},u[ut]=(e,n,r)=>{let{points:s}=n;e.drawLineStrip(s,r.style)},u[ot]=(e,n,r)=>{let{points:s}=n;e.drawPolygon(s,r.style)},u[pt]=(e,n,r)=>{let{points:s}=n;e.drawBezier(s,r.style)},u[mt]=(e,n,r)=>{let{points:s,degree:i}=n;e.drawBezierSpline(s,i,r.style)},u[ct]=(e,n,r)=>{let{center:s,rx:i,ry:c,startAngle:l,endAngle:o,rotation:a}=n;e.drawEllipse(s.x,s.y,i,c,l,o,a,r.style)},new ir({typedDrawFuncs:u})}function Ks(u,t,{drawFuncRegistry:e=Is(),bg:n=cr}){t.begin(),t.drawBackground(n);let r=Zs(u);for(let s=0;s<r.length;s++){let{value:i,properties:c}=r[s],l=Array.isArray(i)?i:[i];for(let o=0;o<l.length;o++){let a=l[o];e.draw(t,a,c)}}t.end()}var be,Te,Oe,Ps=class extends or{constructor(e,n,{drawFuncRegistry:r=Is(),bg:s=cr,autoResize:i=null}={}){super(e);U(this,be);U(this,Te,[0,0]);U(this,Oe,null);if(this.bg=s,this.drawFuncRegistry=r,z(this,Oe,n),z(this,Te,[n.output.width,n.output.height]),this.setDrawFunc(c=>{Ks(c,g(this,Oe),{bg:this.bg,drawFuncRegistry:this.drawFuncRegistry})}),i){let{minWidth:c=1,keepAspect:l=!1,widthFactor:o=.9,target:a}=i;if(!a)throw new Error("Container must be specified for auto resize");z(this,be,new ResizeObserver(f=>{for(let h of f)if(h.target===a){let p=h.contentBoxSize.reduce((x,v)=>Math.max(x,v.inlineSize),0),m=g(this,Te)[0]/g(this,Te)[1],w=p*o;if(w<c)return;let A=g(this,Oe).output;A.width=w,l&&(A.height=w/m),z(this,Te,[A.width,A.height]),g(this,Oe).notifyCanvasSizeChanged(),this.draw()}})),g(this,be).observe(a)}}disconnect(){super.disconnect(),g(this,be)&&g(this,be).disconnect()}};be=new WeakMap,Te=new WeakMap,Oe=new WeakMap;export{fo as BASIC_BACKGROUND_CONFIG,tr as CanvasPathOutput,gn as ClosestPointRegistry,qn as Complex,rr as CoordinateMapper,E as CreateInfo,Ue as DefAngle,es as DefArc,Kr as DefArcLength,os as DefArray,Yn as DefBezier,Zr as DefBezierSpline,zr as DefBoolean,_r as DefChainApply,rs as DefClosestPoint,qr as DefConditional,fe as DefCoordSystem,Sr as DefCoordSystemOps,Fr as DefCurveNormal,Br as DefCurveParam,Pt as DefCurvePoint,Dr as DefCurveTangent,ns as DefEllipse,Ur as DefEllipseFocus,jr as DefFunc,is as DefInterpolate,ss as DefIntersection,Xr as DefLength,je as DefLengthSquared,Gr as DefLine,Jr as DefLineStrip,ts as DefMap,Wr as DefMidPoint,br as DefNormalVector,Nr as DefNumber,Or as DefParallelLine,Tr as DefPerpendicularLine,Ze as DefPoint,Rr as DefPolarCoord,Cr as DefPolarVector,Qr as DefPolygon,Lr as DefReflection,kr as DefRefraction,Hr as DefSelect,Yr as DefTangentLines,Vr as DefTangentPoints,$r as DefText,Ir as DefValue,Mr as DefVector,Pr as DefVectorOps,cs as DefinitionRemovedEvent,wn as DefinitionUpdateEvent,Ms as DiagramCanvas,Ps as DiagramPainter,ir as DrawFuncRegistry,b as EMPTY,dt as EMPTY_INFO,Ge as EventType,re as GeometryScene,X as INVALID,Dn as IntersectionRegistry,cr as NO_BACKGROUND_CONFIG,On as PathOutput,As as PointManipulator,xn as PropertyUpdateEvent,$n as Roots,or as ScenePainter,Es as SvgPathOutput,Me as TYPE_ANGLE,J as TYPE_ARC,pt as TYPE_BEZIER,mt as TYPE_BEZIER_SPLINE,it as TYPE_BOOLEAN,jn as TYPE_COLLECTION,ee as TYPE_COORD_SYSTEM,ct as TYPE_ELLIPSE,Q as TYPE_LINE,ut as TYPE_LINE_STRIP,G as TYPE_NUMBER,O as TYPE_POINT,Xe as TYPE_POLAR,ot as TYPE_POLYGON,En as TYPE_TEXT,us as TYPE_VALUE,$ as TYPE_VECTOR,L as Vec2,C as assertExistsAndNotOptional,y as assertType,$t as calcAngle,yr as calcBezierParameterOfPoint,mn as calcBezierPointsDerivative,dn as calcCirclePointTangentPoints,Ys as calcConvexHull,gs as calcInnerTangentPoints,Us as calcLineImplicit,ys as calcOuterTangentPoints,me as calcParamOnLine,He as clientPositionToLocal,Vn as clipPolygonAtPlane,js as clipPolygonAtPolygon,Ar as closestPointArc,Er as closestPointBezier,Ve as closestPointLine,Fn as computePlane,ps as convertCubicBezierToParamBase,Kt as convertPointFromLocalEllipse,Yt as convertPointToLocalEllipse,Qe as convertQuadraticBezierToParamBase,ms as convertQuarticBezierToParamBase,Is as createDiagramCanvasDrawFuncRegistry,Ot as createFromTemplate,Ne as deCasteljau,co as deg2rad,Ks as drawSceneToDiagram,Pn as getBezierSplineSegment,ds as intersectArcArc,xr as intersectArcBezier,In as intersectBezierBezier,vr as intersectEllipseEllipse,De as intersectLineArc,Gt as intersectLineBezier,Tt as intersectLines,Ws as intersectQuadraticBezier,Mt as intersectorApplyToLineSegments,Ie as isAngleInRange,so as isLine,io as isLineSegment,S as isParamEmpty,dr as isParamValid,yn as isPointDirectionValidOnArc,Fe as isPointInAngleRange,oo as isRay,We as makeAngle,ue as makeArc,Zn as makeBezier,Kn as makeBezierSpline,Re as makeBoolean,ro as makeCollection,Xn as makeEllipse,Xt as makeLine,Jn as makeLineStrip,ye as makeNumber,N as makePoint,fs as makePolarCoordinate,Qn as makePolygon,Rs as makeText,bn as makeTicks,Ds as makeValue,Rt as makeVector,zn as mergeObjectInto,wr as miminumAbsoluteDifferenceAngle,Sn as mouseEventToPosition,at as normalizeAngle,Mn as numSegmentsBezierSpline,hs as objectToString,ve as orientedAngle,ke as rad2deg,Fs as removeColinear,Vs as removeZeroSegments,Nt as styles,Gn as subdivideBezierAdaptive,Rn as subdivideBezierControlPoints,no as subintervalBezierControlPoints};
