(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{ClosestPointRegistry:()=>dt,Complex:()=>A,CreateInfo:()=>le,DefAngle:()=>Ot,DefArc:()=>Ht,DefArcLength:()=>qt,DefArray:()=>Zt,DefBezier:()=>Wt,DefBezierSpline:()=>_t,DefBoolean:()=>St,DefChainApply:()=>Gt,DefClosestPoint:()=>Kt,DefConditional:()=>Pt,DefCurveNormal:()=>It,DefCurvePoint:()=>kt,DefCurveTangent:()=>Tt,DefEllipse:()=>Qt,DefEllipseFocus:()=>Nt,DefFunc:()=>Vt,DefInterpolate:()=>en,DefIntersection:()=>Xt,DefLength:()=>Ut,DefLengthSquared:()=>$t,DefLine:()=>Rt,DefLineStrip:()=>Bt,DefMap:()=>Jt,DefMidPoint:()=>jt,DefNormalVector:()=>mt,DefNumber:()=>At,DefParallelLine:()=>wt,DefParamOnCurve:()=>Mt,DefPerpendicularLine:()=>gt,DefPoint:()=>zt,DefPolarCoord:()=>Dt,DefPolarVector:()=>vt,DefPolygon:()=>Ft,DefReflection:()=>xt,DefRefraction:()=>bt,DefSelectByKey:()=>Yt,DefTangentLines:()=>Ct,DefTangentPoints:()=>Lt,DefText:()=>Et,DefVector:()=>yt,DefinitionRemovedEvent:()=>rn,DefinitionUpdateEvent:()=>nn,EMPTY:()=>oe,EMPTY_INFO:()=>ce,EventType:()=>tn,GeometryScene:()=>sn,INVALID:()=>re,IntersectionRegistry:()=>ct,PropertyUpdateEvent:()=>on,Roots:()=>N,TYPE_ANGLE:()=>U,TYPE_ARC:()=>X,TYPE_BEZIER:()=>ee,TYPE_BEZIER_SPLINE:()=>te,TYPE_BOOLEAN:()=>q,TYPE_ELLIPSE:()=>Z,TYPE_LINE:()=>H,TYPE_LINE_STRIP:()=>Q,TYPE_NUMBER:()=>$,TYPE_POINT:()=>Y,TYPE_POLAR:()=>G,TYPE_POLYGON:()=>K,TYPE_TEXT:()=>ne,TYPE_VECTOR:()=>J,Vec2:()=>i,assertExistsAndNotOptional:()=>ae,assertType:()=>ht,calcAngle:()=>ze,calcBezierParameterOfPoint:()=>fe,calcBezierPointsDerivative:()=>pe,calcCirclePointTangentPoints:()=>rt,calcConvexHull:()=>Fe,calcInnerTangentPoints:()=>st,calcLineImplicit:()=>Je,calcOuterTangentPoints:()=>it,calcParamOnLine:()=>He,closestPointArc:()=>pt,closestPointBezier:()=>ut,closestPointLine:()=>ft,convertCubicBezierToParamBase:()=>qe,convertPointFromLocalEllipse:()=>Re,convertPointToLocalEllipse:()=>Ve,convertQuadraticBezierToParamBase:()=>_e,convertQuarticBezierToParamBase:()=>$e,createFromTemplate:()=>o,deCastlejau:()=>ue,deg2rad:()=>je,getBezierSplineSegment:()=>lt,intersectArcArc:()=>tt,intersectArcBezier:()=>Ke,intersectBezierBezier:()=>Ye,intersectEllipseEllipse:()=>nt,intersectLineArc:()=>Xe,intersectLineBezier:()=>Qe,intersectLines:()=>We,intersectQuadraticBezier:()=>Ue,intersectorApplyToLineSegments:()=>Ge,isAngleInRange:()=>et,isLine:()=>ke,isLineSegment:()=>Ie,isParamEmpty:()=>se,isParamValid:()=>ie,isPointDirectionValidOnArc:()=>ot,isPointInAngleRange:()=>Ze,isRay:()=>Te,makeAngle:()=>we,makeArc:()=>Pe,makeBezier:()=>Ae,makeBezierSpline:()=>Se,makeBoolean:()=>de,makeEllipse:()=>Me,makeLine:()=>xe,makeLineStrip:()=>be,makeNumber:()=>he,makePoint:()=>ye,makePolarCoordinate:()=>me,makePolygon:()=>ve,makeText:()=>Ee,makeVector:()=>ge,mergeObjectInto:()=>r,miminumAbsoluteDifferenceAngle:()=>Le,normalizeAngle:()=>De,numSegmentsBezierSpline:()=>at,objectToString:()=>Oe,orientedAngle:()=>Ce,rad2deg:()=>Ne,removeColinear:()=>Be});var n={};function r(e,t){const n=[[e,t]],r=e=>e&&"object"==typeof e&&!Array.isArray(e);for(;n.length>0;){const[e,t]=n.pop();if(r(e)&&r(t))for(const o of Object.keys(t)){const i=t[o];r(i)?(e[o]||Object.assign(e,{[o]:{}}),n.push([e[o],i])):Object.assign(e,{[o]:i})}}return e}function o(e,t){const n=r({},e);return r(n,t)}e.r(n),e.d(n,{demoAddition:()=>An,demoArcTangents:()=>Tn,demoCurveTangentNormals:()=>In,demoDeCastlejau:()=>zn,demoDetectGround:()=>Ln,demoDot:()=>Mn,demoInscribedAngle:()=>On,demoLength:()=>Pn,demoLens:()=>kn,demoScale:()=>Sn,demoTriangleCircles:()=>Dn,demoTrig:()=>En});class i{static vec2(e=0,t=0){return{x:e,y:t}}static add(e,t){return{x:e.x+t.x,y:e.y+t.y}}static sub(e,t){return{x:e.x-t.x,y:e.y-t.y}}static scale(e,t){return{x:e.x*t,y:e.y*t}}static cwiseMult(e,t){return{x:e.x*t.x,y:e.y*t.y}}static cwiseDiv(e,t){return{x:e.x/t.x,y:e.y/t.y}}static rotate(e,t,n=Math.cos(t),r=Math.sin(t)){return{x:e.x*n-e.y*r,y:e.x*r+e.y*n}}static dot(e,t){return e.x*t.x+e.y*t.y}static len2(e){return e.x*e.x+e.y*e.y}static len(e){return Math.sqrt(e.x*e.x+e.y*e.y)}static polar(e,t){return{x:e*Math.cos(t),y:e*Math.sin(t)}}static normalize(e){return i.scale(e,1/i.len(e))}static normalizeIfNotZero(e,t=1e-10){const n=i.len2(e);return n>t&&(e=i.scale(e,1/Math.sqrt(n))),e}static lerp(e,t,n){const r=1-n;return i.add(i.scale(e,r),i.scale(t,n))}static normal2D(e){return{x:-e.y,y:e.x}}}const{vec2:s,add:a,sub:l,scale:c,cwiseMult:f,cwiseDiv:p,rotate:u,dot:h,len2:y,len:m,polar:g,normalize:w,normalizeIfNotZero:x,lerp:b,normal2D:v}=i;class A{static num(e=0,t=0){return[e,t]}static add(e,t){return[e[0]+t[0],e[1]+t[1]]}static sub(e,t){return[e[0]-t[0],e[1]-t[1]]}static mult(e,t){return[e[0]*t[0]-e[1]*t[1],e[0]*t[1]+e[1]*t[0]]}static div(e,t){const[n,r]=e,[o,i]=t,s=o*o+i*i;return[(n*o+r*i)/s,(r*o-n*i)/s]}static conj(e){return[e[0],-e[1]]}static neg(e){return[-e[0],-e[1]]}static abs(e){const[t,n]=e;return Math.sqrt(t*t+n*n)}static abs2(e){const[t,n]=e;return t*t+n*n}static equals(e,t,n=1e-10){return A.abs(A.sub(e,t))<n}static real(e){return e[0]}static imag(e){return e[1]}static sqrt(e){const t=A.abs(e),[n,r]=e,o=r<0?-1:1;return A.num(Math.sqrt(.5*(t+n)),o*Math.sqrt(.5*(t-n)))}}const{num:S,add:P,sub:M,mult:E,div:O,conj:D,neg:z,abs:k,abs2:T,equals:I,real:L,imag:C,sqrt:j}=A;class N{static solveLinear(e,t,n=1e-10){return Math.abs(e)<n?[]:[-t/e]}static solveQuadratic(e,t,n,r=1e-10){if(Math.abs(e)<r)return N.solveLinear(t,n,r);let o=t*t-4*e*n;if(o<-r)return[];if(o=Math.max(0,o),o<r)return[-t/(2*e)];const i=Math.sqrt(o);return[(-t+i)/(2*e),(-t-i)/(2*e)]}static solveQuadraticComplex(e,t,n,r=1e-10){if(Math.abs(e)<r)return N.solveLinear(t,n,r).map((e=>S(e)));let o=t*t-4*e*n;if(o<-r){const r=t/(2*e),o=-r,i=Math.sqrt(Math.abs(r*r-n/e));return[S(o,i),S(o,-i)]}if(o=Math.max(0,o),Math.abs(o)<r)return[S(-t/(2*e))];const i=Math.sqrt(o);return[(-t+i)/(2*e),(-t-i)/(2*e)]}static solveCubicComplex(e,t,n,r,o=1e-10){if(Math.abs(e)<o)return N.solveQuadraticComplex(t,n,r,o);const i=t/e,s=n/e,a=s-i*i/3,l=2*i*i*i/27-i*s/3+r/e;let c=a*a*a/27+l*l/4;if(c>o){const e=Math.sqrt(c),t=Math.cbrt(-l/2+e),n=Math.cbrt(-l/2-e),r=S(t+n-i/3),o=S(-(t+n)/2-i/3,Math.sqrt(3)/2*(t-n));return[r,o,D(o)]}if(Math.abs(c)<o){const e=Math.cbrt(-l/2),t=.5*-(e+e),n=S(e+e-i/3),r=S(t-i/3);return[n,r,r]}c=Math.min(c,0);const f=Math.sqrt(-a*a*a/27),p=Math.sqrt(-c),u=Math.atan2(p,-l/2),d=Math.cbrt(f),h=d*(Math.cos(u/3)+Math.cos((6*Math.PI-u)/3))-i/3,y=d*(Math.cos((2*Math.PI+u)/3)+Math.cos((4*Math.PI-u)/3))-i/3,m=d*(Math.cos((4*Math.PI+u)/3)+Math.cos((2*Math.PI-u)/3))-i/3;return[S(h),S(y),S(m)]}static solveBiquadraticQuarticComplex(e,t,n=1e-10){const r=S(e*e-4*t),o=j(E(P(S(-e),j(r)),S(.5))),i=j(E(M(S(-e),j(r)),S(.5)));return[o,z(o),i,z(i)]}static solveDepressedQuarticComplex(e,t,n,r=1e-10){const o=e=>Math.abs(e)<r?0:e;if(e=o(e),t=o(t),n=o(n),0===e&&0===t&&0===n)return[S(0),S(0),S(0),S(0)];if(Math.abs(t)<r)return N.solveBiquadraticQuarticComplex(e,n,r);let i=[],s=0,a=S(0),l=0;i=N.solveCubicComplex(1,2*e,e*e-4*n,-t*t,r);for(let e of i){const n=k(e);n>r&&n>l&&(s=O(S(-2*t),j(e)),a=e,l=n)}const c=[];{const t=S(1);let n=M(M(E(t,s),S(2*e)),a),r=E(t,j(a)),o=P(r,j(n));o=E(o,S(.5));let i=M(r,j(n));i=E(i,S(.5)),c.push(o,i)}{const t=S(-1);let n=M(M(E(t,s),S(2*e)),a),r=E(t,j(a)),o=P(r,j(n));o=E(o,S(.5));let i=M(r,j(n));i=E(i,S(.5)),c.push(o,i)}return c}static solveQuarticComplex(e,t,n,r,o,i=1e-10){if(Math.abs(e)<i)return N.solveCubicComplex(t,n,r,o,i);const s=(8*e*n-3*t*t)/(8*e*e),a=(t*t*t-4*e*t*n+8*e*e*r)/(8*e*e*e),l=(16*e*t*t*n-64*e*e*t*r-3*t*t*t*t+256*e*e*e*o)/(256*e*e*e*e),c=N.solveDepressedQuarticComplex(s,a,l,i),f=[];for(const n of c)f.push(M(n,S(t/(4*e))));return f}}const{solveLinear:V,solveQuadratic:R,solveCubicComplex:B,solveBiquadraticQuarticComplex:F,solveDepressedQuarticComplex:W,solveQuarticComplex:_}=N,q="boolean",$="number",U="angle",Y="point",G="polar",J="vector",H="line",Q="lineStrip",K="polygon",X="arc",Z="ellipse",ee="bezier",te="bezSpline",ne="text",re=Object.create({}),oe=Object.create({type:"NONE"});function ie(e){return e!==re}function se(e){return e===oe}function ae(...e){for(let t of e)if(!t||se(t))throw new Error(`Expected existing parameter, got ${JSON.stringify(t)}`)}class le{constructor(e,t={},n={},r=!1){this.name=e,this.dependencies=t,this.params=n,this.ignoreInvalids=r}static new(e,t={},n={},r=!1){return new le(e,t,n,r)}}const ce=new le("empty_info");function fe(e,t,n=1e-10){const r=t.length-1;if(r<1)return[];let o=[],i=[];const s=e=>e.filter((e=>Math.abs(C(e))<n)).map((e=>L(e)));if(1===r){const[r,s]=t,a=l(s-r),c=r;o=V(a.x,c.x-e.x,n),i=V(a.y,c.y-e.y,n)}else if(2===r){const[n,r,s]=_e(...t);o=R(s.x,r.x,n.x-e.x),i=R(s.y,r.y,n.y-e.y)}else if(3===r){const[n,r,a,l]=qe(...t),c=B(l.x,a.x,r.x,n.x-e.x),f=B(l.y,a.y,r.y,n.y-e.y);o=s(c),i=s(f)}else if(4===r){const[n,r,a,l,c]=$e(...t),f=_(c.x,l.x,a.x,r.x,n.x-e.x),p=_(c.y,l.y,a.y,r.y,n.y-e.y);o=s(f),i=s(p)}const a=[];for(const e of o)for(const t of i)Math.abs(e-t)<n&&e>=0&&e<=1&&a.push(e);return a}function pe(e){const t=[],n=e.length-1;for(let r=0;r<n;r++)t.push(c(l(e[r+1],e[r]),n));return t}function ue(e,t){const n=(e=[...e]).length-1;for(let r=1;r<=n;r++)for(let o=0;o<=n-r;o++)e[o]=b(e[o],e[o+1],t);return e[0]}function de(e=!1){return{value:e,type:q}}function he(e=0){return{value:e,type:$}}function ye({x:e=0,y:t=0,...n}={}){return{x:e,y:t,...n,type:Y}}function me({r:e=1,alpha:t=0}={}){return{r:e,alpha:t,type:G}}function ge({x:e=0,y:t=0,ref:n={x:0,y:0}}={}){return{x:e,y:t,ref:n,type:J}}function we({value:e=0,start:t=0,ref:n={x:0,y:0}}={}){return{value:e=De(e),start:t=De(t),ref:n,type:U}}function xe({p0:e={x:0,y:0},p1:t={x:0,y:0},leftOpen:n=!1,rightOpen:r=!1}={}){return{p0:e,p1:t,leftOpen:n,rightOpen:r,type:H}}function be({points:e=[]}={}){return{points:e,type:Q}}function ve({points:e=[]}={}){return{points:e,type:K}}function Ae({points:e=[]}={}){return{points:e,degree:e.length-1,type:ee}}function Se({points:e,degree:t}={}){return{points:e,degree:t,type:te}}function Pe({r:e=1,startAngle:t=0,endAngle:n=2*Math.PI,center:r={x:0,y:0}}={}){return{r:e,startAngle:t,endAngle:n,center:r,type:X}}function Me({center:e={x:0,y:0},rx:t=1,ry:n=1,startAngle:r=0,endAngle:o=2*Math.PI,rotation:i=0}){return{center:e,rx:t,ry:n,startAngle:r,endAngle:o,rotation:i,type:Z}}function Ee({text:e="",ref:t={x:0,y:0}}={}){return{text:e,ref:t,type:ne}}function Oe(e,{maxDecimals:t=2,formatter:n=new Intl.NumberFormat("en-US",{minimumFractionDigits:0,maximumFractionDigits:t})}={}){if(Array.isArray(e))return`[${e.map((e=>Oe(e))).join(", ")}]`;if(e===oe)return"Empty";if(e===re)return"Invalid";if(e.type===q)return`${e.value}`;if(e.type===$)return n.format(e.value);if(e.type===Y)return`Point(${n.format(e.x)}, ${n.format(e.y)})`;if(e.type===J)return`Vector(${n.format(e.x)}, ${n.format(e.y)})`;if(e.type===U)return`Angle(${n.format(Ne(e.value))}°)`;if(e.type===H){const t=e.leftOpen?"(":"[",r=e.rightOpen?")":"]",{p0:o,p1:i}=e;return`Line${t} (${n.format(o.x)}, ${n.format(o.y)}), (${n.format(i.x)}, ${n.format(i.y)})${r} `}if(e.type===X){let{center:t,r,startAngle:o,endAngle:i}=e;return o=Ne(o),i=Ne(i),`Arc(${n.format(r)}, (${n.format(t.x)}, ${n.format(t.y)}), ${n.format(o)}°,${n.format(i)}°)`}return e.type===ne?n.format(e.text):e.toString()}function De(e){const t=2*Math.PI;return Math.min(t,Math.max(0,e-t*Math.floor(e/t)))}function ze(e,t){return De(Math.atan2(t,e))}function ke(e){return e.type===H&&e.leftOpen&&e.rightOpen}function Te(e){return e.type===H&&(e.leftOpen&&!e.rightOpen||!e.leftOpen&&e.rightOpen)}function Ie(e){return e.type===H&&!e.leftOpen&&!e.rightOpen}function Le(e,t){return Math.min(De(e-t),De(t-e))}function Ce(e,t){const{x:n,y:r}=e,{x:o,y:i}=t;let s=Math.atan2(i,o)-Math.atan2(r,n);return s=De(s),s}function je(e){return Math.PI*e/180}function Ne(e){return 180*e/Math.PI}function Ve(e,t,n,r,o,i=!1){const a=Math.cos(-n),c=Math.sin(-n);return i||(e=e.map((e=>l(e,t)))),(e=e.map((e=>u(e,-n,a,c)))).map((e=>p(e,s(r,o))))}function Re(e,t,n,r,o,i=!1){const l=Math.cos(n),c=Math.sin(n);return e=(e=e.map((e=>f(e,s(r,o))))).map((e=>u(e,n,l,c))),i||(e=e.map((e=>a(e,t)))),e}function Be(e,t=1e-10){const n=[];for(let r=0;r<e.length;r++){const o=e[r];if(n.length>1){const e=n[n.length-2],r=n[n.length-1],i=l(r,e),s=l(o,r),a=i.x*s.y-i.y*s.x;Math.abs(a)<t?n[n.length-1]=o:n.push(o)}else n.push(o)}return n}function Fe(e){if((e=Be(e)).length<4)return e;let t=0,n=e[0].y;for(let r=1;r<e.length;r++){const o=e[r];o.y<n&&(n=o.y,t=r)}const r=[e[t]];let o=t;do{let t,n=1/0,i=-1;t=1===r.length?{x:1,y:0}:l(r[r.length-1],r[r.length-2]);const s=r[r.length-1];for(let r=0;r<e.length;r++){if(r===o)continue;const a=Ce(t,l(e[r],s));a<n&&(n=a,i=r)}const a=e[i];r.push(a),o=i}while(o!==t);return r}function We(e,t,n,r,{minA:o=-1/0,maxA:i=1/0,minB:s=-1/0,maxB:a=1/0,eps:l=1e-10}={}){const{x:c,y:f}=e,{x:p,y:u}=t,{x:d,y:h}=n,{x:y,y:m}=r,g=(m-h)*(p-c)-(y-d)*(u-f);if(Math.abs(g)<l)return null;const w=((y-d)*(f-h)-(m-h)*(c-d))/g,x=((p-c)*(f-h)-(u-f)*(c-d))/g;return w<o||w>i||x<s||x>a?null:{x:c+w*(p-c),y:f+w*(u-f),ua:w,ub:x}}function _e(e,t,n){const r=a(l(e,c(t,2)),n);return[e,l(c(t,2),c(e,2)),r]}function qe(e,t,n,r){return[e,c(l(e,t),-3),c(l(a(e,n),c(t,2)),3),a(l(r,e),c(l(t,n),3))]}function $e(e,t,n,r,o){return[e,c(l(t,e),4),c(l(a(e,n),c(t,2)),6),c(a(l(r,e),c(l(t,n),3)),4),l(a(a(e,o),c(n,6)),c(a(t,r),4))]}function Ue(e,t,{eps:n=1e-10}={}){const[r,o,i]=_e(...e),[s,l,f]=_e(...t),{x:p,y:u}=i,{x:d,y:h}=o,{x:y,y:m}=r,{x:g,y:w}=f,{x,y:b}=l,{x:v,y:A}=s,S=Math.pow(p,2)*Math.pow(w,2)-2*p*u*g*w+Math.pow(u,2)*Math.pow(g,2),P=2*Math.pow(p,2)*b*w-2*p*u*x*w-2*p*u*g*b+2*Math.pow(u,2)*x*g,M=2*y*p*u*w-2*y*Math.pow(u,2)*g-Math.pow(d,2)*u*w+d*p*h*w+d*h*u*g-2*Math.pow(p,2)*m*w+2*Math.pow(p,2)*A*w+Math.pow(p,2)*Math.pow(b,2)+2*p*m*u*g-p*Math.pow(h,2)*g-2*p*u*v*w-2*p*u*x*b-2*p*u*g*A+2*Math.pow(u,2)*v*g+Math.pow(u,2)*Math.pow(x,2),E=2*y*p*u*b-2*y*Math.pow(u,2)*x-Math.pow(d,2)*u*b+d*p*h*b+d*h*u*x-2*Math.pow(p,2)*m*b+2*Math.pow(p,2)*A*b+2*p*m*u*x-p*Math.pow(h,2)*x-2*p*u*v*b-2*p*u*x*A+2*Math.pow(u,2)*v*x,O=Math.pow(y,2)*Math.pow(u,2)-y*d*h*u-2*y*p*m*u+y*p*Math.pow(h,2)+2*y*p*u*A-2*y*Math.pow(u,2)*v+Math.pow(d,2)*m*u-Math.pow(d,2)*u*A-d*p*m*h+d*p*h*A+d*h*u*v+Math.pow(p,2)*Math.pow(m,2)-2*Math.pow(p,2)*m*A+Math.pow(p,2)*Math.pow(A,2)+2*p*m*u*v-p*Math.pow(h,2)*v-2*p*u*v*A+Math.pow(u,2)*Math.pow(v,2),D=_(S,P,M,E,O),z=[];for(const e of D){if(Math.abs(C(e))>n)continue;const t=L(e);if(t<0||t>1)continue;const p=a(c(f,t*t),a(c(l,t),s));{const e=R(i.x,o.x,r.x-p.x,2*n),t=R(i.y,o.y,r.y-p.y,2*n);if(e.sort(),t.sort(),e.length<1||t.length<1)continue;let s=-1,a=1/0;for(let n=0;n<e.length;n++){const r=e[n];for(let e=0;e<t.length;e++){const n=t[e],o=Math.abs(r-n);o<a&&(s=r,a=o)}}if(a>2*n)continue;if(s<0||s>1)continue}z.push(p)}return z}function Ye(e,t,{eps:n=1e-10}={}){t.length>e.length&&([e,t]=[t,e]);const r=e.length-1,o=t.length-1;if(3===r||4===r){if(1===o)return Qe(t[0],t[1],e,{minA:0,maxA:1,eps:n})}else if(2===r){if(2===o)return Ue(e,t,{eps:n});if(1===o)return Qe(t[0],t[1],e,{minA:0,maxA:1,eps:n})}else if(1===r&&1===o)return We(e[0],e[1],t[0],t[1],{minA:0,maxA:1,minB:0,maxB:1,eps:n});throw new Error(`Intersection between degrees ${r} and ${o} not supported`)}function Ge(e,t,{wrapPoints:n=!1}={}){const r=[],o=n?t.length:t.length-1;for(let n=0;n<o;n++){const o=e(t[n],t[(n+1)%t.length]);o&&(Array.isArray(o)?r.push(...o):r.push(o))}return r}function Je(e,t){const n=l(t,e),r=v(n),o=-h(e,r);return[r.x,r.y,o]}function He(e,t,n){const r=l(t,e),o=l(n,e);return h(r,o)/y(r)}function Qe(e,t,n,{minA:r=-1/0,maxA:o=1/0,eps:i=1e-10}={}){if(0===n.length)return[];const s=Je(e,t);if(1===n.length){const[a]=n,l=s[0]*a.x+s[1]*a.y+s[2];if(Math.abs(l)<i){const n=He(e,t,a);return n<r||n>o?[]:a}return[]}if(2===n.length){const[i,s]=n;return We(e,t,i,s,{minA:r,maxA:o,minB:0,maxB:1})}if(3===n.length){const[i,f,p]=n,u=a(l(i,c(f,2)),p),d=l(c(f,2),c(i,2)),h=i,[y,m,g]=s,w=y*u.x+m*u.y,x=y*d.x+m*d.y,b=y*h.x+m*h.y+g,v=R(w,x,b),A=[];for(const n of v){if(n<0||n>1)continue;const i=a(c(u,n*n),a(c(d,n),h)),s=He(e,t,i);s<r||s>o||A.push(i)}return A}if(4===n.length){const[l,f,p,u]=qe(...n),[d,h,y]=s,{x:m,y:g}=l,{x:w,y:x}=f,{x:b,y:v}=p,{x:A,y:S}=u,P=B(A*d+S*h,b*d+v*h,w*d+x*h,m*d+g*h+y,i),M=[];for(const n of P){if(Math.abs(C(n))>i)continue;const s=L(n);if(s<0||s>1)continue;let d=u;d=a(c(d,s),p),d=a(c(d,s),f),d=a(c(d,s),l);const h=He(e,t,d);h<r||h>o||M.push(d)}return M}if(5===n.length){const[l,f,p,u,d]=$e(...n),[h,y,m]=s,{x:g,y:w}=l,{x,y:b}=f,{x:v,y:A}=p,{x:S,y:P}=u,{x:M,y:E}=d,O=_(M*h+E*y,S*h+P*y,v*h+A*y,x*h+b*y,g*h+w*y+m,i),D=[];for(const n of O){if(Math.abs(C(n))>i)continue;const s=L(n);if(s<0||s>1)continue;let h=d;h=a(c(h,s),u),h=a(c(h,s),p),h=a(c(h,s),f),h=a(c(h,s),l);const y=He(e,t,h);y<r||y>o||D.push(h)}return D}throw new Error("Intersection with bezier only defined up to degree 3, got "+(n.length-1))}function Ke(e,t,n,{angleMin:r=0,angleMax:o=2*Math.PI,eps:i=1e-10}={}){if(0===n.length)return[];if(1===n.length){const[r]=n;if(Math.abs(d)<i){const n=l(r,e),o=y(n);return Math.abs(o-t*t)<i?[]:r}return[]}if(2===n.length){const[s,a]=n;return Xe(s,a,e,t,{minA:0,maxA:1,angleMin:r,angleMax:o,eps:i})}if(3===n.length){let[s,f,p]=n;s=l(s,e),f=l(f,e),p=l(p,e);let[u,d,h]=_e(s,f,p),{x:y,y:m}=u,{x:g,y:w}=d,{x,y:b}=h;const v=_(x*x+b*b,2*g*x+2*w*b,2*y*x+g*g+2*m*b+w*w,2*y*g+2*m*w,y*y+m*m-t*t,i),A=[];for(let e=0;e<v.length;e++){const t=v[e];let n=!1;for(let r=e+1;r<v.length;r++)if(v[r],k(M(t,r))<i){n=!0;break}n||A.push(t)}const S=[];for(const t of A){if(Math.abs(C(t))>i)continue;const n=L(t);if(n<0||n>1)continue;const s=a(c(h,n*n),a(c(d,n),u));et(ze(s.x,s.y),r,o)&&S.push(a(s,e))}return S}throw new Error("Intersection with bezier only defined up to degree 2, got "+(n.length-1))}function Xe(e,t,n,r,{minA:o=-1/0,maxA:i=1/0,angleMin:s=0,angleMax:a=2*Math.PI,eps:l=1e-10}={}){s=De(s),a=De(a);const{x:c,y:f}=e,p=t.x-e.x,u=t.y-e.y,{x:d,y:h}=n,y=p*p+u*u,m=c-d,g=f-h,w=p*m+u*g;let x=w*w-y*(m*m+g*g-r*r);if(x<-l)return[];if(x=Math.max(0,x),x<l){const e=-w/y;if(e<o||e>i)return[];const t=c+e*p,n=f+e*u;return et(ze(t-d,n-h),s,a)?[{x:t,y:n}]:[]}let b=(-w+Math.sqrt(x))/y,v=(-w-Math.sqrt(x))/y;v<b&&([b,v]=[v,b]);let A=[];b>=o&&b<i&&A.push({x:c+b*p,y:f+b*u}),v>=o&&v<i&&A.push({x:c+v*p,y:f+v*u});const S=[];for(let e=0;e<A.length;e++){const t=A[e];et(ze(t.x-d,t.y-h),s,a)&&S.push(t)}return S}function Ze(e,t,n){return et(De(Math.atan2(e.y,e.x)),t,n)}function et(e,t,n){return t<n?e>=t&&e<=n:e>=t||e<=n}function tt(e,t,n,r,{angleMinA:o=0,angleMaxA:i=2*Math.PI,angleMinB:s=0,angleMaxB:a=2*Math.PI,eps:l=1e-10}={}){const c=e,f=n,p=f.x-c.x,u=f.y-c.y,d=p*p+u*u,h=r+t,y=r-t;if(d>h*h)return[];if(d<y*y)return[];const m=Math.sqrt(d),g=(t*t-r*r+d)/(2*m),w=c.x+g*p/m,x=c.y+g*u/m,b=t*t-g*g,v={x:w,y:x},A=De(o),S=De(i),P=De(s),M=De(a);if(Math.abs(b)<l)return Ze({x:v.x-c.x,y:v.y-c.y},A,S)&&Ze({x:v.x-f.x,y:v.y-f.y},P,M)?[v]:[];const E=Math.sqrt(b),O=[];O.push({x:w+E*u/m,y:x-E*p/m}),O.push({x:w-E*u/m,y:x+E*p/m});const D=[];for(let e=0;e<O.length;e++){const t=O[e];Ze({x:t.x-c.x,y:t.y-c.y},A,S)&&Ze({x:t.x-f.x,y:t.y-f.y},P,M)&&D.push(t)}return D}function nt(e,t,{eps:n=1e-10}={}){const{rx:r,ry:o,center:i,rotation:l}=e,{x:c,y:p}=i,{rx:d,ry:h,center:y,rotation:m}=t,{x:g,y:w}=y,x=Math.cos,b=Math.sin,v=x(2*m),A=b(2*m),S=x(l),P=b(l),M=x(l-2*m),E=b(l-2*m),O=x(2*l-2*m),D=b(2*l-2*m),z=_(-c*c*d*d*v/2+c*c*d*d/2+c*c*h*h*v/2+c*c*h*h/2-c*p*d*d*A+c*p*h*h*A+c*g*d*d*v-c*g*d*d-c*g*h*h*v-c*g*h*h+c*w*d*d*A-c*w*h*h*A-c*r*d*d*S+c*r*d*d*M-c*r*h*h*S-c*r*h*h*M+p*p*d*d*v/2+p*p*d*d/2-p*p*h*h*v/2+p*p*h*h/2+p*g*d*d*A-p*g*h*h*A-p*w*d*d*v-p*w*d*d+p*w*h*h*v-p*w*h*h-p*r*d*d*P-p*r*d*d*E-p*r*h*h*P+p*r*h*h*E-g*g*d*d*v/2+g*g*d*d/2+g*g*h*h*v/2+g*g*h*h/2-g*w*d*d*A+g*w*h*h*A+g*r*d*d*S-g*r*d*d*M+g*r*h*h*S+g*r*h*h*M+w*w*d*d*v/2+w*w*d*d/2-w*w*h*h*v/2+w*w*h*h/2+w*r*d*d*P+w*r*d*d*E+w*r*h*h*P-w*r*h*h*E-r*r*d*d*O/2+r*r*d*d/2+r*r*h*h*O/2+r*r*h*h/2-d*d*h*h,2*o*(-c*d*d*P+c*d*d*E-c*h*h*P-c*h*h*E+p*d*d*S+p*d*d*M+p*h*h*S-p*h*h*M+g*d*d*P-g*d*d*E+g*h*h*P+g*h*h*E-w*d*d*S-w*d*d*M-w*h*h*S+w*h*h*M-r*d*d*D+r*h*h*D),-c*c*d*d*v+c*c*d*d+c*c*h*h*v+c*c*h*h-2*c*p*d*d*A+2*c*p*h*h*A+2*c*g*d*d*v-2*c*g*d*d-2*c*g*h*h*v-2*c*g*h*h+2*c*w*d*d*A-2*c*w*h*h*A+p*p*d*d*v+p*p*d*d-p*p*h*h*v+p*p*h*h+2*p*g*d*d*A-2*p*g*h*h*A-2*p*w*d*d*v-2*p*w*d*d+2*p*w*h*h*v-2*p*w*h*h-g*g*d*d*v+g*g*d*d+g*g*h*h*v+g*g*h*h-2*g*w*d*d*A+2*g*w*h*h*A+w*w*d*d*v+w*w*d*d-w*w*h*h*v+w*w*h*h+r*r*d*d*O-r*r*d*d-r*r*h*h*O-r*r*h*h+2*o*o*d*d*O+2*o*o*d*d-2*o*o*h*h*O+2*o*o*h*h-2*d*d*h*h,2*o*(-c*d*d*P+c*d*d*E-c*h*h*P-c*h*h*E+p*d*d*S+p*d*d*M+p*h*h*S-p*h*h*M+g*d*d*P-g*d*d*E+g*h*h*P+g*h*h*E-w*d*d*S-w*d*d*M-w*h*h*S+w*h*h*M+r*d*d*D-r*h*h*D),-c*c*d*d*v/2+c*c*d*d/2+c*c*h*h*v/2+c*c*h*h/2-c*p*d*d*A+c*p*h*h*A+c*g*d*d*v-c*g*d*d-c*g*h*h*v-c*g*h*h+c*w*d*d*A-c*w*h*h*A+c*r*d*d*S-c*r*d*d*M+c*r*h*h*S+c*r*h*h*M+p*p*d*d*v/2+p*p*d*d/2-p*p*h*h*v/2+p*p*h*h/2+p*g*d*d*A-p*g*h*h*A-p*w*d*d*v-p*w*d*d+p*w*h*h*v-p*w*h*h+p*r*d*d*P+p*r*d*d*E+p*r*h*h*P-p*r*h*h*E-g*g*d*d*v/2+g*g*d*d/2+g*g*h*h*v/2+g*g*h*h/2-g*w*d*d*A+g*w*h*h*A-g*r*d*d*S+g*r*d*d*M-g*r*h*h*S-g*r*h*h*M+w*w*d*d*v/2+w*w*d*d/2-w*w*h*h*v/2+w*w*h*h/2-w*r*d*d*P-w*r*d*d*E-w*r*h*h*P+w*r*h*h*E-r*r*d*d*O/2+r*r*d*d/2+r*r*h*h*O/2+r*r*h*h/2-d*d*h*h),k=[];for(const c of z){if(Math.abs(C(c))>n)continue;const p=L(c);if(!et(De(2*Math.atan(p)),e.startAngle,e.endAngle))continue;const g=(1-p*p)/(1+p*p),w=2*p/(1+p*p);let x=f(s(r,o),s(g,w));x=u(x,l),x=a(x,i);const[b]=Ve([x],y,m,d,h);et(ze(b.x,b.y),t.startAngle,t.endAngle)&&k.push(x)}return k}function rt(e,t,n,{angleMin:r=0,angleMax:o=2*Math.PI,eps:i=1e-10}={}){const s=y(l(e,t))-n*n;return tt(t,n,e,Math.sqrt(s),{angleMinA:r,angleMaxA:o,eps:i})}function ot(e,t){const n=l(e,t.center);return Ze({x:n.x,y:n.y},t.startAngle,t.endAngle)}function it(e,t,{eps:n=1e-10}={}){let r=!1;t.r>e.r&&([e,t]=[t,e],r=!0);const o=l(t.center,e.center),i=m(o);let s=(e.r-t.r)/i;if(Math.abs(s)>1+n)return[];s=Math.min(1,Math.max(-1,s));const f=Math.acos(s),p=Math.atan2(o.y,o.x),u=p-f,d=g(1,p+f),h=g(1,u),y=[];y.push(a(c(d,e.r),e.center)),y.push(a(c(d,t.r),t.center)),y.push(a(c(h,e.r),e.center)),y.push(a(c(h,t.r),t.center));const w=[];for(let n=0;n<y.length;n+=2){let o=y[n+0],i=y[n+1];ot(o,e)&&ot(i,t)&&(r&&([o,i]=[i,o]),w.push(o,i))}return w}function st(e,t,{eps:n=1e-10}={}){let r=!1;t.r>e.r&&([e,t]=[t,e],r=!0);const o=l(t.center,e.center),i=m(o),s=e.r+t.r,f=Math.atan2(o.y,o.x);let p=s/i;if(Math.abs(p)>1+n)return[];p=Math.min(1,Math.max(-1,p));const u=Math.asin(p)-Math.PI/2,d=f+u,h=f-u,y=g(1,d),w=g(1,h),x=[];x.push(a(c(y,e.r),e.center)),x.push(a(c(g(1,d+Math.PI),t.r),t.center)),x.push(a(c(w,e.r),e.center)),x.push(a(c(g(1,h+Math.PI),t.r),t.center));const b=[];for(let n=0;n<x.length;n+=2){let o=x[n+0],i=x[n+1];ot(o,e)&&ot(i,t)&&(r&&([o,i]=[i,o]),b.push(o,i))}return b}function at(e,t){if((e.length-(t+1))%t!=0)throw new Error("Wrong number of input points");return 1===t?e.length-1:Math.floor(e.length/t)}function lt(e,t,n){if((e.length-(t+1))%t!=0)throw new Error("Wrong number of input points");const r=n*t,o=new Array(t+1);for(let n=0;n<=t;n++)o[n]=e[r+n];return o}class ct{static intersectors={};static setIntersector(e,t,n,r=!0){const o=ct.intersectors[e]??{};if(o[t]=n,ct.intersectors[e]=o,e!==t&&r){const r=(e,t)=>n(t,e),o=ct.intersectors[t]??{};o[e]=r,ct.intersectors[t]=o}}static getIntersector(e,t){return(ct.intersectors[e]??{})[t]}static intersect(e,t){const n=e.type,r=t.type;return ct.getIntersector(n,r)(e,t)}static{ct.setIntersector(H,H,((e,t)=>{const n=We(e.p0,e.p1,t.p0,t.p1,{minA:e.leftOpen?-1/0:0,maxA:e.rightOpen?1/0:1,minB:t.leftOpen?-1/0:0,maxB:t.rightOpen?1/0:1});return n?ye({...n}):null})),ct.setIntersector(J,H,((e,t)=>{const n=a(e.ref,e),r=We(e.ref,n,t.p0,t.p1,{minA:0,maxA:1,minB:t.leftOpen?-1/0:0,maxB:t.rightOpen?1/0:1});return r?ye({...r}):null})),ct.setIntersector(J,J,((e,t)=>{const n=a(e.ref,e),r=a(t.ref,t),o=We(e.ref,n,t.ref,r,{minA:0,maxA:1,minB:0,maxB:1});return o?ye({...o}):null})),ct.setIntersector(X,H,((e,t)=>{const n=Xe(t.p0,t.p1,{x:e.center.x,y:e.center.y},e.r,{minA:t.leftOpen?-1/0:0,maxA:t.rightOpen?1/0:1,angleMin:e.startAngle,angleMax:e.endAngle}),r=[];for(let e=0;e<n.length;e++)r.push(ye({...n[e]}));return r})),ct.setIntersector(X,J,((e,t)=>{const n=a(t.ref,t);return Xe(t.ref,n,e.center,e.r,{minA:0,maxA:1,angleMin:e.startAngle,angleMax:e.endAngle}).map((e=>ye({...e})))})),ct.setIntersector(X,X,((e,t)=>{const n=tt(e.center,e.r,t.center,t.r,{angleMinA:e.startAngle,angleMaxA:e.endAngle,angleMinB:t.startAngle,angleMaxB:t.endAngle}),r=[];for(let e=0;e<n.length;e++)r.push(ye({...n[e]}));return r})),ct.setIntersector(Q,H,((e,t)=>{const{p0:n,p1:r}=t;return Ge(((e,o)=>We(n,r,e,o,{minA:t.leftOpen?-1/0:0,maxA:t.rightOpen?1/0:1,minB:0,maxB:1})),e.points,{wrapPoints:!1}).map((e=>ye({...e})))})),ct.setIntersector(Q,J,((e,t)=>{const[n,r]=[t.ref,a(t.ref,t)];return Ge(((e,t)=>We(n,r,e,t,{minA:0,maxA:1,minB:0,maxB:1})),e.points,{wrapPoints:!1}).map((e=>ye({...e})))})),ct.setIntersector(Q,X,((e,t)=>{const{points:n}=e;return Ge(((e,n)=>Xe(e,n,t.center,t.r,{angleMin:t.startAngle,angleMax:t.endAngle,minA:0,maxA:1})),n,{wrapPoints:!1}).map((e=>ye({...e})))})),ct.setIntersector(Q,Q,((e,t)=>{const{points:n}=e,{points:r}=t;return Ge(((e,t)=>Ge(((n,r)=>We(e,t,n,r,{minA:0,maxA:1,minB:0,maxB:1})),n,{wrapPoints:!1})),r,{wrapPoints:!1}).map((e=>ye({...e})))})),ct.setIntersector(K,H,((e,t)=>{const{points:n}=e;return Ge(((e,n)=>We(e,n,t.p0,t.p1,{minB:t.leftOpen?-1/0:0,maxB:t.rightOpen?1/0:1,minA:0,maxA:1})),n,{wrapPoints:!0}).map((e=>ye({...e})))})),ct.setIntersector(K,J,((e,t)=>{const{points:n}=e,[r,o]=[t.ref,a(t.ref,t)];return Ge(((e,t)=>We(r,o,e,t,{minB:0,maxB:1,minA:0,maxA:1})),n,{wrapPoints:!0}).map((e=>ye({...e})))})),ct.setIntersector(K,X,((e,t)=>{const{points:n}=e;return Ge(((e,n)=>Xe(e,n,t.center,t.r,{minA:0,maxA:1,angleMin:t.startAngle,angleMax:t.endAngle})),n,{wrapPoints:!0}).map((e=>ye({...e})))})),ct.setIntersector(K,Q,((e,t)=>{const{points:n}=e,{points:r}=t;return Ge(((e,t)=>Ge(((n,r)=>We(e,t,n,r,{minA:0,maxA:1,minB:0,maxB:1})),n,{wrapPoints:!0})),r,{wrapPoints:!1}).map((e=>ye({...e})))})),ct.setIntersector(K,K,((e,t)=>{const{points:n}=e,{points:r}=t;return Ge(((e,t)=>Ge(((n,r)=>We(e,t,n,r,{minA:0,maxA:1,minB:0,maxB:1})),n,{wrapPoints:!0})),r,{wrapPoints:!0}).map((e=>ye({...e})))})),ct.setIntersector(ee,H,((e,t)=>{const n=Qe(t.p0,t.p1,e.points,{minA:t.leftOpen?-1/0:0,maxA:t.rightOpen?1/0:1}),r=[];for(let e=0;e<n.length;e++)r.push(ye({...n[e]}));return r})),ct.setIntersector(ee,J,((e,t)=>{const[n,r]=[t.ref,a(t.ref,t)],o=Qe(n,r,e.points,{minA:0,maxA:1}),i=[];for(let e=0;e<o.length;e++)i.push(ye({...o[e]}));return i})),ct.setIntersector(ee,X,((e,t)=>{const n=Ke(t.center,t.r,e.points,{angleMin:t.startAngle,angleMax:t.endAngle}),r=[];for(let e=0;e<n.length;e++)r.push(ye({...n[e]}));return r})),ct.setIntersector(ee,Q,((e,t)=>{const{points:n}=e;return Ge(((e,t)=>Qe(e,t,n,{minA:0,maxA:1})),t.points,{wrapPoints:!1}).map((e=>ye({...e})))})),ct.setIntersector(ee,K,((e,t)=>{const{points:n}=e;return Ge(((e,t)=>Qe(e,t,n,{minA:0,maxA:1})),t.points,{wrapPoints:!0}).map((e=>ye({...e})))})),ct.setIntersector(ee,ee,((e,t)=>{const n=Ye(e.points,t.points,{}),r=[];for(let e=0;e<n.length;e++)r.push(ye({...n[e]}));return r})),ct.setIntersector(te,H,((e,t)=>{const{points:n,degree:r}=e;if((n.length-(r+1))%r!=0)throw new Error("Wrong number of input points");const o=[],i=new Array(r+1);for(let e=0;e<n.length-1;e+=r){for(let t=0;t<r+1;t++)i[t]=n[e+t];const s=Qe(t.p0,t.p1,i,{minA:t.leftOpen?-1/0:0,maxA:t.rightOpen?1/0:1});s&&(Array.isArray(s)?o.push(...s):o.push(s))}return o.map((e=>ye(e)))})),ct.setIntersector(te,J,((e,t)=>{const{points:n,degree:r}=e;if((n.length-(r+1))%r!=0)throw new Error("Wrong number of input points");const o=[],i=new Array(r+1),[s,l]=[t.ref,a(t.ref,t)];for(let e=0;e<n.length-1;e+=r){for(let t=0;t<r+1;t++)i[t]=n[e+t];const a=Qe(s,l,i,{minA:t.leftOpen?-1/0:0,maxA:t.rightOpen?1/0:1});a&&(Array.isArray(a)?o.push(...a):o.push(a))}return o.map((e=>ye(e)))})),ct.setIntersector(te,X,((e,t)=>{const{points:n,degree:r}=e;if((n.length-(r+1))%r!=0)throw new Error("Wrong number of input points");const o=[],i=new Array(r+1),{center:s,r:a,startAngle:l,endAngle:c}=t;for(let e=0;e<n.length-1;e+=r){for(let t=0;t<r+1;t++)i[t]=n[e+t];const t=Ke(s,a,i,{angleMin:l,angleMax:c});t&&(Array.isArray(t)?o.push(...t):o.push(t))}return o.map((e=>ye(e)))})),ct.setIntersector(te,Q,((e,t)=>{const{points:n,degree:r}=e;if((n.length-(r+1))%r!=0)throw new Error("Wrong number of input points");const o=[],i=new Array(r+1);for(let e=0;e<n.length-1;e+=r){for(let t=0;t<r+1;t++)i[t]=n[e+t];const s=Ge(((e,t)=>Qe(e,t,i,{minA:0,maxA:1})),t.points,{wrapPoints:!1});s&&(Array.isArray(s)?o.push(...s):o.push(s))}return o.map((e=>ye(e)))})),ct.setIntersector(te,K,((e,t)=>{const{points:n,degree:r}=e;if((n.length-(r+1))%r!=0)throw new Error("Wrong number of input points");const o=[],i=new Array(r+1);for(let e=0;e<n.length-1;e+=r){for(let t=0;t<r+1;t++)i[t]=n[e+t];const s=Ge(((e,t)=>Qe(e,t,i,{minA:0,maxA:1})),t.points,{wrapPoints:!0});s&&(Array.isArray(s)?o.push(...s):o.push(s))}return o.map((e=>ye(e)))})),ct.setIntersector(te,ee,((e,t)=>{const{points:n,degree:r}=e;if((n.length-(r+1))%r!=0)throw new Error("Wrong number of input points");const o=[],i=new Array(r+1);for(let e=0;e<n.length-1;e+=r){for(let t=0;t<r+1;t++)i[t]=n[e+t];const s=Ye(t.points,i,{});s&&(Array.isArray(s)?o.push(...s):o.push(s))}return o.map((e=>ye(e)))})),ct.setIntersector(te,te,((e,t)=>{const{points:n,degree:r}=e,{points:o,degree:i}=t;if((n.length-(r+1))%r!=0)throw new Error("Wrong number of input points");if((o.length-(i+1))%i!=0)throw new Error("Wrong number of input points");const s=[],a=new Array(r+1),l=new Array(i+1);for(let e=0;e<n.length-1;e+=r){for(let t=0;t<r+1;t++)a[t]=n[e+t];for(let e=0;e<o.length-1;e+=i){for(let t=0;t<i+1;t++)l[t]=o[e+t];const t=Ye(a,l,{});t&&(Array.isArray(t)?s.push(...t):s.push(t))}}return s.map((e=>ye(e)))})),ct.setIntersector(Z,H,((e,t)=>{let n=[t.p0,t.p1];n=Ve(n,e.center,e.rotation,e.rx,e.ry);let r=ct.getIntersector(H,X)(xe({p0:n[0],p1:n[1]}),Pe({r:1,startAngle:e.startAngle,endAngle:e.endAngle,center:{x:0,y:0}}));r=Re(r,e.center,e.rotation,e.rx,e.ry);const o=[];for(let e=0;e<r.length;e++)o.push(ye({...r[e]}));return o})),ct.setIntersector(Z,J,((e,t)=>{let n=[t.ref,a(t.ref,t)];n=Ve(n,e.center,e.rotation,e.rx,e.ry);let r=ct.getIntersector(H,X)(xe({p0:n[0],p1:n[1]}),Pe({r:1,startAngle:e.startAngle,endAngle:e.endAngle,center:{x:0,y:0}}));r=Re(r,e.center,e.rotation,e.rx,e.ry);const o=[];for(let e=0;e<r.length;e++)o.push(ye({...r[e]}));return o})),ct.setIntersector(Z,X,((e,t)=>{const n=nt(e,Me({center:t.center,rx:t.r,ry:t.r,startAngle:t.startAngle,endAngle:t.endAngle,rotation:0})),r=[];for(let e=0;e<n.length;e++)r.push(ye({...n[e]}));return r})),ct.setIntersector(Z,Q,((e,t)=>{let n=t.points;n=Ve(n,e.center,e.rotation,e.rx,e.ry);let r=ct.getIntersector(Q,X)(be({points:n}),Pe({r:1,startAngle:e.startAngle,endAngle:e.endAngle,center:{x:0,y:0}}));r=Re(r,e.center,e.rotation,e.rx,e.ry);const o=[];for(let e=0;e<r.length;e++)o.push(ye({...r[e]}));return o})),ct.setIntersector(Z,K,((e,t)=>{let n=t.points;n=Ve(n,e.center,e.rotation,e.rx,e.ry);let r=ct.getIntersector(K,X)(ve({points:n}),Pe({r:1,startAngle:e.startAngle,endAngle:e.endAngle,center:{x:0,y:0}}));r=Re(r,e.center,e.rotation,e.rx,e.ry);const o=[];for(let e=0;e<r.length;e++)o.push(ye({...r[e]}));return o})),ct.setIntersector(Z,ee,((e,t)=>{let n=t.points;n=Ve(n,e.center,e.rotation,e.rx,e.ry);let r=ct.getIntersector(ee,X)(Ae({points:n}),Pe({r:1,startAngle:e.startAngle,endAngle:e.endAngle,center:{x:0,y:0}}));r=Re(r,e.center,e.rotation,e.rx,e.ry);const o=[];for(let e=0;e<r.length;e++)o.push(ye({...r[e]}));return o})),ct.setIntersector(Z,te,((e,t)=>{let n=t.points;n=Ve(n,e.center,e.rotation,e.rx,e.ry);let r=ct.getIntersector(te,X)(Se({points:n,degree:t.degree}),Pe({r:1,startAngle:e.startAngle,endAngle:e.endAngle,center:{x:0,y:0}}));r=Re(r,e.center,e.rotation,e.rx,e.ry);const o=[];for(let e=0;e<r.length;e++)o.push(ye({...r[e]}));return o})),ct.setIntersector(Z,Z,((e,t)=>{const n=nt(e,t),r=[];for(let e=0;e<n.length;e++)r.push(ye({...n[e]}));return r}))}}function ft(e,t,n,{minA:r=-1/0,maxA:o=1/0,eps:i=1e-10}={}){const s=n.x-t.x,a=n.y-t.y,l=s*s+a*a;if(l<i)return{x:t.x,y:t.y,t:0};let c=(e.x-t.x)*s+(e.y-t.y)*a;return c/=l,c=Math.min(o,Math.max(r,c)),{x:t.x+c*s,y:t.y+c*a,t:c}}function pt(e,t,n,{angleMin:r=0,angleMax:o=2*Math.PI,eps:i=1e-10}={}){const s=e.x-t.x,a=e.y-t.y,l=s*s+a*a;if(l<i)return{x:t.x+n,y:t.y};const c=Math.sqrt(l),f=ze(s,a);if(f>=r&&f<o)return{x:t.x+s*n/c,y:t.y+a*n/c};{const e=Le(f,r)<Le(f,o)?r:o;return{x:t.x+n*Math.cos(e),y:t.y+n*Math.sin(e)}}}function ut(e,t,{eps:n=1e-10}={}){const r=t.length-1;if(r<0)throw new Error("No Bezier control points given");if(r>2)throw new Error("Closest Bezier point only defined for up to degree 2");if(0===r)return t[0];if(1===r)return ft(e,t[0],t[1],{minA:0,maxA:1,eps:n});let[o,i,s]=_e(...t),{x:f,y:p}=o,{x:u,y:d}=i,{x:h,y:m}=s;const{x:g,y:w}=e,x=B(4*h*h+4*m*m,6*u*h+6*d*m,4*f*h+2*u*u-4*h*g+4*p*m+2*d*d-4*m*w,2*f*u-2*u*g+2*p*d-2*d*w,n);let b=1/0,v=null;for(const t of x){if(Math.abs(C(t))>n)continue;let r=L(t);r=Math.min(1,Math.max(0,r));let f=s;f=a(c(f,r),i),f=a(c(f,r),o);const p=y(l(f,e));p<b&&(b=p,v=f)}return v}class dt{static closest={};static setClosestPointFunction(e,t){dt[e]=t}static getClosestPointFunction(e){return dt[e]}static closestPoint(e,t){const n=t.type;return dt.getClosestPointFunction(n)(e,t)}static{dt.setClosestPointFunction(Y,((e,t)=>t)),dt.setClosestPointFunction(H,((e,t)=>ye({...ft(e,t.p0,t.p1,{minA:t.leftOpen?-1/0:0,maxA:t.rightOpen?1/0:1})}))),dt.setClosestPointFunction(J,((e,t)=>{const n=a(t.ref,t);return ye(ft(e,t.ref,n,{minA:0,maxA:1}))})),dt.setClosestPointFunction(X,((e,t)=>ye({...pt(e,t.center,t.r,{angleMin:t.startAngle,angleMax:t.endAngle})}))),dt.setClosestPointFunction(Q,((e,t)=>{const{points:n}=t;let r=1/0,o=null;const i=n.length-1;for(let t=0;t<i;t++){const i=ft(e,n[t],n[t+1],{minA:0,maxA:1}),s=y(l(e,i));s<r&&(r=s,o=i)}return ye({...o,d2:r})})),dt.setClosestPointFunction(K,((e,t)=>{const{points:n}=t;let r=1/0,o=null;const i=n.length;for(let t=0;t<i;t++){const i=ft(e,n[t],n[(t+1)%n.length],{minA:0,maxA:1}),s=y(l(e,i));s<r&&(r=s,o=i)}return ye({...o,d2:r})})),dt.setClosestPointFunction(ee,((e,t)=>{const n=ut(e,t.points,{});return n?ye(n):re})),dt.setClosestPointFunction(te,((e,t)=>{const{points:n,degree:r}=t;if((n.length-(r+1))%r!=0)throw new Error("Wrong number of input points");let o=1/0,i=null;const s=new Array(r+1);for(let t=0;t<n.length-1;t+=r){for(let e=0;e<r+1;e++)s[e]=n[t+e];const a=ut(e,s,{});if(!a)continue;const c=y(l(e,a));c<o&&(o=c,i=a)}return i?ye(i):re})),dt.setClosestPointFunction(Z,((e,t)=>{const[n]=Ve([e],t.center,t.rotation,t.rx,t.ry);let r=pt(n,{x:0,y:0},1,{angleMin:t.startAngle,angleMax:t.endAngle});return[r]=Re([r],t.center,t.rotation,t.rx,t.ry),ye({...r})}))}}function ht(e,...t){for(let n of t)if(e.type===n)return;throw new Error(`Expected type ${type}, got ${e.type}`)}class yt{constructor({x:e=0,y:t=0,ref:n={x:0,y:0},normalize:r=!1}={}){this.x=e,this.y=t,this.ref=n,this.normalize=r}static fromPosition({p:e,ref:t=oe,normalize:n=oe}){return le.new("pc",{p:e,ref:t,normalize:n})}static fromRefVector({ref:e=oe,v:t=oe,normalize:n=oe}){return le.new("rv",{ref:e,v:t,normalize:n})}static fromCoordinates({x:e=oe,y:t=oe,refX:n=oe,refY:r=oe,normalize:o=oe}){return le.new("c",{x:e,y:t,refX:n,refY:r,normalize:o})}static fromLineSegment(e,t=oe){return le.new("l",{line:e,normalize:t})}static fromPoints(e,t,n=oe){return le.new("pp",{p0:e,p1:t,normalize:n})}static fromPolar({polar:e,ref:t=oe,normalize:n=oe}){return le.new("pol",{polar:e,ref:t,normalize:n})}compute(e){const{dependencies:t}=e;let{x:n,y:r,ref:o,normalize:i}=this;if("rv"===e.name){const{ref:e,v:s,normalize:a}=t;se(e)||(ht(e,Y),o=e),se(s)||(ht(s,J),n=s.x,r=s.y),se(a)||(ht(a,q),i=a.value)}else if("c"===e.name){const{x:e,y:s,refX:a,refY:l,normalize:c}=t;se(e)||(ht(e,$),n=e.value),se(s)||(ht(s,$),r=s.value),se(a)||(ht(a,$),o.x=a.value),se(l)||(ht(l,$),o.y=l.value),se(c)||(ht(c,q),i=c.value)}else if("pc"===e.name){const{p:e,normalize:s,ref:a}=t;se(e)||(ht(e,Y),n=e.x,r=e.y),se(s)||(ht(s,q),i=s.value),se(a)||(ht(a,Y),o=a)}else if("l"===e.name){const{line:e,normalize:s}=t;ae(e),ht(e,H);const{p0:a,p1:c}=e;({x:n,y:r}=l(c,a)),o=a,se(s)||(ht(s,q),i=s.value)}else if("pp"===e.name){const{p0:e,p1:s,normalize:a}=t;ae(e,s),ht(e,Y),ht(s,Y),o=e,se(a)||(ht(a,q),i=a.value),({x:n,y:r}=l(s,e))}else if("pol"===e.name){const{polar:e,ref:s,normalize:a}=t;ae(e),ht(e,G);const{r:l,alpha:c}=e;({x:n,y:r}=g(l,c)),se(s)||(ht(s,Y),o=s),se(a)||(ht(a,q),i=a.value)}else if(e!==ce)throw new Error("No suitable parameters found to construct Vector");return i&&({x:n,y:r}=x(s(n,r))),ge({x:n,y:r,ref:o})}}class mt{constructor({normalize:e=!1,ref:t={x:0,y:0}}={}){this.normalize=e,this.ref=t}static fromPointCoordinates({p:e,ref:t=oe,normalize:n=oe}){return le.new("pc",{p:e,ref:t,normalize:n})}static fromLine({line:e,ref:t=oe,normalize:n=oe}){return le.new("l",{line:e,ref:t,normalize:n})}static fromVector({v:e,ref:t=oe,normalize:n=oe}){return le.new("v",{v:e,ref:t,normalize:n})}static fromCoordinates({x:e,y:t,ref:n=oe,normalize:r=oe}){return le.new("c",{x:e,y:t,ref:n,normalize:r})}static fromPoints({p0:e,p1:t,ref:n=oe,normalize:r=oe}){return le.new("pp",{p0:e,p1:t,ref:n,normalize:r})}static fromArc(e,t,n=oe){return le.new("arc",{p:e,arc:t,normalize:n})}static fromEllipse(e,t,n=oe){return le.new("eli",{p:e,ellipse:t,normalize:n})}static circleNormal(e,t,n){return e=l(e,t),c(e,2/(n*n))}static ellipseNormal(e,t,n,r,o){let i=l(e,t);i=u(i,-o);let a=s(2*i.x/(n*n),2*i.y/(r*r));return a=u(a,o),a}compute(e){const{dependencies:t}=e;let n,{normalize:r,ref:o}=this;if("pc"===e.name){const{p:e,ref:i,normalize:s}=t;ae(e),ht(e,Y),se(i)||(ht(i,Y),o=i),se(s)||(ht(s,q),r=s.value),n=v(e)}else if("l"===e.name){const{line:e,ref:i,normalize:s}=t;ae(e),ht(e,H);const{p0:a,p1:c}=e;n=v(l(c,a)),o=a,se(i)||(ht(i,Y),o=i),se(s)||(ht(s,q),r=s.value)}else if("v"===e.name){const{v:e,ref:i,normalize:s}=t;ae(e),ht(e,J),n=v(e),o=e.ref,se(i)||(ht(i,Y),o=i),se(s)||(ht(s,q),r=s.value)}else if("c"===e.name){const{x:e,y:i,ref:a,normalize:l}=t;ae(e,i),ht(e,$),ht(i,$),n=v(s(e.val,i.val)),se(a)||(ht(a,Y),o=a),se(l)||(ht(l,q),r=l.value)}else if("pp"===e.name){const{p0:e,p1:i,ref:s,normalize:a}=t;ae(e,i),ht(e,Y),ht(i,Y),n=v(l(i,e)),o=e,se(s)||(ht(s,Y),o=s),se(a)||(ht(a,q),r=a.value),se(a)||(ht(a,q),r=a.value)}else if("arc"===e.name){const{p:e,arc:i,normalize:s}=t;ae(e,i),ht(e,Y),ht(i,X);const{r:a,center:l}=i;n=mt.circleNormal(e,l,a),o=e,se(s)||(ht(s,q),r=s.value)}else{if("eli"!==e.name)throw new Error("No suitable constructor found");{const{p:e,ellipse:i,normalize:s}=t;ae(e,i),ht(e,Y),ht(i,Z);const{rx:a,ry:l,rotation:c,center:f}=i;n=mt.ellipseNormal(e,f,a,l,c),o=e,se(s)||(ht(s,q),r=s.value)}}return r&&(n=x(n)),ge({x:n.x,y:n.y,ref:o})}}class gt{static fromVectorsOrLine({v:e,ref:t=oe}){return le.new("vl",{v:e,ref:t})}compute(e){const{dependencies:t}=e;let n={x:0,y:0},r={x:0,y:0};if("vl"!==e.name)throw new Error("No suitable constructor found");{const{v:e,ref:o}=t;if(se(e))throw new Error("Expected non-empty parameter");if(e.type===J)n=e.ref,r=Object.assign({},e);else{if(e.type!==H)throw new Error("Expected vector or line");{const{p0:t,p1:o}=e;n=t,r=l(o,t)}}if(!se(o)){if(o.type!==Y)throw new Error("Expected point");n=o}}const o=v({x:r.x,y:r.y});return xe({p0:n,p1:a(n,o),leftOpen:!0,rightOpen:!0})}}class wt{constructor({distance:e=1}={}){this.distance=e}#e(e,t,n){const r=v(t),o=m(r);if(o<1e-10)return re;r.x/=o,r.y/=o;const i=a(e,c(r,n));return xe({p0:i,p1:a(i,t),leftOpen:!0,rightOpen:!0})}static fromVectorsOrLine({v:e,distance:t=oe}){return le.new("vld",{v:e,distance:t})}static fromVectorsOrLineRef({v:e,ref:t=oe}){return le.new("vlr",{v:e,ref:t})}compute(e){const{dependencies:t}=e;let{distance:n}=this,r={x:0,y:0},o={x:0,y:0};if("vlr"===e.name){const{v:e,ref:i}=t;if(se(e))throw new Error("Expected non-empty");if(e.type===J)o=e,r=e.ref;else{if(e.type!==H)throw new Error("Expected vector or line");{const{p0:t,p1:n}=e;o=l(n,t),r=t}}if(!se(i)){if(i.type!==Y)throw new Error("Expected point");r=i,n=0}}else{if("vld"!==e.name)throw new Error("No suitable constructor found");{const{v:e,distance:i}=t;if(se(e))throw new Error("Expected non-empty");if(e.type===J)o=e,r=e.ref;else{if(e.type!==H)throw new Error("Expected vector or line");{const{p0:t,p1:n}=e;o=l(n,t),r=t}}if(!se(i)){if(i.type!==$)throw new Error("Expected number");n=i.value}}}return this.#e(r,o,n)}}class xt{constructor(e=!1){this.normalize=e}static fromVectorNormal({v:e,n:t,ref:n=oe,normalize:r=oe}){return le.new("vn",{v:e,n:t,ref:n,normalize:r})}static reflectVector(e,t){const n=h(e,t);return l(e,c(t,2*n))}compute(e){const{dependencies:t}=e;let{normalize:n}=this;if("vn"===e.name){const{v:e,n:r,ref:o,normalize:i}=t;ae(e,r),ht(e,J),ht(r,J);let s=e.ref,a=xt.reflectVector(e,r);return se(i)||(ht(i,q),n=i.value),n&&(a=x(a)),se(o)||(ht(o,Y),s=o),ge({x:a.x,y:a.y,ref:s})}throw new Error("No suitable constructor found")}}class bt{constructor({eta:e=1,normalize:t=!1}={}){this.eta=e,this.normalize=t}static fromVectorNormal({v:e,n:t,ref:n=oe,eta:r=oe,normalize:o=oe}){return le.new("vn",{v:e,n:t,ref:n,eta:r,normalize:o})}static refractVector(e,t,n){t=Object.assign({},t);let r=h(e,t);r>0&&(r=-r,t.x*=-1,t.y*=-1,n=1/n);const o=1-n*n*(1-r*r);return o<0?{x:0,y:0}:l(c(e,n),c(t,n*r+Math.sqrt(o)))}compute(e){const{dependencies:t}=e;if("vn"===e.name){const{v:e,n,ref:r,normalize:o,eta:i}=t;let{eta:s,normalize:a}=this;ae(e,n),ht(e,J),ht(n,J);let l=e.ref;se(o)||(ht(o,q),a=o.value),se(i)||(ht(i,$),s=i.value),se(r)||(ht(r,Y),l=r);let c=bt.refractVector(e,n,s);return a&&(c=x(c)),ge({x:c.x,y:c.y,ref:l})}throw new Error("No suitable constructor found")}}class vt{constructor({r:e=1,alpha:t=0,ref:n={x:0,y:0}}={}){this.r=e,this.alpha=t,this.ref=n}static fromPolar(e,t=oe){return le.new("pol",{polar:e,ref:t})}static fromAngle({angle:e,startAngle:t=oe,r:n=oe,ref:r=oe}){return le.new("ang",{angle:e,startAngle:t,r:n,ref:r})}static fromRadiusAngle({r:e=oe,alpha:t=oe,ref:n=oe}){return le.new("ra",{r:e,alpha:t,ref:n})}compute(e){let{r:t,alpha:n,ref:r}=this;const{dependencies:o}=e;if("ra"===e.name){const{r:e,alpha:i,ref:s}=o;se(e)||(ht(e,$),t=e.value),se(i)||(ht(i,$),n=i.value),se(s)||(ht(s,Y),r=s)}else if("ang"===e.name){const{angle:e,startAngle:i,r:s,ref:a}=o;ae(e),ht(e,U);const{value:l,start:c}=e;r=e.ref,se(s)||(ht(s,$),t=s.value),se(i)||(ht(i,$),c=i.value),se(a)||(ht(a,Y),r=a),n=c+l}else if("pol"===e.name){const{polar:e,ref:i}=o;ae(e),ht(e,G),({r:t,alpha:n}=e),se(i)||(ht(i,Y),r=i)}else if(e!==ce)throw new Error("No suitable constructor found");const{x:i,y:s}=g(t,n);return ge({x:i,y:s,ref:r})}}class At{constructor(e){this.value=e}static fromField(e,t,n=null){return le.new("ok",{obj:e},{key:t,transform:n})}compute(e){let{value:t}=this;const{dependencies:n}=e;if("ok"===e.name){const{obj:r}=n;ae(r);const{key:o,transform:i}=e.params;if(t=r[o],void 0===t)return re;if("number"!=typeof t)throw new Error("Trying to create number from non-number field");i&&i instanceof Function&&(t=i(t))}else if(e!==ce)throw new Error("No suitable constructor");return he(t)}}class St{constructor(e){this.value=e}static fromPredicate(e,t){return le.new("p",t,{predicate:e})}static fromNot(e){return le.new("not",{boolValue:e})}static OP_AND=0;static OP_OR=1;static fromOp(e,t){return le.new("op",e,{operation:t})}compute(e){let{value:t}=this;const{dependencies:n,params:r}=e;if("p"===e.name){const{predicate:e}=r;return de(e(n))}if("not"===e.name){const{boolValue:e}=n;return ae(e),ht(e,q),de(!e.value)}if("op"===e.name){const{boolValues:e}=n;ae(e);const{operation:t}=r,o=[];for(const t of e)ht(t,q),o.push(t.value);let i;if(t===St.OP_AND)i=o.reduce(((e,t)=>e&&t),!0);else{if(t!==St.OP_OR)throw new Error("Requested Boolean operation not supported");i=o.reduce(((e,t)=>e||t),!1)}return de(i)}if(e!==ce)throw new Error("No suitable constructor");return de(t)}}class Pt{static fromCondition(e,t){return le.new("c",{obj:e,condition:t})}static fromEitherOr(e,t,n){return le.new("eo",{obj0:e,obj1:t,condition:n})}compute(e){const{dependencies:t}=e;if("c"===e.name){const{obj:e,condition:n}=t;return ae(e,n),ht(n,q),n.value?e:re}if("eo"===e.name){const{obj0:e,obj1:n,condition:r}=t;return ae(e,n,r),ht(r,q),r.value?e:n}throw new Error("No suitable constructor")}}class Mt{static fromCurve(e,t,n=1e-10){return le.new("curve",{curve:e,p:t},{eps:n})}static bezierParam(e,t,n=1e-10){return fe(t,e.points,n)}static arcParam(e,t,n=1e-10){let{center:r,r:o,startAngle:i,endAngle:s}=e;i>s&&(s+=2*Math.PI);const a=s-i;let c=l(t,r);return Math.abs(y(c)-o*o)>n?[]:[(ze(c.x,c.y)-i)/a]}static ellipseParam(e,t,n=1e-10){let{center:r,rx:o,ry:i,rotation:s,startAngle:a,endAngle:l}=e;a>l&&(l+=2*Math.PI);const c=l-a;let[f]=Ve([t],r,s,o,i);return Math.abs(y(f)-1)>n?[]:[(ze(f.x,f.y)-a)/c]}static lineParam(e,t,n=1e-10){let{p0:r,p1:o}=e;const i=l(o,r),s=v(i),a=h(s,l(t,r));if(Math.abs(a)>n)return[];const c=He(r,o,t);return c<0||c>1?[]:[c]}static vectorParam(e,t,n=1e-10){const r=v(e),o=h(r,l(t,e.ref));if(Math.abs(o)>n)return[];const i=He(e.ref,a(e,e.ref),t);return i<0||i>1?[]:[i]}static lineStripParam(e,t,n=1e-10){const r=[],{points:o}=e,i=o.length-1;for(let e=0;e<i;e++){let[s,a]=[o[e],o[e+1]];const c=l(a,s),f=v(c),p=h(f,l(t,s));if(Math.abs(p)>n)continue;const u=He(s,a,t);u<0||u>1||r.push((u+e)/i)}return r}static polygonParam(e,t,n=1e-10){const r=[],{points:o}=e,i=o.length;for(let e=0;e<i;e++){let[s,a]=[o[e],o[(e+1)%o.length]];const c=l(a,s),f=v(c),p=h(f,l(t,s));if(Math.abs(p)>n)continue;const u=He(s,a,t);u<0||u>1||r.push((u+e)/i)}return r}static bezierSplineParam(e,t,n=1e-10){const r=[],{points:o,degree:i}=e,s=at(o,i);for(let e=0;e<s;e++){const a=fe(t,lt(o,i,e),n);r.push(...a.map((t=>(t+e)/s)))}return r}static curveParam(e,t,n){const r=e.type;if(r===ee)return Mt.bezierParam(e,t,n);if(r===X)return Mt.arcParam(e,t);if(r===Z)return Mt.ellipseParam(e,t);if(r===H)return Mt.lineParam(e,t,n);if(r===J)return Mt.vectorParam(e,t,n);if(r===Q)return Mt.lineStripParam(e,t,n);if(r===K)return Mt.polygonParam(e,t,n);if(r===te)return Mt.bezierSplineParam(e,t,n);throw new Error(`Object type ${r} not supported`)}compute(e){const{dependencies:t}=e;if("curve"===e.name){const{curve:n,p:r}=t,{eps:o}=e.params;return ae(n,r),ht(r,Y),Mt.curveParam(n,r,o).map((e=>he(e)))}throw new Error("No suitable constructor")}}class Et{constructor({text:e="",ref:t={x:0,y:0}}={}){this.text=e,this.ref=t}static fromObjectRef({obj:e=oe,ref:t=oe}){return le.new("or",{obj:e,ref:t})}compute(e){let{text:t,ref:n}=this;const{dependencies:r}=e;if("or"===e.name){const{obj:e,ref:o}=r;se(e)||(t=t instanceof Function?t(e):Oe(e)),se(o)||(ht(o,Y),n=o)}else if(e!==ce)throw new Error("No suitable constructor found");return t instanceof Function&&(t=t()),Ee({text:t,ref:n})}}class Ot{static fromVectorsOrLines(e,t){return le.new("vl",{v0:e,v1:t})}static USE_SMALLER_ANGLE=-1;static USE_COMPUTED_ANGLE=0;static USE_LARGER_ANGLE=1;static fromPoints(e,t,n,r=Ot.USE_COMPUTED_ANGLE){return le.new("ppp",{p0:e,p1:t,p2:n},{useAngle:r})}static fromFixedDir({v:e,fixedDir:t={x:1,y:0},useAngle:n=Ot.USE_COMPUTED_ANGLE}){return le.new("fd",{v:e},{useAngle:n,fixedDir:t})}compute(e){const{dependencies:t,params:n}=e;if("vl"===e.name){let e,n,r,o;const{v0:i,v1:s}=t;if(i.type===H)e=i.p0,n=l(i.p1,i.p0);else{if(i.type!==J)throw new Error(`Expected line or vector, got ${i.type} `);e=i.ref,n=i}if(s.type===H)r=s.p0,o=l(s.p1,s.p0);else{if(s.type!==J)throw new Error(`Expected line or vector, got ${s.type} `);r=s.ref,o=s}let c=We(e,a(e,n),r,a(r,o));return c||(c=e),we({value:Ce(n,o),start:Ce({x:1,y:0},n),ref:c})}if("ppp"===e.name){const{p0:e,p1:r,p2:o}=t;if(e.type!==Y||r.type!==Y||o.type!==Y)throw new Error(`Expected points, got ${e.type}, ${r.type}, ${o.type} `);const i=r,s=l(e,i),a=Ce(s,l(o,i));let c=Ce({x:1,y:0},s),f=c+a;f<c&&(f+=2*Math.PI);const{useAngle:p}=n,u=f-c;return p===Ot.USE_SMALLER_ANGLE?u>Math.PI&&([c,f]=[f,c]):p===Ot.USE_LARGER_ANGLE&&u<Math.PI&&([c,f]=[f,c]),we({value:f-c,start:c,ref:i})}if("fd"===e.name){let e,r;const{v:o}=t;ae(o),ht(o,J,H);const{fixedDir:i,useAngle:s}=n;o.type===H?(e=o.p0,r=l(o.p1,o.p0)):o.type===J&&(e=o.ref,r=o);const a=Ce(i,r);let c=Ce({x:1,y:0},i),f=c+a;f<c&&(f+=2*Math.PI);const p=f-c;return s===Ot.USE_SMALLER_ANGLE?p>Math.PI&&([c,f]=[f,c]):s===Ot.USE_LARGER_ANGLE&&p<Math.PI&&([c,f]=[f,c]),we({value:f-c,start:c,ref:e})}throw new Error("No suitable constructor found")}}class Dt{constructor({r:e=1,alpha:t=0}={}){this.r=e,this.alpha=t}static fromPointOrVector(e){return le.new("pv",{p:e})}static fromValues({r:e=oe,alpha:t=oe}){return le.new("v",{r:e,alpha:t})}compute(e){let{r:t,alpha:n}=this;const{dependencies:r}=e;if("pv"===e.name){const{p:e}=r;ae(e),ht(e,Y,J),t=m(e),n=ze(e.x,e.y)}else if("v"===e.name){const{r:e,alpha:o}=r;se(e)||(ht(e,$),t=e.value),se(o)||(ht(o,$),n=o.value)}else if(e!==ce)throw new Error("No suitable constructor");return me({r:t,alpha:n})}}class zt{constructor(e=0,t=0){this.x=e,this.y=t}static fromPointOrVector(e){return le.new("p",{p:e})}static fromCoordinates(e=oe,t=oe){return le.new("xy",{x:e,y:t})}static fromAttachedVector(e,t){return le.new("pv",{p:e,v:t})}static fromPolar(e){return le.new("pol",{polar:e})}compute(e){let{x:t,y:n}=this;const{dependencies:r}=e;if("p"===e.name){const{p:e}=r;if(se(e)||e.type!==Y&&e.type!==J)throw new Error("Point from point or vector requires 1 valid point or vector no suitable parameter set available");if(e.type===Y)t=e.x,n=e.y;else if(e.type===J){const{ref:r}=e;({x:t,y:n}=a(r,e))}}else if("xy"===e.name){const{x:e,y:o}=r;if(!se(e)){if(e.type!==$)throw new Error("Point from coordinates requires x to be either empty or a number");t=e.value}if(!se(o)){if(o.type!==$)throw new Error("Point from coordinates requires y to be either empty or a number");n=o.value}}else if("pv"===e.name){const{p:e,v:o}=r;if(se(e)||se(o))throw new Error("Point from point and vector requires non - empty parameter");if(e.type!==Y||o.type!==J)throw new Error("Point from point and vector requires a point and a vector");({x:t,y:n}=a(e,o))}else if("pol"===e.name){const{polar:e}=r;ae(e),ht(e,G),({x:t,y:n}=g(e.r,e.alpha))}else if(e!==ce)throw new Error("Point: No suitable parameter set available");return ye({x:t,y:n})}}class kt{constructor(e=0){this.t=e}static fromCurve({obj:e,t=oe}){return le.new("obj",{obj:e,t})}static ellipsePoint(e,t,n,r,o){let i=g(1,o);return[i]=Re([i],e,r,t,n),i}static circlePoint(e,t,n){return a(e,g(t,n))}static linePoint(e,t,n){return b(e,t,n)}static vectorPoint(e,t){return a(e.ref,c(e,t))}static lineStripPoint(e,t){t*=e.length-1;const n=Math.floor(t);t%=1;const[r,o]=[e[n],e[n+1]];return b(r,o,t)}static polygonPoint(e,t){t*=e.length;const n=Math.floor(t);t%=1;const[r,o]=[e[n],e[(n+1)%e.length]];return b(r,o,t)}static bezierPoint(e,t){return ue(e,t)}static bezierSplinePoint(e,t,n){n*=at(e,t);const r=Math.floor(n);return n%=1,ue(lt(e,t,r),n)}static curvePoint(e,t){const n=e.type;if(n===Z){const n=e;let{center:r,rx:o,ry:i,rotation:s,startAngle:a,endAngle:l}=n;a>l&&(l+=2*Math.PI);const c=a+t*(l-a);return ye(kt.ellipsePoint(r,o,i,s,c))}if(n===X){const n=e;let{center:r,r:o,startAngle:i,endAngle:s}=n;i>s&&(s+=2*Math.PI);const a=i+t*(s-i);return ye(kt.circlePoint(r,o,a))}if(n===H){const n=e;let{p0:r,p1:o}=n;return ye(kt.linePoint(r,o,t))}if(n===J){const n=e;return ye(kt.vectorPoint(n,t))}if(n===Q){const n=e;let{points:r}=n;if(r.length<2)return re;t*=r.length-1;const o=Math.floor(t);t%=1;const[i,s]=[r[o],r[o+1]];return ye(b(i,s,t))}if(n===K){const n=e;let{points:r}=n;return r.length<3?re:ye(kt.polygonPoint(r,t))}if(n===ee){const n=e;let{points:r}=n;return ye(kt.bezierPoint(r,t))}if(n===te){const n=e;let{points:r,degree:o}=n;return ye(kt.bezierSplinePoint(r,o,t))}throw new Error("Can't create point from given object")}compute(e){const{dependencies:t}=e;if("obj"===e.name){let{t:e}=this;const{obj:n,t:r}=t;return ae(n),se(r)||(ht(r,$),e=r.value),kt.curvePoint(n,e)}throw new Error("No suitable constructor")}}class Tt{constructor({t:e=0,normalize:t=!1,scale:n=1}={}){this.t=e,this.normalize=t,this.scale=n}static fromCurve({obj:e,t=oe,normalize:n=oe,scale:r=oe}){return le.new("obj",{obj:e,t,normalize:n,scale:r})}static lineTangent(e,t){return l(t,e)}static circleTangent(e,t){return s(-e*Math.sin(t),e*Math.cos(t))}static ellipseTangent(e,t,n,r){let o=s(-e*Math.sin(r),t*Math.cos(r));return o=u(o,n),o}static bezierTangent(e,t){return ue(pe(e),t)}static lineStripTangent(e,t){t*=e.length-1;const n=Math.floor(t);t%=1;const[r,o]=[e[n],e[n+1]];return l(o,r)}static polygonTangent(e,t){t*=e.length;const n=Math.floor(t);t%=1;const[r,o]=[e[n],e[(n+1)%e.length]];return l(o,r)}static bezierSplineTangent(e,t,n){n*=at(e,t);const r=Math.floor(n);return n%=1,ue(pe(lt(e,t,r)),n)}static vectorTangent(e){return e}static curveTangentRef(e,t){const n=e.type;if(n===X){const n=e;let{center:r,r:o,startAngle:i,endAngle:s}=n;i>s&&(s+=2*Math.PI);const a=i+t*(s-i),l=kt.circlePoint(r,o,a);return{v:Tt.circleTangent(o,a),ref:l}}if(n===Z){const n=e;let{center:r,rx:o,ry:i,rotation:s,startAngle:a,endAngle:l}=n;a>l&&(l+=2*Math.PI);const c=a+t*(l-a);return{v:Tt.ellipseTangent(o,i,s,c),ref:kt.ellipsePoint(r,o,i,s,c)}}if(n===H){const n=e;let{p0:r,p1:o}=n;const i=kt.linePoint(r,o,t);return{v:Tt.lineTangent(r,o),ref:i}}if(n===J){let n=e;const r=a(n.ref,c(n,t));return{v:Tt.vectorTangent(n),ref:r}}if(n===Q){const n=e;let{points:r}=n;if(r.length<2)return null;const o=kt.lineStripPoint(r,t);return{v:Tt.lineStripTangent(r,t),ref:o}}if(n===K){const n=e;let{points:r}=n;if(r.length<3)return null;const o=kt.polygonPoint(r,t);return{v:Tt.polygonTangent(r,t),ref:o}}if(n===ee){const n=e,{points:r}=n,o=kt.bezierPoint(r,t);return{v:Tt.bezierTangent(r,t),ref:o}}if(n===te){const n=e;let{points:r,degree:o}=n;const i=kt.bezierSplinePoint(r,o,t);return{v:Tt.bezierSplineTangent(r,o,t),ref:i}}throw new Error("Can't compute tangent from given object")}compute(e){const{dependencies:t}=e;let{t:n,normalize:r,scale:o}=this;if("obj"===e.name){const{obj:e,t:i,normalize:s,scale:a}=t;ae(e),se(i)||(ht(i,$),n=i.value),se(s)||(ht(s,q),r=s.value),se(a)||(ht(a,$),o=a.value);const l=Tt.curveTangentRef(e,n);let{v:f,ref:p}=l;return r&&(f=x(f)),f=c(f,o),ge({x:f.x,y:f.y,ref:p})}throw new Error("No suitable constructor")}}class It{constructor({t:e=0,normalize:t=!1,scale:n=1}={}){this.t=e,this.normalize=t,this.scale=n}static fromCurve({obj:e,t=oe,normalize:n=oe,scale:r=oe}){return le.new("obj",{obj:e,t,normalize:n,scale:r})}static circleNormal(e,t){let n=g(e,t);return c(n,2/(e*e))}static ellipseNormal(e,t,n,r){let o=s(e*Math.cos(r),t*Math.sin(r)),i=s(2*o.x/(e*e),2*o.y/(t*t));return i=u(i,n),i}static lineNormal(e,t){return v(l(t,e))}static lineStripNormal(e,t){t*=e.length-1;const n=Math.floor(t);t%=1;const[r,o]=[e[n],e[n+1]];return v(l(o,r))}static polygonNormal(e,t){t*=e.length;const n=Math.floor(t);t%=1;const[r,o]=[e[n],e[(n+1)%e.length]];return v(l(o,r))}static bezierNormal(e,t){const n=ue(pe(e),t);return v(n)}static bezierSplineNormal(e,t,n){n*=at(e,t);const r=Math.floor(n);n%=1;const o=pe(lt(e,t,r));return v(ue(o,n))}static normalRefFromObject(e,t){if(e.type===X){const n=e;let{center:r,r:o,startAngle:i,endAngle:s}=n;i>s&&(s+=2*Math.PI);const a=i+t*(s-i);return{n:It.circleNormal(o,a),ref:kt.circlePoint(r,o,a)}}if(e.type===Z){const n=e;let{center:r,rx:o,ry:i,rotation:s,startAngle:a,endAngle:l}=n;a>l&&(l+=2*Math.PI);const c=a+t*(l-a),f=kt.ellipsePoint(r,o,i,s,c);return{n:It.ellipseNormal(o,i,s,c),ref:f}}if(e.type===H){const n=e;let{p0:r,p1:o}=n;const i=kt.linePoint(r,o,t);return{n:It.lineNormal(r,o),ref:i}}if(e.type===J){let n=e;const r=a(n.ref,c(n,t));return{n:v(n),ref:r}}if(e.type===Q){const n=e;let{points:r}=n;if(r.length<2)return re;const o=kt.lineStripPoint(r,t);return{n:It.lineStripNormal(r,t),ref:o}}if(e.type===K){const n=e;let{points:r}=n;if(r.length<3)return re;const o=kt.polygonPoint(r,t);return{n:It.polygonNormal(r,t),ref:o}}if(e.type===ee){const n=e,{points:r}=n,o=kt.bezierPoint(r,t);return{n:It.bezierNormal(r,t),ref:o}}if(e.type===te){const n=e;let{points:r,degree:o}=n;const i=kt.bezierSplinePoint(r,o,t);return{n:It.bezierSplineNormal(r,o,t),ref:i}}throw new Error("Can't compute tangent on given object")}compute(e){const{dependencies:t,params:n}=e;let{t:r,normalize:o,scale:i}=this;if("obj"===e.name){const{obj:e,t:n,normalize:s,scale:a}=t;ae(e),se(n)||(ht(n,$),r=n.value),se(s)||(ht(s,q),o=s.value),se(a)||(ht(a,$),i=a.value);let{n:l,ref:f}=It.normalRefFromObject(e,r,o);return o&&(l=x(l)),l=c(l,i),ge({x:l.x,y:l.y,ref:f})}throw new Error("No suitable constructor")}}class Lt{static fromPointArc(e,t){return le.new("pa",{p:e,arc:t})}static fromOuterTangents(e,t){return le.new("ot",{arc0:e,arc1:t})}static fromInnerTangents(e,t){return le.new("it",{arc0:e,arc1:t})}static fromPointEllipse(e,t){return le.new("pe",{p:e,ellipse:t})}compute(e){const{dependencies:t}=e;if("pa"===e.name){const{p:e,arc:n}=t;ae(e,n),ht(e,Y),ht(n,X);const r=rt(e,n.center,n.r,{angleMin:n.startAngle,angleMax:n.endAngle});return r&&0!==r.length?r.map((e=>ye(e))):re}if("pe"===e.name){const{p:e,ellipse:n}=t;ae(e,n),ht(e,Y),ht(n,Z);const{center:r,rx:o,ry:i,rotation:a,startAngle:l,endAngle:c}=n,[f]=Ve([e],r,a,o,i);let p=rt(f,s(0,0),1,{angleMin:l,angleMax:c});return p&&0!==p.length?(p=Re(p,r,a,o,i),p.map((e=>ye(e)))):re}if("ot"===e.name){const{arc0:e,arc1:n}=t;ae(e,n),ht(e,X),ht(n,X);const r=it(e,n);return r&&0!==r.length&&r.length%2==0?r.map((e=>ye(e))):re}if("it"===e.name){const{arc0:e,arc1:n}=t;ae(e,n),ht(e,X),ht(n,X);const r=st(e,n);return r&&0!==r.length&&r.length%2==0?r.map((e=>ye(e))):re}throw new Error("No suitable constructor")}}class Ct{static fromPointArc(e,t,{leftOpen:n=!1,rightOpen:r=!1}={}){return le.new("pa",{p:e,arc:t},{leftOpen:n,rightOpen:r})}static fromPointEllipse(e,t,{leftOpen:n=!1,rightOpen:r=!1}={}){return le.new("pe",{p:e,ellipse:t},{leftOpen:n,rightOpen:r})}static fromOuterTangents(e,t,{leftOpen:n=!1,rightOpen:r=!1}={}){return le.new("ot",{arc0:e,arc1:t},{leftOpen:n,rightOpen:r})}static fromInnerTangents(e,t,{leftOpen:n=!1,rightOpen:r=!1}={}){return le.new("it",{arc0:e,arc1:t},{leftOpen:n,rightOpen:r})}compute(e){const{dependencies:t}=e,{params:n}=e;if("pa"===e.name){const{p:e,arc:r}=t,{leftOpen:o,rightOpen:i}=n;ae(e,r),ht(e,Y),ht(r,X);const s=rt(e,r.center,r.r,{angleMin:r.startAngle,angleMax:r.endAngle});if(!s||0===s.length)return re;const a=[],l=ye(e);for(let e of s){const t=ye(e);a.push(xe({p0:l,p1:t,leftOpen:o,rightOpen:i}))}return a}if("pe"===e.name){const{p:e,ellipse:r}=t,{leftOpen:o,rightOpen:i}=n;ae(e,r),ht(e,Y),ht(r,Z);const{center:a,rx:l,ry:c,rotation:f,startAngle:p,endAngle:u}=r,[d]=Ve([e],a,f,l,c);let h=rt(d,s(0,0),1,{angleMin:p,angleMax:u});if(!h||0===h.length)return re;h=Re(h,a,f,l,c);const y=[],m=ye(e);for(let e of h){const t=ye(e);y.push(xe({p0:m,p1:t,leftOpen:o,rightOpen:i}))}return y}if("ot"===e.name){const{arc0:e,arc1:r}=t,{leftOpen:o,rightOpen:i}=n;ae(e,r),ht(e,X),ht(r,X);const s=it(e,r);if(!s||0===s.length||s.length%2!=0)return re;const a=[];for(let e=0;e<s.length;e+=2){const t=s[e+0],n=s[e+1];a.push(xe({p0:t,p1:n,leftOpen:o,rightOpen:i}))}return a}if("it"===e.name){const{arc0:e,arc1:r}=t,{leftOpen:o,rightOpen:i}=n;ae(e,r),ht(e,X),ht(r,X);const s=st(e,r);if(!s||0===s.length||s.length%2!=0)return re;const a=[];for(let e=0;e<s.length;e+=2){const t=s[e+0],n=s[e+1];a.push(xe({p0:t,p1:n,leftOpen:o,rightOpen:i}))}return a}throw new Error("No suitable constructor")}}class jt{static fromObject(e){return le.new("o",{obj:e})}static fromPoints(...e){return le.new("p",[...e])}compute(e){const{dependencies:t}=e;if("o"===e.name){const{obj:e}=t;if(ae(e),e instanceof Array){let t=0,n=0,r=0;for(let o=0;o<e.length;o++){if(e[o],e.type!==Y)throw new Error("MidPoint of array defined for points only");t+=e.x,n+=e.y,r++}return t/=r,n/=r,ye({x:t,y:n})}if(e.type===Y)return e;if(e.type===H){let t=e.p0.x+e.p1.x,n=e.p0.y+e.p1.y;return t*=.5,n*=.5,ye({x:t,y:n})}if(e.type===J)return ye(a(e.ref,c(e,.5)));if(e.type===X)return ye(e.center);if(e.type===Z)return ye(e.center);throw new Error("Object type not supported")}if("p"===e.name){if(!Array.isArray(t))throw new Error("Expected array");let e=0,n=0;for(let r=0;r<t.length;r++){const o=t[r];ht(o,Y),e+=o.x,n+=o.y}return e/=t.length,n/=t.length,ye({x:e,y:n})}throw new Error("No suitable constructor available")}}class Nt{static fromEllipse(e){return le.new("eli",{ellipse:e})}compute(e){const{dependencies:t}=e;if("eli"===e.name){const{ellipse:e}=t;ae(e),ht(e,Z);const{center:n,rx:r,ry:o,rotation:i}=e;if(Math.abs(r,o)<1e-10)return[ye(n)];const l=Math.max(r,o),c=Math.min(r,o),f=Math.sqrt(l*l-c*c);let p=[];return r>=o?(p.push(s(f,0)),p.push(s(-f,0))):(p.push(s(0,f)),p.push(s(0,-f))),p=p.map((e=>u(e,i))),p=p.map((e=>a(e,n))),p.map((e=>ye(e)))}throw new Error("No suitable constructor available")}}class Vt{constructor(e){this.f=e}static from(e={},t={},n=!1){return le.new("f",e,t,n)}compute(e){const{dependencies:t,params:n}=e;if("f"===e.name)return this.f(t,n);throw new Error("No suitable constructor")}}class Rt{constructor({p0:e={x:0,y:0},p1:t={x:0,y:0},leftOpen:n=!1,rightOpen:r=!1}={}){this.p0=e,this.p1=t,this.leftOpen=n,this.rightOpen=r}static fromVector(e){return le.new("v",{v:e})}static fromPointVector(e,t){return le.new("pv",{p:e,v:t})}static fromPoints(e,t){return le.new("pp",{p0:e,p1:t})}compute(e){const{dependencies:t}=e;let{p0:n,p1:r,leftOpen:o,rightOpen:i}=this;if("v"===e.name){const{v:e}=t;if(e.type!==J)throw new Error(`Require vector, got ${e.type} `);n=e.ref,r=a(n,e)}else if("pv"===e.name){const{p:e,v:o}=t;if(e.type!==Y)throw new Error(`Require point, got ${e.type} `);if(o.type!==J)throw new Error(`Require vector, got ${o.type} `);n=e,r=a(n,o)}else if("pp"===e.name){const{p0:e,p1:o}=t;if(e.type!==Y)throw new Error(`Require point, got ${e.type} `);if(o.type!==Y)throw new Error(`Require vector, got ${o.type} `);n=e,r=o}else if(e!==ce)throw new Error("No suitable LineSegment constructor found");return xe({p0:n,p1:r,leftOpen:o,rightOpen:i})}}class Bt{constructor(e=[]){this.points=e}static fromPoints(e,t=!1){return le.new("p",e,{attach:t})}static fromPointArray(e,t=!1){return le.new("pa",{pointArray:e},{attach:t})}static fromPolygon(e,t=!1){return le.new("poly",{poly:e},{attach:t})}compute(e){const{dependencies:t}=e;let{points:n}=this;const{attach:r}=e.params;if("p"===e.name){n=r?[...n]:[];for(const e of t)ae(e),ht(e,Y),n.push(e)}else if("poly"===e.name){const{poly:e}=t;ae(e),ht(e,K),r?n.push(...e.points):n=[...e.points]}else if("pa"===e.name){const{pointArray:e}=t;if(ae(e),!Array.isArray(e))throw new Error("Expected array");for(const t of e)ae(t),ht(t,Y);n=r?[...n,...e]:e}else if(e!==ce)throw new Error("No suitable constructor");return be({points:n})}}class Ft{constructor(e=[]){this.points=e}static fromPoints(e,t=!1){return le.new("p",e,{attach:t})}static fromPointArray(e,t=!1){return le.new("pa",{pointArray:e},{attach:t})}static fromLineStrip(e,t=!1){return le.new("ls",{lineStrip:e},{attach:t})}compute(e){const{dependencies:t}=e;let{points:n}=this;const{attach:r}=e.params;if("p"===e.name){n=r?[...n]:[];for(const e of t)ae(e),ht(e,Y),n.push(e)}else if("ls"===e.name){const{lineStrip:e}=t;ae(e),ht(e,Q),r?n.push(...n):n=[...e.points]}else if("pa"===e.name){const{pointArray:e}=t;if(ae(e),!Array.isArray(e))throw new Error("Expected array");for(const t of e)ae(t),ht(t,Y);n=r?[...n,...e]:e}else if(e!==ce)throw new Error("No suitable constructor");return ve({points:n})}}class Wt{constructor(e=[]){this.points=e}static fromPoints(e,t=!1){return le.new("p",e,{attach:t})}static fromPointArray(e,t=!1){return le.new("pa",{pointArray:e},{attach:t})}compute(e){const{dependencies:t}=e;let{points:n}=this;const{attach:r}=e.params;if("p"===e.name){n=r?[...n]:[];for(const e of t)ae(e),ht(e,Y),n.push(e)}else if("pa"===e.name){const{pointArray:e}=t;if(ae(e),!Array.isArray(e))throw new Error("Expected array");for(const t of e)ae(t),ht(t,Y);n=r?[...n,...e]:e}else if(e!==ce)throw new Error("No suitable constructor");return Ae({points:n})}}class _t{constructor({points:e=[],degree:t=1}){this.points=e,this.degree=t}static fromPoints(e,t=!1){return le.new("p",e,{attach:t})}static fromPointArray(e,t=!1){return le.new("pa",{pointArray:e},{attach:t})}compute(e){const{dependencies:t}=e;let{points:n}=this;const{degree:r}=this,{attach:o}=e.params;if("p"===e.name){n=o?[...n]:[];for(const e of t)ae(e),ht(e,Y),n.push(e)}else if("pa"===e.name){const{pointArray:e}=t;if(ae(e),!Array.isArray(e))throw new Error("Expected array");for(const t of e)ae(t),ht(t,Y);n=o?[...n,...e]:e}else if(e!==ce)throw new Error("No suitable constructor");return Se({points:n,degree:r})}}class qt{static fromArc(e){return le.new("arc",{arc:e})}static fromValues(e,t,n){return le.new("v",{r:e,startAngle:t,endAngle:n})}static calcArcLength(e,t,n){return t=De(t),(n=De(n))<t&&(n+=2*Math.PI),(n-t)*e}compute(e){const{dependencies:t}=e;if("arc"===e.name){const{arc:e}=t;ae(e),ht(e,X);const{r:n,startAngle:r,endAngle:o}=e;return he(qt.calcArcLength(n,r,o))}if("v"===e.name){const{r:e,startAngle:n,endAngle:r}=t;return he(qt.calcArcLength(e,n,r))}throw new Error("No suitable constructor")}}class $t{static fromVectorOrLine(e){return le.new("vl",{v:e})}static fromPoints(e,t){return le.new("pp",{p0:e,p1:t})}compute(e){let t=0,n=0;const{dependencies:r}=e;if("vl"===e.name){const{v:e}=r;if(ae(e),ht(e,J,H),e.type===J)t=e.x,n=e.y;else if(e.type===H){const{p0:r,p1:o}=e;t=o.x-r.x,n=o.y-r.y}}else{if("pp"!==e.name)throw new Error("No suitable constructor found");{const{p0:e,p1:o}=r;ae(e,o),ht(e,Y),ht(o,Y),t=o.x-e.x,n=o.y-e.y}}return he(t*t+n*n)}}class Ut{constructor(){this.ds=new $t}static fromVectorOrLine(e){return $t.fromVectorOrLine(e)}static fromPoints(e,t){return $t.fromPoints(e,t)}compute(e){const t=this.ds.compute(e);return t.value=Math.sqrt(t.value),t}}class Yt{constructor(e){this.key=e}static fromObject(e,t=null){return le.new("o",{obj:e},{transform:t})}compute(e){const{dependencies:t}=e;if("o"===e.name){const{obj:n}=t,{transform:r}=e.params;ae(n);let o=n[this.key];return void 0===o?re:(r&&r instanceof Function&&(o=r(o)),o)}throw new Error("No suitable constructor found")}}class Gt{constructor(...e){this.chain=[...e]}compute(e){const t=this.chain;let n=e;for(let e=0;e<t.length;e++){const r=t[e];n=r instanceof Function?r(n):t[e].compute(n)}return n}}class Jt{constructor(e){this.f=e}static fromArray(e){return le.new("a",e)}static fromValues(...e){return le.new("v",[...e])}compute(e){const{dependencies:t}=e,n=new Array(t.length),{f:r}=this;for(let e=0;e<t.length;e++)n[e]=r instanceof Function?r(t[e]):r.compute(t[e]);return n}}class Ht{constructor({r:e=1,center:t={x:0,y:0},startAngle:n=0,endAngle:r=2*Math.PI}={}){this.r=e,this.center=t,this.startAngle=n,this.endAngle=r}static fromValues({r:e=oe,center:t=oe,startAngle:n=oe,endAngle:r=oe}){return le.new("v",{r:e,center:t,startAngle:n,endAngle:r})}static fromPoints({p0:e,p1:t,p2:n,fullCircle:r=!1}){return le.new("ppp",{p0:e,p1:t,p2:n},{fullCircle:r})}static fromCenterAndPoints(e,t,n,r=Ot.USE_COMPUTED_ANGLE){return le.new("cap",{center:e,p0:t,p1:n},{useAngle:r})}static computeParametersFromPoints(e,t,n,r){const o=[e.x,e.y],i=[t.x,t.y],s=[n.x,n.y];if(I(o,i)||I(i,s)||I(s,o))return null;const a=O(M(s,o),M(i,o));if(Math.abs(a[1])<this.eps)return null;const l=E(a,D(a)),c=P(O(E(M(i,o),M(a,l)),E([0,2],[C(a),0])),o),f=k(M(o,c));if(r)return{r:f,center:{x:L(c),y:C(c)},startAngle:0,endAngle:2*Math.PI};{const r={x:L(c),y:C(c)},o=[ze(e.x-r.x,e.y-r.y),ze(t.x-r.x,t.y-r.y),ze(n.x-r.x,n.y-r.y)];return{r:f,center:r,startAngle:Math.min(...o),endAngle:Math.max(...o)}}}compute(e){let{r:t,center:n,startAngle:r,endAngle:o}=this;const{dependencies:i,params:s}=e;if("v"===e.name){const{r:e,center:s,startAngle:a,endAngle:l}=i;se(e)||(ht(e,$),t=e.value),se(s)||(ht(s,Y),n=s),se(a)||(ht(a,$),r=a.value),se(l)||(ht(l,$),o=l.value)}else if("ppp"===e.name){const{p0:s,p1:a,p2:l}=i;ae(s,a,l),ht(s,Y),ht(a,Y),ht(l,Y);const{fullCircle:c}=e.params,f=Ht.computeParametersFromPoints(s,a,l,c);if(!f)return re;({r:t,center:n,startAngle:r,endAngle:o}=f)}else if("cap"===e.name){const{center:e,p0:a,p1:l}=i;ae(e,a,l),ht(e,Y),ht(a,Y),ht(l,Y);const c=a.x-e.x,f=a.y-e.y,p=c*c+f*f,u=Math.sqrt(p),d=l.x-e.x,h=l.y-e.y,y=d*d+h*h;if(Math.abs(p-y)>1e-7)return re;r=ze(a.x-e.x,a.y-e.y),o=ze(l.x-e.x,l.y-e.y);let m=r,g=o;g<m&&(g+=2*Math.PI);const{useAngle:w}=s,x=g-m;w===Ot.USE_SMALLER_ANGLE?x>Math.PI&&([m,g]=[g,m]):w===Ot.USE_LARGER_ANGLE&&x<Math.PI&&([m,g]=[g,m]),r=m,o=g,n=e,t=u}else if(e!==ce)throw new Error("No suitable constructor found");return Pe({r:t,center:n,startAngle:r,endAngle:o})}}class Qt{constructor({center:e={x:0,y:0},rx:t=1,ry:n=1,startAngle:r=0,endAngle:o=2*Math.PI,rotation:i=0}={}){this.center=e,this.rx=t,this.ry=n,this.startAngle=r,this.endAngle=o,this.rotation=i}static fromValues({center:e=oe,rx:t=oe,ry:n=oe,startAngle:r=oe,endAngle:o=oe,rotation:i=oe}){return le.new("v",{center:e,rx:t,ry:n,startAngle:r,endAngle:o,rotation:i})}compute(e){let{center:t,rx:n,ry:r,startAngle:o,endAngle:i,rotation:s}=this;const{dependencies:a}=e;if("v"===e.name){const{center:e,rx:l,ry:c,startAngle:f,endAngle:p,rotation:u}=a;se(e)||(ht(e,Y),t=e),se(l)||(ht(l,$),n=l.value),se(c)||(ht(c,$),r=c.value),se(f)||(ht(f,$),o=f.value),se(p)||(ht(p,$),i=p.value),se(u)||(ht(u,$),s=u.value)}else if(e!==ce)throw new Error("No suitable constructor");return Me({center:t,rx:n,ry:r,startAngle:o,endAngle:i,rotation:s})}}class Kt{static fromObject(e,t){return le.new("o",{p:e,obj:t})}static fromCollection(e,t){const n=[e];if(Array.isArray(t))n.push(...t);else for(const e of Object.keys(t))n.push(t[e]);return le.new("mo",n)}compute(e){const{dependencies:t}=e;let n=null;if("o"===e.name){const{p:e,obj:r}=t;ae(e,r),ht(e,Y),n=dt.closestPoint(e,r)}else{if("mo"!==e.name)throw new Error("No suitable constructor found");{const[e,...r]=t;ae(e,...r),ht(e,Y);let o=1/0;for(const t of r){ae(t);const r=dt.closestPoint(e,t);if(!r)continue;const i=y(l(r,e));i<o&&(o=i,n=r)}}}return n||re}}class Xt{static fromObjects(e,t){return le.new("o",{obj0:e,obj1:t})}compute(e){const{dependencies:t}=e;if("o"===e.name){const{obj0:e,obj1:n}=t;ae(e,n);return ct.intersect(e,n)||re}throw new Error("No suitable constructor found")}}class Zt{static fromObjects(e,{filterOutInvalid:t=!0,filterOutEmpty:n=!0,filterOutNull:r=!0,appendArrayDependencies:o=!1,ignoreInvalids:i=!1}={}){return le.new("o",e,{filterOutInvalid:t,filterOutEmpty:n,filterOutNull:r,appendArrayDependencies:o},i)}compute(e){const{dependencies:t}=e,{params:n}=e;if("o"===e.name){const{filterOutInvalid:e,filterOutEmpty:r,filterOutNull:o,appendArrayDependencies:i}=n,s=[];for(const n of Object.keys(t)){let a=t[n];null===a&&o||a===oe&&r||a===re&&e||(i&&Array.isArray(a)?s.push(...a):s.push(a))}return s}throw new Error("No suitable constructor")}}class en{constructor(e=.5){this.t=e}static fromObjects(e,t,n=oe){return le.new("o",{obj0:e,obj1:t,t:n})}static fromAngle(e,t=oe){return le.new("ang",{angle:e,t})}compute(e){const{dependencies:t}=e;let{t:n}=this;if("o"===e.name){const{obj0:e,obj1:r,t:o}=t;if(ae(e,r),se(o)||(ht(o,$),n=o.value),e.type!==r.type)throw new Error("Interpolation only defined for objects of same type");const i=e.type,s=1-n;if(i===$)return he(s*e.value+n*r.vallue);if(i===Y)return ye(b(e,r,n));if(i===J){const t=b(e,r,n),o=b(e.ref,r.ref,n);return ge({x:t.x,y:t.y,ref:o})}if(i===G)return me({r:s*e.r+n*r.r,alpha:s*e.alpha+n*r.alpha});if(i===U)return we({value:s*e.value+n*r.value,start:s*e.start+n*r.start,ref:b(e.ref,r.ref,n)});if(i===X)return Pe({r:s*e.r+n*r.r,startAngle:s*e.startAngle+n*r.startAngle,endAngle:s*e.endAngle+n*r.endAngle,center:b(e.center,r.center,n)});if(i===Z){const t=s*e.rx+n*r.rx,o=s*e.ry+n*r.ry,i=s*e.rotation+n*r.rotation,a=s*e.startAngle+n*r.startAngle,l=s*e.endAngle+n*r.endAngle;return Me({center:b(e.center,r.center,n),rx:t,ry:o,startAngle:a,endAngle:l,rotation:i})}if(i===H)return xe({p0:b(e.p0,r.p0,n),p1:b(e.p1,r.p1,n),leftOpen:e.leftOpen||r.leftOpen,rightOpen:e.rightOpen||r.rightOpen});if(i===Q){const t=e.points,n=r.points;if(t.length!==n.length)throw new Error("Interpolated points number must be the same");const o=new Array(t.length);return t.forEach(((e,t)=>{o[t]=b(e,n[t])})),be({points:o})}if(i===K){const t=e.points,n=r.points;if(t.length!==n.length)throw new Error("Interpolated points number must be the same");const o=new Array(t.length);return t.forEach(((e,t)=>{o[t]=b(e,n[t])})),ve({points:o})}if(i===ee){const t=e.points,n=r.points;if(t.length!==n.length)throw new Error("Interpolated points number must be the same");const o=new Array(t.length);return t.forEach(((e,t)=>{o[t]=b(e,n[t])})),Ae({points:o})}if(i===te){const t=e.points,n=r.points;if(t.length!==n.length)throw new Error("Interpolated points number must be the same");if(e.degree!==r.degree)throw new Error("Interpolation of Bezier splines requires same degree");const o=new Array(t.length);return t.forEach(((e,t)=>{o[t]=b(e,n[t])})),Se({points:o,degree:e.degree})}throw new Error(`Interpolation of given type ${i} not supported`)}if("ang"===e.name){const{angle:e,t:r}=t;ae(e),ht(e,U),se(r)||(ht(r,$),n=r.value);const{start:o,value:i,ref:s}=e;return we({value:n*i,start:o,ref:s})}throw new Error("No suitable construcotr")}}class tn{#t;#n;constructor(e){this.name=e,this.#t=[],this.#n=0}addCallback(e){const t=this.#n++;return this.#t.push({cb:e,id:t}),t}removeCallback(e){const t=this.#t.findIndex((t=>t.id===e));t>=0&&this.#t.splice(t,1)}notify(e){for(let t=0;t<this.#t.length;t++){const{cb:n}=this.#t[t];if(n(e))break}}}class nn{constructor(e,t){this.scene=e,this.index=t}}class rn{constructor(e,t){this.scene=e,this.index=t}}class on{constructor(e,t){this.scene=e,this.index=t}}class sn{#r;#o;#i;#s;#a;#l;#c;#f;static EVENT_UPDATE="update";static EVENT_PROPERTY="property";static EVENT_REMOVE="remove";constructor(){this.#r=[],this.#o=[],this.#i=[],this.#s=[],this.#a=[],this.#l=[],this.#c=[],this.#f={},this.#f[sn.EVENT_UPDATE]=new tn(sn.EVENT_UPDATE),this.#f[sn.EVENT_PROPERTY]=new tn(sn.EVENT_PROPERTY),this.#f[sn.EVENT_REMOVE]=new tn(sn.EVENT_REMOVE)}registerCallback(e,t){const n=this.#f[e];return n?n.addCallback(t):-1}removeCallback(e,t){const n=this.#f[e];n&&n.removeCallback(t)}#p(e,t){const n=this.#f[e];if(!n)throw"Trying to notify events that do not exist";n.notify(t)}#u(e,t){t>=e.length&&(e.length=t+1)}#d(e,t){const n=[],r=t.dependencies;for(Object.keys(r).forEach((e=>n.push(r[e])));n.length>0;){const t=n.pop();if(t===oe||t<0)continue;if(t===e)return!0;const r=this.#i[t].dependencies;Object.keys(r).forEach((e=>n.push(r[e])))}return!1}add(e,t=null,n={}){let r=this.#o.length;return this.#c.length>0&&(r=this.#c.pop()),this.set(r,e,t,n)}get(e){return e>=this.#o.length?null:{value:this.#r[e],definition:this.#o[e],createInfo:this.#i[e],index:e,properties:this.#l[e]}}#h(e){const t={};t[e]={idx:e,entries:{}};const n=[e];for(;n.length>0;){const e=n.shift(),r=this.#s[e]??[],o=t[e]??{idx:e,entries:{}};for(let e of r)o.entries[e]=e;n.push(...r),t[e]=o}const r={};r[e]=0;for(const e of Object.keys(t)){const{idx:n,entries:o}=t[e];for(const e of Object.keys(o)){const t=r[e]??0;r[e]=t+1}}const o=[];for(const e of Object.keys(r))0===r[e]&&o.push(e);const i=[];for(;o.length>0;){const e=o.shift(),{idx:n,entries:s}=t[e];i.push(n);for(let e of Object.keys(s)){let t=r[e];t--,t<1&&o.push(e),r[e]=t}}return i}#y(e){const t=this.#a[e];for(const e of t){const t=this.#i[e],n=this.#o[e];if(this.#r[e]=re,n)if(t===ce)this.#r[e]=n.compute(ce);else{const{dependencies:r}=t,o={name:t.name,dependencies:Array.isArray(r)?[]:{},params:t.params,ignoreInvalids:t.ignoreInvalids},i=o.dependencies;let s=!0;for(const e of Object.keys(r)){const n=r[e];if(n===oe||n<0)i[e]=oe;else{let r=this.#r[n];if(!ie(r)){if(!t.ignoreInvalids){s=!1;break}r=re}i[e]=r}}this.#r[e]=s?n.compute(o):re}this.#p("update",new nn(this,e))}}#m(e){this.#a[e]=this.#h(e);const t=this.#i[e].dependencies;for(const e of Object.keys(t)){const n=t[e];n===oe||n<0||this.#m(n)}}set(e,t,n=null,r={}){if(n||(n=ce),this.#i[e]){if(this.#d(e,n))throw new Error(`Adding element ${e} with dependencies[${JSON.stringify(n)}] would create a loop`);this.#g(e)}this.#u(this.#o,e),this.#u(this.#i,e),this.#u(this.#s,e),this.#u(this.#a,e),this.#u(this.#r,e),this.#u(this.#l,e),this.#i[e]=n,this.#o[e]=t,this.#l[e]=r;const o=n.dependencies;for(const t of Object.keys(o)){const n=o[t];if(n===oe||n<0)continue;let r=this.#s[n]??[];r.push(e),this.#s[n]=r}return this.#m(e),this.#y(e),e}update(e,t){if(e>=this.#o.length||!this.#o[e])throw new Error(`Trying to update non - existent definition at index ${e} `);this.#o[e]=t,this.#y(e)}setProperties(e,t){if(e>=this.#o.length||!this.#o[e])throw new Error(`Trying to update non - existent property at index ${e} `);this.#l[e]=t,this.#p("property",new on(this,e))}updateProperties(e,t){if(e>=this.#o.length||!this.#o[e])throw new Error(`Trying to update non - existent property at index ${e} `);r(this.#l[e],t),this.#p("property",new on(this,e))}#g(e){const t=this.#i[e].dependencies;this.#i[e]=null,this.#r[e]=re;const n=this.#s[e]??[];for(const e of n)this.#y(e);for(const n of Object.keys(t)){const r=t[n];if(r===oe||r<0)continue;const o=this.#s[r];if(void 0===o)throw new Error(`Trying to remove dependency ${e} from ${r} `);const i=o.findIndex((t=>t===e));if(i<0)throw new Error(`Trying to remove dependency ${e} from ${r} `);o.splice(i,1),this.#m(r)}}remove(e){if(e>=this.#o.length)throw new Error(`Trying to delete non - existent definition at index ${e} `);if(!this.#o[e])throw new Error(`Trying to delete non - existent definition at index ${e} `);this.#p("remove",new nn(this,e)),this.#g(e),this.#i[e]=null,this.#a[e]=null,this.#o[e]=null,this.#l[e]=null,this.#c.push(e)}view({skipInvalidValues:e=!0}={}){let t=0,n=this.#o,r=this.#r,o=this;return{*[Symbol.iterator](){for(;t<n.length;){for(;(!n[t]||e&&!ie(r[t]))&&t<n.length;)t++;t<n.length&&(yield o.get(t),t++)}}}}}i.vec2;const an={primitives:{line:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0},text:{font:"10px sans-serif",textAlign:"start",textBaseline:"alphabetic",direction:"inherit",fontKerning:"auto"}},geo:{point:{r:4,fillStyle:"rgb(255,0,0)",strokeStyle:"rgb(0,0,0)",outline:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}},text:{fillStyle:"rgb(0,0,0)",strokeStyle:"rgb(0,0,0)",outline:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0},textStyle:{font:"10px sans-serif",textAlign:"start",textBaseline:"alphabetic",direction:"inherit",fontKerning:"auto"},offset:{x:0,y:0}},angle:{r:20,toDeg:!0,arc:{showDirection:!0,fillStyle:"rgba(255,0,0,0.25)",strokeStyle:"rgb(0,0,0)",outline:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}},text:{show:!0,fillStyle:"rgb(0,0,0)",strokeStyle:"rgba(0,0,0,0)",radius:1.5,textStyle:{font:"10px sans-serif",textAlign:"start",textBaseline:"alphabetic",direction:"inherit",fontKerning:"auto"},outline:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0},transform:(e,t)=>{const n=new Intl.NumberFormat("en-US",{minimumFractionDigits:0,maximumFractionDigits:0}).format(e);return t?`${n}°`:`${n}`}}},arc:{fillStyle:"rgba(0,0,0,0)",strokeStyle:"rgb(0,0,0)",outline:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0},closeArc:!1},line:{strokeStyle:"rgb(0,0,0)",lineStyle:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}},vector:{shaft:{fillStyle:"rgb(0,0,0)",strokeStyle:"rgb(0,0,0)",lineStyle:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}},arrow:{length:.2,width:.05,sizeRelative:!0,fillStyle:"rgb(0,0,0)",strokeStyle:"rgb(0,0,0)",lineStyle:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}}},polygon:{strokeStyle:"rgb(0,0,255)",fillStyle:"rgba(0,0,255,0.25)",lineStyle:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}}}};function ln(e){const t=e.target.getBoundingClientRect();return{x:e.clientX-t.left,y:e.clientY-t.top}}const cn={grid:{show:!1},axes:{show:!1}},fn={grid:{strokeStyle:"rgb(192,192,192)",lineStyle:{lineWidth:1,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0},xticks:1,yticks:1,show:!0},axes:{show:!0,x:{strokeStyle:"rgb(0,0,0)",lineStyle:{lineWidth:2,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0},ticks:{show:!0,spacing:1,size:.1,strokeStyle:"rgb(0,0,0)",lineStyle:{lineWidth:2,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}},labels:{show:!0,strokeStyle:"rgb(192,192,192)",fillStyle:"rgb(192,192,192)",textStyle:{font:"10px sans-serif",textAlign:"start",textBaseline:"alphabetic",direction:"inherit",fontKerning:"auto"}},show:!0},y:{strokeStyle:"rgb(0,0,0)",lineStyle:{lineWidth:2,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0},ticks:{show:!0,spacing:1,size:.1,strokeStyle:"rgb(0,0,0)",lineStyle:{lineWidth:2,lineCap:"butt",lineJoin:"miter",miterLimit:10,lineDash:[],lineDashOffset:0}},labels:{show:!0,strokeStyle:"rgb(192,192,192)",fillStyle:"rgb(192,192,192)",textStyle:{font:"10px sans-serif",textAlign:"start",textBaseline:"alphabetic",direction:"inherit",fontKerning:"auto"}},show:!0},numberFormatter:null}};function pn(e,t,n,r,o,i){let s=e*Math.ceil(t/e);const a=(s-t)/n,l=e/n,c=n/e;let f=[];for(let t=0;t<c;t++){let n=a+t*l,c=s+t*e;r&&(n=1-n),n=n*i+o,f.push([c,n])}return f}class un{static#w=0;static#x=1;#b;#v;constructor(e,t,n,r){this.scene=e,this.writePoints=[],this.readPoints=[],this.handlers={};for(let e of r){const{write:t,read:n,radius:r}=e;this.writePoints.push(t),this.readPoints.push({index:n,radius:r})}this.#b=0,this.#v={},this.attach(n,t)}detach(){for(let e of Object.keys(this.handlers))this.#A(e);this.#v.down=!1,this.#v.lastPos=null,this.#v.lastDownPos=null,this.#b=un.#w}attach(e,t){this.detach(),this.handlers={},this.canvas=e,this.coordinateMapper=t,this.#S("mousedown",(e=>this.#P(e))),this.#S("mouseup",(e=>this.#M(e))),this.#S("mouseleave",(e=>this.#E(e))),this.#S("mousemove",(e=>this.#O(e)))}#S(e,t){this.#A(e),this.canvas.addEventListener(e,t),this.handlers[e]=t}#A(e){const t=this.handlers[e];t&&(this.canvas.removeEventListener(e,t),delete this.handlers[e])}#P(e){const t=ln(e);if(this.#v.down=!0,this.#v.lastPos=t,this.#v.lastDownPos=t,this.#b===un.#w){let e=-1,n=1/0;const r=this.coordinateMapper.convertSurfaceToLocal(t.x,t.y),o=this.scene;for(let t=0;t<this.readPoints.length;t++){const s=this.readPoints[t],a=o.get(s.index).value;ht(a,Y);const l=i.len2(i.sub(a,r)),c=s.radius/this.coordinateMapper.scalingLocalToSurface();l<c*c&&l<n&&(n=l,e=t)}e>=0&&(this.#b=un.#x,this.#v.idx=e)}}#M(e){const t=ln(e);this.#v.down=!1,this.#v.lastPos=t,this.#v.lastDownPos=null,this.#b=un.#w}#E(e){const t=ln(e);this.#v.down=!1,this.#v.lastPos=t,this.#v.lastDownPos=null,this.#b=un.#w}#O(e){const t=ln(e),n=this.coordinateMapper.convertSurfaceToLocal(t.x,t.y);if(this.#b===un.#x){const{idx:e}=this.#v,t=this.writePoints[e];this.scene.update(t,new zt(n.x,n.y))}this.#v.lastPos=t}static createForPoints(e,t,n,r,o){const i=[];for(let e of r)i.push({read:e,write:e,radius:o});return new un(e,t,n,i)}static createForPointsAndHandles(e,t,n,r,o){const i=[];for(let e=0;e<r.length;e++){const t=r[e];let n,s;Array.isArray(t)&&2===t.length?2===t.length?[n,s]=t:(n=t[0],s=n):(n=t,s=n),i.push({read:n,write:s,radius:o})}return new un(e,t,n,i)}}class dn{constructor({x0:e=0,y0:t=0,x1:n=1,y1:r=1,flipY:o=!0,width:i,height:s}){this.surface={width:i,height:s},this.flipY=o,this.updateViewport({x0:e,y0:t,x1:n,y1:r})}updateSurface(e,t){this.surface={width:e,height:t},this.#D()}updateViewport({x0:e,y0:t,x1:n,y1:r}={}){this.requestedViewport={x0:e,y0:t,x1:n,y1:r},this.#D()}convertLocalToSurface(e,t){const{x0:n,y0:r,x1:o,y1:i}=this;return e=(e-n)/(o-n),t=(t-r)/(i-r),this.flipY&&(t=1-t),{x:e*=this.surface.width,y:t*=this.surface.height}}convertSurfaceToLocal(e,t){e/=this.surface.width,t/=this.surface.height,this.flipY&&(t=1-t);const{x0:n,y0:r,x1:o,y1:i}=this;return{x:e=e*(o-n)+n,y:t=t*(i-r)+r}}scalingLocalToSurface(){return this.surface.width/(this.x1-this.x0)}convertLocalAngleToSurface(e){return this.flipY?-e:e}isCounterClockwise(){return this.flipY}#D(){const{surface:e}=this;{const t=e.width/e.height,{x0:n,y0:r,x1:o,y1:i}=this.requestedViewport,s=o-n,a=i-r;let l,c;t>s/a?(c=a,l=c*t):(l=s,c=l/t);const f=.5*(n+o),p=.5*(r+i);this.x0=f-.5*l,this.y0=p-.5*c,this.x1=f+.5*l,this.y1=p+.5*c}const{x0:t,y0:n,x1:r,y1:o}=this,i=[{x:t,y:n},{x:r,y:n},{x:r,y:o},{x:t,y:o}],s=[];for(let e=0;e<i.length;e++){const t=i[e],n=i[(e+1)%i.length],r=n.x-t.x,o=n.y-t.y;s.push({p0:t,p1:n,n:{x:o,y:-r}})}this.viewportCorners=i,this.viewportSides=s}}class hn{constructor({x0:e=0,y0:t=0,x1:n=1,y1:r=1,flipY:o=!0,canvas:i}={}){this.flipY=o,this.canvas=i,this.context=i.getContext("2d"),this.coordinateMapper=new dn({x0:e,y0:t,x1:n,y1:r,flipY:o,width:i.width,height:i.height})}updateViewport({x0:e,y0:t,x1:n,y1:r}={}){this.coordinateMapper.updateViewport({x0:e,y0:t,x1:n,y1:r})}notifyCanvasSizeChanged(){this.coordinateMapper.updateSurface(this.canvas.width,this.canvas.height)}clear({fillAlpha:e=!0}={}){e?(this.context.save(),this.context.fillStyle="rgb(255,255,255)",this.context.fillRect(0,0,this.canvas.width,this.canvas.height),this.context.restore()):this.context.clearRect(0,0,this.canvas.width,this.canvas.height)}#z(e){const t=this.context,{lineWidth:n,lineCap:r,lineJoin:o,miterLimit:i,lineDash:s,lineDashOffset:a}=e;t.lineWidth=n,t.lineCap=r,t.lineJoin=o,t.miterLimit=i,t.setLineDash(s),t.lineDashOffset=a}#k(e){const t=this.context,{font:n,textAlign:r,textBaseline:o,direction:i,fontKerning:s}=e;t.font=n,t.textAlign=r,t.textBaseline=o,t.direction=i,t.fontKerning=s}drawBackground(e=cn){const{axes:t={},grid:n={},numberFormatter:r=(e=>e)}=e,{x0:o,y0:i,x1:s,y1:a,flipY:l}=this.coordinateMapper,c=s-o,f=a-i,{canvas:p,context:u}=this,d=this.coordinateMapper;if(n.show){const{strokeStyle:e,lineStyle:t}=n;u.save(),this.#z(t),u.strokeStyle=e;const{xticks:r,yticks:s}=n;let a=[];"number"==typeof r?a=pn(r,o,c,!1,0,p.width):Array.isArray(r)&&(a=r.map((e=>[e,(e-o)/c*p.width])));let d=[];"number"==typeof s?d=pn(s,i,f,l,0,p.height):Array.isArray(s)&&(d=s.map((e=>[e,(e-i)/f*p.height]))),u.beginPath();for(let e of a){const[,t]=e;u.moveTo(t,0),u.lineTo(t,p.height)}for(let e of d){const[,t]=e;u.moveTo(0,t),u.lineTo(p.width,t)}u.stroke(),u.restore()}if(t.show){u.save();const e=d.convertLocalToSurface(0,0),{x:n,y:s}=t;if(n.show){const{strokeStyle:t,lineStyle:i}=n;u.strokeStyle=t,this.#z(i),u.beginPath(),u.moveTo(0,e.y),u.lineTo(p.width,e.y),u.stroke();const{ticks:s}=n;if(s.show){const t=pn(s.spacing,o,c,!1,0,p.width);u.strokeStyle=s.strokeStyle,this.#z(s.lineStyle);const{size:i}=s,a=i*d.scalingLocalToSurface();u.beginPath();for(let n of t){const[,t]=n;u.moveTo(t,e.y-a),u.lineTo(t,e.y+a)}u.stroke();const{labels:l}=n;if(l.show){this.#k(l.textStyle);let n=1.5*-a;n*=this.flipY?-1:1;for(let o of t){const[t,i]=o,s=r(t),a=u.measureText(s),l=n+a.actualBoundingBoxAscent,c=.5*-a.width;u.fillText(s,i+c,e.y+l)}}}}if(s.show){const{strokeStyle:t,lineStyle:n}=s;u.strokeStyle=t,this.#z(n),u.beginPath(),u.moveTo(e.x,0),u.lineTo(e.x,p.height),u.stroke();const{ticks:o,labels:a}=s;if(o.show){const t=pn(o.spacing,i,f,this.flipY,0,p.height);u.strokeStyle=o.strokeStyle,this.#z(o.lineStyle);const{size:n}=o,s=n*d.scalingLocalToSurface();u.beginPath();for(let n of t){const[,t]=n;u.moveTo(e.x-s,t),u.lineTo(e.x+s,t)}if(u.stroke(),a.show){this.#k(a.textStyle);let n=1.5*-s;for(let o of t){const[t,i]=o,s=r(t),a=u.measureText(s),l=.5*(a.actualBoundingBoxAscent+a.actualBoundingBoxDescent),c=n-a.actualBoundingBoxRight;u.fillText(s,e.x+c,i+l)}}}}u.restore()}}drawPoint(e,t,n={}){n=o(an.geo.point,n);let{r,fillStyle:i,strokeStyle:s,outline:a}=n;const l=this.context;l.save(),l.fillStyle=i,l.strokeStyle=s,this.#z(a),({x:e,y:t}=this.coordinateMapper.convertLocalToSurface(e,t)),l.beginPath(),l.arc(e,t,r,0,2*Math.PI),l.fill(),l.stroke(),l.restore()}drawText(e,t,n,r={}){r=o(an.geo.text,r);let{fillStyle:i,strokeStyle:s,outline:a,textStyle:l,offset:c}=r;({x:e,y:t}=this.coordinateMapper.convertLocalToSurface(e+c.x,t+c.y));const f=this.context;f.save(),f.fillStyle=i,f.strokeStyle=s,this.#z(a),this.#k(l),f.beginPath(),f.strokeText(n,e,t),f.fillText(n,e,t),f.restore()}drawAngle(e,t,n,r,i={}){i=o(an.geo.angle,i);let{r:s,toDeg:a,arc:l,text:c}=i;const f=this.coordinateMapper,p=s/f.scalingLocalToSurface(),u=r+n,d=r+.5*n;let h=e+p*c.radius*Math.cos(d),y=t+p*c.radius*Math.sin(d),{x:m,y:g}=f.convertLocalToSurface(e,t);({x:h,y}=f.convertLocalToSurface(h,y));const w=this.context;if(w.save(),w.fillStyle=l.fillStyle,w.strokeStyle=l.strokeStyle,this.#z(l.outline),w.beginPath(),w.moveTo(m,g),w.arc(m,g,s,f.convertLocalAngleToSurface(r),f.convertLocalAngleToSurface(u),f.isCounterClockwise()),w.closePath(),w.fill(),w.stroke(),l.showDirection){const n={x:Math.cos(u),y:Math.sin(u)},r={x:n.y,y:-n.x};let o=e+p*n.x,i=t+p*n.y,s=o+.6*p*r.x,a=i+.6*p*r.y,l=s+.2*p*n.x,c=a+.2*p*n.y;({x:o,y:i}=f.convertLocalToSurface(o,i)),({x:s,y:a}=f.convertLocalToSurface(s,a)),({x:l,y:c}=f.convertLocalToSurface(l,c)),w.fillStyle=w.strokeStyle,w.beginPath(),w.moveTo(o,i),w.lineTo(s,a),w.lineTo(l,c),w.closePath(),w.fill(),w.stroke()}if(c.show){let e=a?Ne(n):n;const t=c.transform?c.transform(e,a):"";this.#k(c.textStyle),this.#z(c.outline),w.fillStyle=c.fillStyle,w.strokeStyle=c.strokeStyle,w.strokeText(t,h,y),w.fillText(t,h,y)}w.restore()}drawArc(e,t,n,r=0,i=2*Math.PI,s={}){s=o(an.geo.arc,s);let{fillStyle:a,strokeStyle:l,outline:c,closeArc:f}=s;const p=this.context,u=this.coordinateMapper;p.save(),p.fillStyle=a,p.strokeStyle=l,this.#z(c),({x:e,y:t}=u.convertLocalToSurface(e,t)),n*=u.scalingLocalToSurface(),p.beginPath(),p.arc(e,t,n,u.convertLocalAngleToSurface(r),u.convertLocalAngleToSurface(i),u.isCounterClockwise()),p.fill(),p.stroke(),p.restore()}drawEllipse(e,t,n,r,i,s,a,l={}){l=o(an.geo.arc,l);let{fillStyle:c,strokeStyle:f,outline:p,closeArc:u}=l;const d=this.context,h=this.coordinateMapper;d.save(),d.fillStyle=c,d.strokeStyle=f,this.#z(p),({x:e,y:t}=h.convertLocalToSurface(e,t)),n*=h.scalingLocalToSurface(),r*=h.scalingLocalToSurface(),d.beginPath(),d.ellipse(e,t,n,r,h.convertLocalAngleToSurface(a),h.convertLocalAngleToSurface(i),h.convertLocalAngleToSurface(s),h.isCounterClockwise()),d.fill(),d.stroke(),d.restore()}drawLine(e,t,n,r,i,s,a={}){a=o(an.geo.line,a);let{strokeStyle:l="rgb(0,0,0)",lineStyle:c}=a;const f=this.context,p=this.coordinateMapper;f.save(),f.strokeStyle=l,this.#z(c,an.geo.line.lineStyle);const{p0:u,p1:d}=function(e,t,n,r,o,i,s){const a=e,l=(a.viewportCorners,a.viewportSides),c=r-t,f=o-n,p={x:t,y:n},u={x:r,y:o};let d=i?-1/0:0,h=s?1/0:1;for(let e=0;e<l.length;e++){const t=l[e],n=We(p,u,t.p0,t.p1);n&&(t.n.x*c+t.n.y*f<0?d=Math.max(d,n.ua):h=Math.min(h,n.ua))}return{p0:{x:t+d*c,y:n+d*f},p1:{x:t+h*c,y:n+h*f}}}(this.coordinateMapper,e,t,n,r,i,s);({x:e,y:t}=p.convertLocalToSurface(u.x,u.y)),({x:n,y:r}=p.convertLocalToSurface(d.x,d.y)),f.beginPath(),f.moveTo(e,t),f.lineTo(n,r),f.stroke(),f.restore()}drawBezier(e,t={}){if(e.length>4)throw new Error("Drawing bezier curves only supported up to cubics, got "+(e.length-1));t=o(an.geo.line,t);let{strokeStyle:n="rgb(0,0,0)",lineStyle:r}=t;const i=this.context,s=this.coordinateMapper;i.save(),i.strokeStyle=n,this.#z(r,an.geo.line.lineStyle);const a=e.map((e=>s.convertLocalToSurface(e.x,e.y)));if(i.beginPath(),2===a.length){const[e,t]=a;i.moveTo(e.x,e.y),i.lineTo(t.x,t.y)}else if(3===a.length){const[e,t,n]=a;i.moveTo(e.x,e.y),i.quadraticCurveTo(t.x,t.y,n.x,n.y)}else if(4===a.length){const[e,t,n,r]=a;i.moveTo(e.x,e.y),i.bezierCurveTo(t.x,t.y,n.x,n.y,r.x,r.y)}i.stroke(),i.restore()}drawBezierSpline(e,t,n={}){if(t<1)throw new Error(`Drawing bezier curves only supported starting from degree 1, got ${t}`);if(t>3)throw new Error(`Drawing bezier curves only supported up to cubics, got ${t}`);if((e.length-(t+1))%t!=0)throw new Error("Wrong number of input points");n=o(an.geo.line,n);let{strokeStyle:r="rgb(0,0,0)",lineStyle:i}=n;const s=this.context,a=this.coordinateMapper;s.save(),s.strokeStyle=r,this.#z(i,an.geo.line.lineStyle);const l=e.map((e=>a.convertLocalToSurface(e.x,e.y)));s.beginPath(),s.moveTo(l[0].x,l[0].y);for(let e=1;e<l.length;e+=t)if(1===t){const[t]=[l[e]];s.lineTo(t.x,t.y)}else if(2===t){const[t,n]=[l[e],l[e+1]];s.quadraticCurveTo(t.x,t.y,n.x,n.y)}else if(3===t){const[t,n,r]=[l[e],l[e+1],l[e+2]];s.bezierCurveTo(t.x,t.y,n.x,n.y,r.x,r.y)}s.stroke(),s.restore()}drawLineStrip(e,t={}){if(e.length<2)return;t=o(an.geo.line,t);let{strokeStyle:n="rgb(0,0,0)",lineStyle:r}=t;const i=this.context,s=this.coordinateMapper;i.save(),i.strokeStyle=n,this.#z(r,an.geo.line.lineStyle),i.beginPath();const a=s.convertLocalToSurface(e[0].x,e[0].y);i.moveTo(a.x,a.y);for(let t=1;t<e.length;t++){let n=e[t];n=s.convertLocalToSurface(n.x,n.y),i.lineTo(n.x,n.y)}i.stroke(),i.restore()}drawPolygon(e,t={}){if(e.length<2)return;t=o(an.geo.polygon,t);let{strokeStyle:n,fillStyle:r,lineStyle:i}=t;const s=this.context,a=this.coordinateMapper;s.save(),s.strokeStyle=n,s.fillStyle=r,this.#z(i,an.geo.line.lineStyle),s.beginPath();const l=a.convertLocalToSurface(e[0].x,e[0].y);s.moveTo(l.x,l.y);for(let t=1;t<e.length;t++){let n=e[t];n=a.convertLocalToSurface(n.x,n.y),s.lineTo(n.x,n.y)}s.closePath(),s.stroke(),s.fill(),s.restore()}drawVector(e,t,n,r,i={}){i=o(an.geo.vector,i);let{shaft:s,arrow:a}=i;const l=this.context,c=this.coordinateMapper;({x:e,y:t}=c.convertLocalToSurface(e,t)),({x:n,y:r}=c.convertLocalToSurface(n,r));const f=n-e,p=r-t,u=f*f+p*p;if(u<1)return;const d=Math.sqrt(u);let h,y,m,g;if(a.sizeRelative?(h=-a.width*p,y=a.width*f):(h=-a.width*p/d,y=a.width*f/d),a.sizeRelative){const n=1-a.length;m=e+n*f,g=t+n*p}else m=n-a.length*f/d,g=r-a.length*p/d;l.save(),this.#z(s.lineStyle),l.strokeStyle=s.strokeStyle,l.beginPath(),l.moveTo(e,t),l.lineTo(m,g),l.stroke(),this.#z(a.lineStyle),l.strokeStyle=a.strokeStyle,l.fillStyle=a.fillStyle,l.beginPath(),l.moveTo(n,r),l.lineTo(m+h,g+y),l.lineTo(m-h,g-y),l.closePath(),l.fill(),l.stroke(),l.restore()}}class yn{#T=[];#I=[];#L=[];#C;#j=-1;#N=-1;#V=-1;#R=-1;constructor(e,t=null){this.drawFunc=t,this.scene=e,this.#C=!1,this.stopped=!1,this.#T=[],this.#I=[],this.#L=[],this.#j=this.scene.registerCallback(sn.EVENT_UPDATE,(e=>{this.#T.push(e.index),this.requestDraw()})),this.#N=this.scene.registerCallback(sn.EVENT_REMOVE,(e=>{this.#I.push(e.index),this.requestDraw()})),this.#V=this.scene.registerCallback(sn.EVENT_PROPERTY,(e=>{this.#L.push(e.index),this.requestDraw()})),this.requestDraw()}setDrawFunc(e){this.drawFunc=e}stop(){this.stopped=!0}start(){this.start=!0,this.requestDraw()}requestDraw(){this.stopped||this.#C||(this.#C=!0,this.#R=window.requestAnimationFrame((()=>{this.drawFunc&&this.drawFunc(this.scene,[...this.#T],[...this.#I],[...this.#L]),this.#R=-1,this.#C=!1,this.#T=[],this.#I=[],this.#L=[]})))}draw(){this.drawFunc&&this.drawFunc(this.scene,[...this.#T],[...this.#I],[...this.#L]),this.#C=!1,this.#T=[],this.#I=[],this.#L=[]}disconnect(){this.#R>=0&&(window.cancelAnimationFrame(this.#R),this.#R=-1),this.scene.removeCallback(sn.EVENT_UPDATE,this.#j),this.scene.removeCallback(sn.EVENT_REMOVE,this.#N),this.scene.removeCallback(sn.EVENT_PROPERTY,this.#V),this.#j=-1,this.#N=-1,this.#V=-1}}class mn extends yn{#B;#F=[0,0];#W=null;constructor(e,t,{bg:n=cn,autoResize:r=null}={}){if(super(e),this.bg=n,this.#W=t,this.#F=[t.canvas.width,t.canvas.height],this.setDrawFunc((e=>function(e,t,{bg:n=cn}={}){t.clear(),t.drawBackground(n);const r=[];for(const t of e.view({skipInvalidValues:!0})){const e=t.value instanceof Array?t.value:[t.value],{properties:n={}}=t;if(n.invisible)continue;const{style:o,z:i=0}=n;for(let t=0;t<e.length;t++){const n=e[t];r.push({val:n,z:i,style:o})}}r.sort(((e,t)=>t.z-e.z));for(let e=0;e<r.length;e++){const{val:n,style:o}=r[e];if(n.type===Y)t.drawPoint(n.x,n.y,o);else if(n.type===H){const{p0:e,p1:r}=n;t.drawLine(e.x,e.y,r.x,r.y,n.leftOpen,n.rightOpen,o)}else if(n.type===J){const{ref:e,x:r,y:i}=n;t.drawVector(e.x,e.y,e.x+r,e.y+i,o)}else if(n.type===X){const{center:e,r,startAngle:i,endAngle:s}=n;t.drawArc(e.x,e.y,r,i,s,o)}else if(n.type===U){const{ref:e,value:r,start:i}=n;t.drawAngle(e.x,e.y,r,i,o)}else if(n.type===ne){const{text:e,ref:r}=n;t.drawText(r.x,r.y,e,o)}else if(n.type===Q){const{points:e}=n;t.drawLineStrip(e,o)}else if(n.type===K){const{points:e}=n;t.drawPolygon(e,o)}else if(n.type===ee){const{points:e}=n;t.drawBezier(e,o)}else if(n.type===te){const{points:e,degree:r}=n;t.drawBezierSpline(e,r,o)}else if(n.type===Z){const{center:e,rx:r,ry:i,startAngle:s,endAngle:a,rotation:l}=n;t.drawEllipse(e.x,e.y,r,i,s,a,l,o)}}}(e,this.#W,{bg:this.bg}))),r){const{minWidth:e=1,keepAspect:t=!1,widthFactor:n=.9,target:o}=r;if(!o)throw new Error("Container must be specified for auto resize");this.#B=new ResizeObserver((r=>{for(const i of r)if(i.target===o){let r=i.contentBoxSize.reduce(((e,t)=>Math.max(e,t.inlineSize)),0);const o=this.#F[0]/this.#F[1];let s=r*n;if(s<e)return;const a=this.#W.canvas;a.width=s,t&&(a.height=s/o),this.#F=[a.width,a.height],this.#W.notifyCanvasSizeChanged(),this.draw()}})),this.#B.observe(o)}}disconnect(){super.disconnect(),this.#B&&this.#B.disconnect()}}const gn=(...e)=>{const t=document.createElement("div");for(let n of e)t.appendChild(n);return t},wn=e=>{const t=document.createElement("input");return t.type="checkbox",t.checked=e,t},xn=e=>{const t=((...e)=>{const t=document.createElement("span");for(let n of e)t.appendChild(n);return t})();return t.textContent=e,t},bn=(e,t,n)=>{const r=document.createElement("input");return r.type="range",r.min=e,r.max=t,r.value=n,r};function vn(e,t){new MutationObserver(((n,r)=>{for(const o of n)if("childList"===o.type)for(const n of o.removedNodes)n===e&&(t(),r.disconnect())})).observe(document.body,{attributes:!0,subtree:!0,childList:!0})}function An(e,t){const n=new sn,r=new hn({x0:-3,y0:-3,x1:3,y1:3,flipY:!0,canvas:t}),o=new mn(n,r,{bg:fn,autoResize:{target:e,keepAspect:!1,minWidth:t.width/2,widthFactor:.8}}),i={r:8,fillStyle:"rgb(128,128,128)"},s=n.add(new zt(-2,-2),ce,{z:0,style:i}),a=n.add(new zt(1,0),ce,{z:0,style:i}),l=n.add(new zt(2,2),ce,{z:0,style:i}),c=n.add(new yt,yt.fromPoints(s,a),{z:2,style:{shaft:{strokeStyle:"rgb(255,0,0)",lineStyle:{lineWidth:2}},arrow:{strokeStyle:"rgb(255,0,0)",fillStyle:"rgb(255,0,0)"}}}),f=n.add(new yt,yt.fromPoints(a,l),{z:2,style:{shaft:{strokeStyle:"rgb(0,0,255)",lineStyle:{lineWidth:2}},arrow:{strokeStyle:"rgb(0,0,255)",fillStyle:"rgb(0,0,255)"}}}),p=(n.add(new yt,yt.fromPoints(s,l),{z:1,style:{shaft:{},arrow:{width:.025}}}),n.add(new St(!0))),u=n.add(new Pt,Pt.fromCondition(s,p),{invisible:!0}),d=n.add(new yt,yt.fromRefVector({ref:u,v:f}),{z:2,style:{shaft:{strokeStyle:"rgba(0,0,255,0.5)",lineStyle:{lineWidth:2}},arrow:{strokeStyle:"rgba(0,0,255,0.5)",fillStyle:"rgba(0,0,255,0.5)"}}}),h=n.add(new zt,zt.fromPointOrVector(d),{z:0,invisible:!0}),y=(n.add(new yt,yt.fromRefVector({ref:h,v:c}),{z:2,style:{shaft:{strokeStyle:"rgba(255,0,0,0.5)",lineStyle:{lineWidth:2}},arrow:{strokeStyle:"rgba(255,0,0,0.5)",fillStyle:"rgba(255,0,0,0.5)"}}}),un.createForPoints(n,r.coordinateMapper,r.canvas,[s,a,l],40));vn(t,(()=>{y.detach(),o.disconnect()}));const m=wn(n.get(p).value.value);m.onchange=e=>{n.update(p,new St(m.checked))},e.appendChild(gn(xn("Show reverse order:"),m))}function Sn(e,t){const n=new sn,r=new hn({x0:-3,y0:-3,x1:3,y1:3,flipY:!0,canvas:t}),s=new mn(n,r,{bg:fn,autoResize:{target:e,keepAspect:!1,minWidth:t.width/2,widthFactor:.8}}),a=!0,l={r:8,fillStyle:"rgb(128,128,128)"},c=n.add(new zt(0,0),ce,{z:0,style:l}),f=n.add(new zt(1,1),ce,{z:0,style:l}),p=n.add(new yt,yt.fromPoints(c,f),{z:2,style:{shaft:{lineStyle:{lineWidth:4}}}}),u=n.add(new At(1)),d=e=>{const{v:t,ref:n,scale:r}=e;return ye(i.add(n,i.scale(t,r.value)))},h=n.add(new Vt(d),Vt.from({ref:c,v:p,scale:u}),{invisible:a}),y={shaft:{strokeStyle:"red",lineStyle:{lineWidth:2}},arrow:{strokeStyle:"red",fillStyle:"red"}},m={shaft:{strokeStyle:"blue",lineStyle:{lineWidth:2}},arrow:{strokeStyle:"blue",fillStyle:"blue"}},g=n.add(new yt,yt.fromPoints(c,h),{z:1,style:o(y)});n.registerCallback(sn.EVENT_UPDATE,(e=>{e.index===u&&(n.get(e.index).value.value<0?n.updateProperties(g,{style:m}):n.updateProperties(g,{style:y}))}));const w=n.add(new mt({normalize:!0}),mt.fromVector({v:p,ref:c}),{invisible:a}),x=n.add(new At(-.5)),b=n.add(new Vt(d),Vt.from({ref:c,v:w,scale:x}),{invisible:a}),v=new Intl.NumberFormat("en-US",{minimumFractionDigits:0,maximumFractionDigits:1});n.add(new Et({text:e=>`Scale: ${v.format(e.value)}`}),Et.fromObjectRef({obj:u,ref:b}),{style:{textStyle:{font:"20px sans-serif"}}});let A=0,S=(new Date).getTime();const P=()=>{let e=(new Date).getTime();const t=(e-S)/1e3;S=e,A+=t/5,n.update(u,new At(2*Math.cos(2*Math.PI*A))),window.requestAnimationFrame(P)};P();const M=un.createForPoints(n,r.coordinateMapper,r.canvas,[c,f],40);vn(t,(()=>{M.detach(),s.disconnect()}))}function Pn(e,t){const n=new sn,r=new hn({x0:-3,y0:-3,x1:3,y1:3,flipY:!0,canvas:t}),o=new mn(n,r,{bg:fn,autoResize:{target:e,keepAspect:!1,minWidth:t.width/2,widthFactor:.8}}),s=!0,a={r:8,fillStyle:"rgb(128,128,128)"},l=n.add(new zt(-1,-1),ce,{z:0,style:a}),c=n.add(new zt(1,1),ce,{z:0,style:a}),f=n.add(new yt,yt.fromPoints(l,c),{z:1,style:{shaft:{lineStyle:{lineWidth:4}}}}),p=n.add(new yt({x:1,y:0}),ce,{invisible:s}),u=n.add(new Rt({leftOpen:!0,rightOpen:!0}),Rt.fromPointVector(l,p),{invisible:s}),d=n.add(new gt,gt.fromVectorsOrLine({v:p,ref:c}),{invisible:s}),h=n.add(new Xt,Xt.fromObjects(u,d),{invisible:s}),y=n.add(new Rt,Rt.fromPoints(l,h),{z:2,style:{strokeStyle:"red",lineStyle:{lineWidth:4}}}),m=n.add(new Rt,Rt.fromPoints(h,c),{z:2,style:{strokeStyle:"blue",lineStyle:{lineWidth:4}}}),g=n.add(new jt,jt.fromObject(f),{invisible:s}),w=n.add(new jt,jt.fromObject(y),{invisible:s}),x=n.add(new jt,jt.fromObject(m),{invisible:s}),b=n.add(new jt,jt.fromPoints(l,h,c),{invisible:s}),v=new Vt((e=>{const{p0:t,p1:n,nref:r,ref:o}=e,s=i.sub(n,t);let a=i.normal2D(s);const l=i.sub(t,r);return i.dot(l,a)<0&&(a=i.scale(a,-1)),a=i.normalizeIfNotZero(a),ge({x:a.x,y:a.y,ref:o})})),A=n.add(v,Vt.from({p0:l,p1:c,nref:b,ref:g}),{invisible:s}),S=n.add(v,Vt.from({p0:l,p1:h,nref:b,ref:w}),{invisible:s}),P=n.add(v,Vt.from({p0:h,p1:c,nref:b,ref:x}),{invisible:s}),M=new Vt((e=>{const t=e[0];return ye(i.add(t.ref,i.scale(t,.4)))})),E=n.add(M,Vt.from([A]),{invisible:s}),O=n.add(M,Vt.from([S]),{invisible:s}),D=n.add(M,Vt.from([P]),{invisible:s}),z=(n.add(new Ot,Ot.fromPoints(l,h,c,Ot.USE_SMALLER_ANGLE),{style:{r:30,arc:{showDirection:!1},text:{textStyle:{font:"15px sans-serif"}}}}),new Intl.NumberFormat("en-US",{minimumFractionDigits:0,maximumFractionDigits:1})),k=e=>t=>`${e} ${z.format(t.value)}`,T=n.add(new $t,$t.fromPoints(l,c)),I=n.add(new $t,$t.fromPoints(l,h)),L=n.add(new $t,$t.fromPoints(h,c)),C=(n.add(new Et({text:k("|c|² = ")}),Et.fromObjectRef({obj:T,ref:E}),{z:0,style:{strokeStyle:"rgb(255,255,255)",textStyle:{font:"bold 15px sans-serif"},outline:{lineWidth:6}}}),n.add(new Et({text:k("|a|² = ")}),Et.fromObjectRef({obj:I,ref:O}),{z:0,style:{strokeStyle:"rgb(255,255,255)",fillStyle:"red",textStyle:{font:"bold 15px sans-serif"},outline:{lineWidth:6}}}),n.add(new Et({text:k("|b|² = ")}),Et.fromObjectRef({obj:L,ref:D}),{z:0,style:{strokeStyle:"rgb(255,255,255)",fillStyle:"blue",textStyle:{font:"bold 15px sans-serif"},outline:{lineWidth:6}}}),n.add(new Vt((e=>he(e[0].value+e[1].value))),Vt.from([I,L]))),j=(n.add(new Et({text:k("|a|² + |b|² = "),ref:{x:-.5,y:2.5}}),Et.fromObjectRef({obj:C}),{z:0,style:{strokeStyle:"rgb(255,255,255)",fillStyle:"black",textStyle:{font:"bold 20px sans-serif",textAlign:"end"},outline:{lineWidth:6}}}),n.add(new Et({text:k("|c|² = "),ref:{x:-.5,y:2}}),Et.fromObjectRef({obj:T}),{z:0,style:{strokeStyle:"rgb(255,255,255)",fillStyle:"black",textStyle:{font:"bold 20px sans-serif",textAlign:"end"},outline:{lineWidth:6}}}),un.createForPoints(n,r.coordinateMapper,r.canvas,[l,c],40));vn(t,(()=>{j.detach(),o.disconnect()}))}function Mn(e,t){const n=new sn,r=new hn({x0:-3,y0:-3,x1:3,y1:3,flipY:!0,canvas:t}),o=new mn(n,r,{bg:cn,autoResize:{target:e,keepAspect:!1,minWidth:t.width/2,widthFactor:.8}}),s=!0,a={r:8,fillStyle:"rgb(128,128,128)"},l=n.add(new zt(0,0),ce,{z:0,style:a}),c=n.add(new zt(2.5,0),ce,{z:0,style:a}),f=n.add(new zt(1,1),ce,{z:0,style:a}),p=[l,c,f],u=n.add(new St(!0)),d=n.add(new St(!0)),h=p.map((e=>n.add(new Pt,Pt.fromCondition(e,u),{invisible:s}))),y=p.map((e=>n.add(new Pt,Pt.fromCondition(e,d),{invisible:s}))),m=n.add(new St(!1)),g=n.add(new St(!1)),w=[n.add(new yt,yt.fromPoints(p[0],p[1],m),{z:1,style:{shaft:{lineStyle:{lineWidth:4}}}}),n.add(new yt,yt.fromPoints(p[0],p[2],g),{z:1,style:{shaft:{lineStyle:{lineWidth:4}}}})],x=w.map((e=>n.add(new Pt,Pt.fromCondition(e,u),{invisible:s}))),b=w.map((e=>n.add(new Pt,Pt.fromCondition(e,d),{invisible:s}))),v={lineStyle:{lineWidth:2,lineDash:[5]}},A=(n.add(new Ot,Ot.fromPoints(p[1],p[0],p[2],Ot.USE_SMALLER_ANGLE),{z:0,style:{r:40,arc:{showDirection:!1},text:{radius:.75,strokeStyle:"rgb(255,255,255)",fillStyle:"black",textStyle:{font:"bold 15px sans-serif",textAlign:"center"},outline:{lineWidth:6}}}}),(e,t,r,o,a,l)=>{const c=n.add(new zt,zt.fromPointOrVector(e),{invisible:s}),f=n.add(new zt,zt.fromPointOrVector(t),{invisible:s}),p=n.add(new Rt({leftOpen:!0,rightOpen:!0}),Rt.fromVector(e),{z:2,style:v}),u=n.add(new gt,gt.fromVectorsOrLine({v:p,ref:f}),{z:2,invisible:s}),d=n.add(new Xt,Xt.fromObjects(p,u),{invisible:s}),h=(n.add(new Ot,Ot.fromPoints(r[0],d,f,Ot.USE_SMALLER_ANGLE),{z:3,style:{arc:{showDirection:!1,fillStyle:"rgba(128,128,128,0.1)"},text:{radius:.5,transform:()=>".",textStyle:{font:"15px bold sans-serif"},textAlign:"center",textBaseline:"middle"}}}),n.add(new Rt,Rt.fromPoints(d,f),{z:2,style:{strokeStyle:"rgb(128,128,128)",lineStyle:{lineWidth:2,lineDash:[5]}}}),n.add(new Vt((e=>{const{a:t,b:n}=e;return he(i.dot(t,n))})),Vt.from({a:e,b:t}))),y=n.add(new St,St.fromPredicate((e=>e[0].value<0),[h])),m=n.add(new St,St.fromNot(y)),g={z:1,style:{strokeStyle:"rgb(255,0,0)",lineStyle:{lineWidth:2}}},w={z:1,style:{strokeStyle:"rgb(0,0,255)",lineStyle:{lineWidth:2}}},x=n.add(new Rt,Rt.fromPoints(r[0],d),g),b=n.add(new Ut,Ut.fromVectorOrLine(e)),A=n.add(new Ut,Ut.fromPoints(r[0],d)),S=n.add(new Vt((e=>he(e[0].value*e[1].value*(e[2].value?1:-1)))),Vt.from([b,A,m])),P=n.add(new yt({normalize:!0}),yt.fromPoints(f,d),{invisible:s}),M=n.add(new Vt((e=>ge(i.scale(e[0],e[1].value)))),Vt.from([P,b]),{invisible:s}),E=new Gt(new yt,(e=>zt.fromPointOrVector(e)),new zt),O=n.add(E,yt.fromRefVector({v:M,ref:r[0]}),{invisible:s}),D=n.add(E,yt.fromRefVector({v:M,ref:d}),{invisible:s}),z={z:3,style:{strokeStyle:"rgb(255,0,0)",fillStyle:"rgba(255,0,0,0.25)"}},k={z:3,style:{strokeStyle:"rgb(0,0,255)",fillStyle:"rgb(0,0,255,0.25)"}},T=n.add(new Ft,Ft.fromPoints([r[0],O,D,d]),z),I=n.add(new jt,jt.fromPoints(r[0],O,D,d),{invisible:s});n.registerCallback(sn.EVENT_UPDATE,(e=>{e.index===y&&(n.get(e.index).value.value?(n.setProperties(x,w),n.setProperties(T,k)):(n.setProperties(x,g),n.setProperties(T,z)))}));const L=n.add(new en(.75),en.fromObjects(r[0],d),{invisible:s}),C=(n.add(new Et({text:`|${l[1]}|cos α`}),Et.fromObjectRef({ref:L}),{invisible:!0,z:0,style:{strokeStyle:"rgb(255,255,255)",fillStyle:"black",textStyle:{font:"bold 15px sans-serif",textAlign:"center"},outline:{lineWidth:6}}}),n.add(new jt,jt.fromPoints(r[0],O),{invisible:s})),j=n.add(new jt,jt.fromPoints(O,D),{invisible:s});n.add(new Ht,Ht.fromCenterAndPoints(r[0],O,c,Ot.USE_SMALLER_ANGLE),{z:2,style:{strokeStyle:"rgba(0,0,0,0.75)",outline:{lineDash:[10]}}}),n.add(new Et,Et.fromObjectRef({obj:S,ref:I}),{z:-1,style:{strokeStyle:"rgb(255,255,255)",fillStyle:"black",textStyle:{font:"bold 15px sans-serif",textAlign:"center"},outline:{lineWidth:6}}}),n.add(new Et,Et.fromObjectRef({obj:b,ref:C}),{z:0,style:{strokeStyle:"rgb(255,255,255)",fillStyle:"black",textStyle:{font:"bold 10px sans-serif",textAlign:"center"},outline:{lineWidth:6}}}),n.add(new Et,Et.fromObjectRef({obj:A,ref:j}),{z:0,style:{strokeStyle:"rgb(255,255,255)",fillStyle:"black",textStyle:{font:"bold 10px sans-serif",textAlign:"center"},outline:{lineWidth:6}}})});A(x[0],x[1],[h[0],h[1]],(h[0],h[2]),0,["u","v"]),A(b[1],b[0],[y[0],y[2]],(y[0],y[1]),0,["v","u"]);const S=un.createForPoints(n,r.coordinateMapper,r.canvas,[l,c,f],40);vn(t,(()=>{S.detach(),o.disconnect()}));const P=wn(n.get(u).value.value);P.onchange=e=>{n.update(u,new St(P.checked))},e.appendChild(gn(xn("Display projection on u:"),P));const M=wn(n.get(d).value.value);M.onchange=e=>{n.update(d,new St(M.checked))},e.appendChild(gn(xn("Display projection on v:"),M));const E=wn(n.get(m).value.value);E.onchange=e=>{n.update(m,new St(E.checked))},e.appendChild(gn(xn("Normalize u:"),E));const O=wn(n.get(g).value.value);O.onchange=e=>{n.update(g,new St(O.checked))},e.appendChild(gn(xn("Normalize v:"),O))}function En(e,n){const r=new sn,o=new hn({x0:-2,y0:-2,x1:2,y1:2,flipY:!0,canvas:n}),i=new mn(r,o,{bg:cn,autoResize:{target:e,keepAspect:!1,minWidth:n.width/2,widthFactor:.8}}),s=!0,{DefPoint:a,DefVector:l,DefAngle:c,DefLine:f,DefArc:p,DefChainApply:u,DefIntersection:d,DefClosestPoint:h,DefParallelLine:y,DefMidPoint:m,DefText:g,DefFunc:w,makePoint:x}=t,b=r.add(new a(0,0),null,{}),v=r.add(new l({x:1,y:0}),l.fromRefVector({ref:b}),{invisible:s}),A=r.add(new a,a.fromPointOrVector(v),{invisible:s}),S=r.add(new l({x:0,y:1,ref:{x:0,y:1}}),l.fromRefVector({ref:b}),{invisible:s}),P=r.add(new f({leftOpen:!0,rightOpen:!0}),f.fromVector(v)),M=r.add(new f({leftOpen:!0,rightOpen:!0}),f.fromVector(S)),E=r.add(new p({r:1}),p.fromValues({center:b})),O=r.add(new u(new d,(e=>e[1])),d.fromObjects(E,P),{invisible:s}),D=r.add(new u(new d,(e=>e[1])),d.fromObjects(E,M),{invisible:s}),z=r.add(new a(0,0),ce,{invisible:s});{const e=r.get(b);r.update(z,new a(e.value.x+1,e.value.y))}const k=r.add(new h,h.fromObject(z,E),{style:{r:6}}),T=(r.add(new l,l.fromPoints(b,k)),r.add(new f({leftOpen:!0,rightOpen:!0}),f.fromPoints(b,k),{z:2,style:{strokeStyle:"rgba(0,0,0,0.25)",lineStyle:{lineDash:[4]}}})),I=r.add(new h,h.fromObject(k,P),{invisible:s}),L=r.add(new h,h.fromObject(k,M),{invisible:s}),C=(r.add(new f,f.fromPoints(I,k),{style:{lineStyle:{lineDash:[4]}}}),r.add(new f,f.fromPoints(L,k),{style:{lineStyle:{lineDash:[4]}}}),r.add(new c,c.fromPoints(A,b,k),{style:{r:40,text:{radius:.35,transform:(e,t)=>"α",textStyle:{font:"20px bold sans-serif"}}}}),r.add(new f,f.fromPoints(b,I),{style:{strokeStyle:"rgb(255,0,0)",lineStyle:{lineWidth:2}}})),j=r.add(new f,f.fromPoints(b,L),{style:{strokeStyle:"rgb(0,0,255)",lineStyle:{lineWidth:2}}}),N=r.add(new y,y.fromVectorsOrLineRef({v:M,ref:O}),{style:{strokeStyle:"rgba(0,0,0,0.1)"}}),V=r.add(new y,y.fromVectorsOrLineRef({v:P,ref:D}),{style:{strokeStyle:"rgba(0,0,0,0.1)"}}),R=r.add(new d,d.fromObjects(T,N),{invisible:s}),B=r.add(new d,d.fromObjects(T,V),{invisible:s}),F=r.add(new h,h.fromObject(R,P),{invisible:s}),W=r.add(new h,h.fromObject(B,M),{invisible:s}),_=(r.add(new f,f.fromPoints(F,R),{style:{strokeStyle:"rgb(0,255,0)",lineStyle:{lineWidth:2}}}),r.add(new f,f.fromPoints(W,B),{style:{strokeStyle:"rgb(0,255,255)",lineStyle:{lineWidth:2}}}),r.add(new m,m.fromObject(C),{invisible:s})),q=r.add(new m,m.fromObject(j),{invisible:s}),$=(r.add(new g({text:"cos"}),g.fromObjectRef({ref:_}),{style:{fillStyle:"rgb(255,0,0)",strokeStyle:"rgba(0,0,0,0)",offset:{x:-.2,y:-.2},textStyle:{font:"20px bold sans-serif"}}}),r.add(new g({text:"sin"}),g.fromObjectRef({ref:q}),{style:{fillStyle:"rgb(0,0,255)",strokeStyle:"rgba(0,0,0,0)",offset:{x:-.4,y:0},textStyle:{font:"20px bold sans-serif"}}}),(e,t,n,r)=>{const o=e[r]-n[r],i=t[r]-n[r],s={x:e.x,y:e.y};return Math.sign(o)*Math.sign(i)<0&&(s[r]-=n[r],s[r]*=-1,s[r]+=n[r]),s}),U=r.add(new h,h.fromObject(k,N),{invisible:s}),Y=r.add(new w((e=>{const{p:t,ref:n,orig:r}=e,o=$(t,n,r,"y");return x({x:o.x,y:o.y})})),w.from({p:U,ref:R,orig:b}),{invisible:s}),G=r.add(new h,h.fromObject(k,V),{invisible:s}),J=r.add(new w((e=>{const{p:t,ref:n,orig:r}=e,o=$(t,n,r,"x");return x({x:o.x,y:o.y})})),w.from({p:G,ref:B,orig:b}),{invisible:s}),H=r.add(new m,m.fromPoints(F,Y),{invisible:s}),Q=r.add(new m,m.fromPoints(W,J),{invisible:s}),K=(r.add(new g({text:"tan"}),g.fromObjectRef({ref:H}),{style:{fillStyle:"rgb(0,255,0)",strokeStyle:"rgba(0,0,0,0)",offset:{x:.2,y:0},textStyle:{font:"20px bold sans-serif"}}}),r.add(new g({text:"cot"}),g.fromObjectRef({ref:Q}),{style:{fillStyle:"rgb(0,255,255)",strokeStyle:"rgba(0,0,0,0)",offset:{x:0,y:.2},textStyle:{font:"20px bold sans-serif"}}}),un.createForPointsAndHandles(r,o.coordinateMapper,o.canvas,[[k,z]],40));vn(n,(()=>{K.detach(),i.disconnect()}))}function On(e,n){const r=new sn,o=new hn({x0:-3,y0:-3,x1:3,y1:3,flipY:!0,canvas:n}),i=new mn(r,o,{bg:cn,autoResize:{target:e,keepAspect:!1,minWidth:n.width/2,widthFactor:.8}}),s=!0,{DefPoint:a,DefAngle:l,DefLine:c,DefArc:f,DefClosestPoint:p,DefText:u,createFromTemplate:d,rad2deg:h}=t,y=r.add(new a(0,0),ce,{invisible:s}),m=r.add(new f({r:2}),f.fromValues({center:y})),g=r.add(new a(0,0),ce,{invisible:s}),w=r.add(new a(0,0),ce,{invisible:s}),x=r.add(new a(0,0),ce,{invisible:s});r.add(new a(0,0),ce,{invisible:s});{const e=r.get(y);r.update(g,new a(e.value.x-1,e.value.y)),r.update(w,new a(e.value.x+1,e.value.y)),r.update(x,new a(e.value.x,e.value.y+1))}const b=r.add(new p,p.fromObject(g,m),{z:-1,style:{r:6}}),v=r.add(new p,p.fromObject(w,m),{z:-1,style:{r:6}}),A=r.add(new p,p.fromObject(x,m),{z:-1,style:{r:6}}),S=[[b,g],[v,w],[A,x]],P=(r.add(new c,c.fromPoints(b,v)),r.add(new c,c.fromPoints(v,A)),r.add(new c,c.fromPoints(A,b)),{lineStyle:{lineDash:[5]}}),M=(r.add(new c,c.fromPoints(y,b),{style:P}),r.add(new c,c.fromPoints(y,v),{style:P}),r.add(new c,c.fromPoints(y,A),{style:P}),{r:40,arc:{showDirection:!1,fillStyle:"rgba(0,0,200,0.35)",strokeStyle:"rgb(0,0,200)"},text:{radius:.5,strokeStyle:"rgba(0,0,0,0)",fillStyle:"rgb(0,0,150)",textStyle:{font:"20px sans-serif"}}}),E={r:40,arc:{showDirection:!1,fillStyle:"rgba(200,0,0,0.35)",strokeStyle:"rgb(200,0,0)"},text:{radius:.5,strokeStyle:"rgba(150,0,0,0)",fillStyle:"rgb(150,0,0)",textStyle:{textAlign:"right",font:"20px sans-serif"}}},O=e=>(t,n)=>e,D=r.add(new l,l.fromPoints(v,b,A),{style:d(M,{text:{transform:O("φ₂")}})}),z=r.add(new l,l.fromPoints(A,v,b),{style:d(E,{text:{transform:O("φ₁")}})}),k=r.add(new l,l.fromPoints(A,y,b),{style:d(E,{text:{transform:O("μ₁")}})}),T=r.add(new l,l.fromPoints(v,y,A),{style:d(M,{text:{transform:O("μ₂")}})}),I=(r.add(new u({text:"A"}),u.fromObjectRef({ref:b}),{style:{offset:{x:-.25,y:0},strokeStyle:"rgba(0,0,0,0)",fillStyle:"rgb(0,0,0)",textStyle:{font:"20px bold sans-serif"}}}),r.add(new u({text:"B"}),u.fromObjectRef({ref:v}),{style:{offset:{x:.25,y:0},strokeStyle:"rgba(0,0,0,0)",fillStyle:"rgb(0,0,0)",textStyle:{font:"20px bold sans-serif"}}}),r.add(new u({text:"P"}),u.fromObjectRef({ref:A}),{style:{offset:{x:0,y:.25},strokeStyle:"rgba(0,0,0,0)",fillStyle:"rgb(0,0,0)",textStyle:{font:"20px bold sans-serif"}}}),r.add(new u({text:"M"}),u.fromObjectRef({ref:y}),{style:{offset:{x:0,y:-.25},strokeStyle:"rgba(0,0,0,0)",fillStyle:"rgb(0,0,0)",textStyle:{font:"20px bold sans-serif"}}}),new Intl.NumberFormat("en-US",{minimumFractionDigits:0,maximumFractionDigits:1})),L=e=>t=>{const n=h(t.value);return`${e} = ${I.format(n)}°`},C={textStyle:{font:"20px sans-serif"}},j=d(C,{strokeStyle:"rgba(0,0,0,0)",fillStyle:"rgb(150,0,0)",textStyle:{textAlign:"center"}}),N=d(C,{strokeStyle:"rgba(0,0,0,0)",fillStyle:"rgb(0,0,150)",textStyle:{textAlign:"center"}}),V=(r.add(new u({text:L("φ₁"),ref:{x:-2,y:2}}),u.fromObjectRef({obj:z}),{style:j}),r.add(new u({text:L("μ₁"),ref:{x:-2,y:1.75}}),u.fromObjectRef({obj:k}),{style:j}),r.add(new u({text:L("φ₂"),ref:{x:2,y:2}}),u.fromObjectRef({obj:D}),{style:N}),r.add(new u({text:L("μ₂"),ref:{x:2,y:1.75}}),u.fromObjectRef({obj:T}),{style:N}),un.createForPointsAndHandles(r,o.coordinateMapper,o.canvas,S,40));vn(n,(()=>{V.detach(),i.disconnect()}))}function Dn(e,n){const r=new sn,o=new hn({x0:-3,y0:-3,x1:3,y1:3,flipY:!0,canvas:n}),i=new mn(r,o,{bg:cn,autoResize:{target:e,keepAspect:!1,minWidth:n.width/2,widthFactor:.8}}),{DefPoint:s,DefAngle:a,DefLine:l,DefArc:c,DefChainApply:f,DefIntersection:p,DefPerpendicularLine:u,DefLength:d,DefInterpolate:h,DefPolarVector:y,DefMidPoint:m,DefPolygon:g,DefBoolean:w,DefConditional:x}=t,b=-3,v=!0,A=[r.add(new s(-2,0),ce,{z:b,style:{r:6,fillStyle:"black"}}),r.add(new s(2,0),ce,{z:b,style:{r:6,fillStyle:"black"}}),r.add(new s(0,2),ce,{z:b,style:{r:6,fillStyle:"black"}})],S=(r.add(new g,g.fromPoints(A),{z:-1}),r.add(new w(!0))),P=A.map((e=>r.add(new x,x.fromCondition(e,S),{invisible:v,z:b}))),M=P.map(((e,t)=>r.add(new l,l.fromPoints(e,P[(t+1)%P.length]),{z:-2}))),E=M.map((e=>r.add(new m,m.fromObject(e),{z:b,style:{fillStyle:"rgb(255,0,0)",r:3}}))).map(((e,t)=>r.add(new u,u.fromVectorsOrLine({ref:e,v:M[t]}),{z:-2,style:{strokeStyle:"rgba(128,0,0,0.5)",lineStyle:{lineWidth:2}}}))),O=r.add(new p,p.fromObjects(E[0],E[1]),{z:b,style:{fillStyle:"rgb(255,0,0)",r:6}}),D=r.add(new d,d.fromPoints(P[0],O)),z=(r.add(new c,c.fromValues({r:D,center:O}),{style:{strokeStyle:"rgba(255,0,0,0.5)",outline:{lineWidth:4}}}),r.add(new w(!0))),k=A.map((e=>r.add(new x,x.fromCondition(e,z),{invisible:v}))),T=k.map(((e,t)=>r.add(new l,l.fromPoints(e,k[(t+1)%k.length]),{invisible:v,z:-2}))),I=k.map(((e,t)=>{const n=k.length,o=(t+n-1)%n,i=(t+1)%n;return r.add(new a,a.fromPoints(k[i],e,k[o],a.USE_SMALLER_ANGLE),{style:{arc:{showDirection:!1},text:{show:!1}}})})).map(((e,t)=>r.add(new h(.5),h.fromAngle(e),{invisible:v}))).map((e=>r.add(new f(new y,(e=>l.fromVector(e)),new l({leftOpen:!0,rightOpen:!0})),y.fromAngle({angle:e}),{style:{strokeStyle:"rgba(0,0,128,0.5)",lineStyle:{lineWidth:1}}}))),L=r.add(new p,p.fromObjects(I[0],I[1]),{z:b,style:{fillStyle:"rgb(0,0,255)",r:6}}),C=r.add(new u,u.fromVectorsOrLine({v:T[0],ref:L}),{z:-2,style:{strokeStyle:"rgba(128,128,128,0.5)",lineStyle:{lineWidth:2,lineDash:[4]}}}),j=r.add(new p,p.fromObjects(C,T[0]),{z:b,style:{fillStyle:"rgb(0,0,255)",r:3}}),N=r.add(new d,d.fromPoints(L,j)),V=(r.add(new c,c.fromValues({r:N,center:L}),{style:{strokeStyle:"rgba(0,0,255,0.5)",outline:{lineWidth:4}}}),un.createForPointsAndHandles(r,o.coordinateMapper,o.canvas,A,40));vn(n,(()=>{V.detach(),i.disconnect()}));const R=wn(r.get(S).value.value);R.onchange=e=>{r.update(S,new w(R.checked))},e.appendChild(gn(xn("Show outcircle: "),R));const B=wn(r.get(z).value.value);B.onchange=e=>{r.update(z,new w(B.checked))},e.appendChild(gn(xn("Show incircle: "),B))}function zn(e,n){const r=new sn,o=new hn({x0:-3,y0:-3,x1:3,y1:3,flipY:!0,canvas:n}),s=new mn(r,o,{bg:cn,autoResize:{target:e,keepAspect:!1,minWidth:n.width/2,widthFactor:.8}}),{DefPoint:a,DefLine:l,DefInterpolate:c,DefBezier:f,DefNumber:p}=t,u=i.vec2,d=[u(-2,-2),u(-2,2),u(2,2),u(2,-2)],h={r:8,fillStyle:"rgb(128,128,128)"},y=d.map((e=>r.add(new a(e.x,e.y),ce,{z:0,style:h}))),m=(r.add(new f,f.fromPoints(y),{z:1}),r.add(new p(.5))),g=["blue","red","cyan"],w=[4,3,2,1],x=[3,3,3,3],b=(e,t,n,o,i)=>{const s=[];for(let t=0;t<e.length-1;t++)s.push(r.add(new l,l.fromPoints(e[t],e[t+1]),{z:2,style:{strokeStyle:n,lineStyle:{lineWidth:o}}}));const a=[];for(let o=0;o<e.length-1;o++)a.push(r.add(new c,c.fromObjects(e[o],e[o+1],t),{z:1,style:{fillStyle:n,r:i,outline:{lineWidth:2}}}));return[s,a]};let v=y,A=0;for(;v.length>1;){let e=g[A],t=x[A],n=w[A];A=(A+1)%g.length;let[r,o]=b(v,m,e,n,t);v=o}const S=un.createForPointsAndHandles(r,o.coordinateMapper,o.canvas,y,40);vn(n,(()=>{S.detach(),s.disconnect()}));const P=bn(0,100,50),M=xn(""),E=new Intl.NumberFormat("en-US",{minimumFractionDigits:0,maximumFractionDigits:2});P.oninput=()=>{const e=(Number.parseInt(P.value)-Number.parseInt(P.min))/(Number.parseInt(P.max)-Number.parseInt(P.min));r.update(m,new p(e)),M.textContent=`t = ${E.format(e)}`},P.oninput(),e.appendChild(gn(P,M))}function kn(e,n){const r=new sn,o=new hn({x0:-1,y0:-3,x1:6,y1:3,flipY:!0,canvas:n}),s=new mn(r,o,{bg:cn,autoResize:{target:e,keepAspect:!1,minWidth:n.width/2,widthFactor:.8}}),{DefPoint:a,DefVector:l,DefLine:c,DefArc:f,DefChainApply:p,DefIntersection:u,DefPolarVector:d,DefNumber:h,DefSelectByKey:y,DefPolarCoord:m,DefNormalVector:g,DefRefraction:w,INVALID:x,deg2rad:b}=t,v=(i.vec2,!0),A=r.add(new a(.5,0),ce,{invisible:v}),S=r.add(new a(3.5,0),ce,{invisible:v}),P=r.add(new h(2.25)),M=r.add(new h(2.25)),E=r.add(new f({r:1.5}),f.fromValues({center:A,r:P}),{invisible:v}),O=r.add(new f({r:1.75}),f.fromValues({center:S,r:M}),{invisible:v}),D=r.add(new u,u.fromObjects(E,O),{invisible:v}),z=r.add(new y(0),y.fromObject(D),{invisible:v}),k=r.add(new y(1),y.fromObject(D),{invisible:v}),T=r.add(new f,f.fromCenterAndPoints(A,z,k),{style:{strokeStyle:"red"}}),I=r.add(new f,f.fromCenterAndPoints(S,k,z),{style:{strokeStyle:"blue"}}),L=(e,t,n,o,i)=>{const s=r.add(new c({rightOpen:!0}),c.fromPointVector(e,t),{invisible:v}),a=r.add(new p(new u,(e=>e[0]?e[0]:x)),u.fromObjects(s,o)),l=r.add(new g({normalize:!0}),g.fromArc(a,o),{invisible:v,style:{shaft:{strokeStyle:"red"}}}),f=r.add(new w({normalize:!0}),w.fromVectorNormal({v:t,n:l,ref:a,eta:i}),{invisible:v,style:{shaft:{strokeStyle:"blue",lineStyle:{lineWidth:4}}}}),d=r.add(new c({rightOpen:!0}),c.fromPointVector(a,f),{invisible:v}),h=r.add(new p(new u,(e=>2===e.length?e[1]?e[1]:x:e[0]?e[0]:x)),u.fromObjects(d,n)),y=r.add(new g({normalize:!0}),g.fromArc(h,n),{invisible:v,style:{shaft:{strokeStyle:"red"}}}),m=r.add(new w({normalize:!0}),w.fromVectorNormal({v:f,n:y,ref:h,eta:i}),{invisible:v,style:{shaft:{strokeStyle:"blue",lineStyle:{lineWidth:4}}}}),b={strokeStyle:"rgb(127,127,127)",lineStyle:{lineWidth:4}};r.add(new c,c.fromPoints(C,a),{z:2,style:b}),r.add(new c,c.fromPoints(a,h),{z:2,style:b}),r.add(new c({rightOpen:!0}),c.fromPointVector(h,m),{z:2,style:b})},C=r.add(new a(-.25,0)),j=r.add(new a(.75,0),ce,{z:0,style:{r:8,fillStyle:"rgba(0,128,128,0.5)",outline:{strokeStyle:"rgba(0,32,32,0.5"}}}),N=r.add(new c({rightOpen:!0}),c.fromPoints(C,j),{invisible:v}),V=r.add(new l({normalized:!0}),l.fromLineSegment(N),{invisible:v}),R=r.add(new m,m.fromPointOrVector(V)),B=(r.add(new h,h.fromField(R,"alpha")),e=>t=>t+e);let F=[];const W=b(25);for(let e=0;e<4;e++){const t=(e+1)/4*W;F.push(t),F.push(-t)}const _=[],q=[];for(const e of F){const t=r.add(new h,h.fromField(R,"alpha",B(e))),n=r.add(new d({r:1}),d.fromRadiusAngle({ref:C,alpha:t}),{invisible:v});_.push(t),q.push(n)}const $=r.add(new h(.7692307692307692));L(C,V,T,I,$);for(let e of q)L(C,e,T,I,$);const U=un.createForPointsAndHandles(r,o.coordinateMapper,o.canvas,[j],1/0);vn(n,(()=>{U.detach(),s.disconnect()}));const Y=bn(0,100,50);Y.oninput=e=>{const t=Number.parseInt(Y.max),n=Number.parseInt(Y.min),o=t-n;let i=(Number.parseInt(Y.value)-n)/o;i=1-i;const s=.5+3*i;r.update(M,new h(s))};const G=bn(0,100,50);G.oninput=e=>{const t=Number.parseInt(G.max),n=Number.parseInt(G.min),o=t-n,i=.5+(Number.parseInt(G.value)-n)/o*3;r.update(P,new h(i))},e.appendChild(gn(xn("Left:"),Y)),e.appendChild(gn(xn("Right:"),G));const J=bn(0,100,50),H=xn(""),Q=new Intl.NumberFormat("en-US",{minimumFractionDigits:0,maximumFractionDigits:2});J.oninput=()=>{const e=1+(Number.parseInt(J.value)-Number.parseInt(J.min))/(Number.parseInt(J.max)-Number.parseInt(J.min))*1,t=1/e;r.update($,new h(t)),H.textContent=`Eta material: ${Q.format(e)}`},J.oninput(),e.appendChild(gn(J,H))}function Tn(e,n){const r=new sn,o=new hn({x0:-4,y0:-4,x1:4,y1:4,flipY:!0,canvas:n}),s=new mn(r,o,{bg:cn,autoResize:{target:e,keepAspect:!1,minWidth:n.width/2,widthFactor:.8}}),{DefPoint:a,DefArc:l,DefEllipse:c,DefTangentLines:f,DefTangentPoints:p,deg2rad:u}=t,d=(i.vec2,r.add(new a(2,0),ce,{z:-1,style:{r:6,fillStyle:"rgb(32,32,32)"}})),h=r.add(new l({center:{x:0,y:0},r:1,startAngle:u(0),endAngle:u(360)}),l.fromValues({center:d})),y=r.add(new l({center:{x:3,y:-2},r:.25,startAngle:u(0),endAngle:u(240)}),l.fromValues({})),m=r.add(new l({center:{x:-2,y:2},r:1.5,startAngle:u(0),endAngle:u(270)}),l.fromValues({})),g=r.add(new c({center:{x:3,y:2},rx:.5,ry:1,startAngle:u(0),endAngle:u(360)}),c.fromValues({})),w=(r.add(new f,f.fromOuterTangents(h,y),{style:{strokeStyle:"red"}}),r.add(new p,p.fromOuterTangents(h,y),{style:{fillStyle:"red"}}),r.add(new f,f.fromInnerTangents(h,y),{style:{strokeStyle:"blue"}}),r.add(new p,p.fromInnerTangents(h,y),{style:{fillStyle:"blue"}}),r.add(new f,f.fromPointArc(d,y),{style:{strokeStyle:"green"}}),r.add(new p,p.fromPointArc(d,y),{style:{fillStyle:"green"}}),r.add(new f,f.fromOuterTangents(h,m),{style:{strokeStyle:"red"}}),r.add(new p,p.fromOuterTangents(h,m),{style:{fillStyle:"red"}}),r.add(new f,f.fromInnerTangents(h,m),{style:{strokeStyle:"blue"}}),r.add(new p,p.fromInnerTangents(h,m),{style:{fillStyle:"blue"}}),r.add(new f,f.fromPointArc(d,m),{style:{strokeStyle:"green"}}),r.add(new p,p.fromPointArc(d,m),{style:{fillStyle:"green"}}),r.add(new f,f.fromPointEllipse(d,g,{leftOpen:!0,rightOpen:!0}),{style:{strokeStyle:"orange"}}),r.add(new p,p.fromPointEllipse(d,g),{style:{fillStyle:"orange"}}),un.createForPointsAndHandles(r,o.coordinateMapper,o.canvas,[d],1/0));vn(n,(()=>{w.detach(),s.disconnect()}))}function In(e,n){const r=new sn,o=new hn({x0:-5,y0:-5,x1:5,y1:5,flipY:!0,canvas:n}),s=new mn(r,o,{bg:cn,autoResize:{target:e,keepAspect:!1,minWidth:n.width/2,widthFactor:.8}}),{DefVector:a,DefLine:l,DefArc:c,DefPolygon:f,DefBoolean:p,DefBezier:u,DefNumber:d,DefEllipse:h,DefLineStrip:y,DefBezierSpline:m,DefCurveNormal:g,DefCurvePoint:w,DefCurveTangent:x,INVALID:b,deg2rad:v}=t,A=i.vec2,S=r.add(new p(!0)),P=r.add(new p(!0)),M=r.add(new d(0)),E=r.add(new d(1)),O=r.add(new d(1)),D=r.add(new a({x:.5,y:-1,ref:{x:-3,y:-2}})),z=r.add(new l({p0:{x:-2,y:-2},p1:{x:-2.1,y:-2.5}})),k=r.add(new y([A(-1,-3),A(-.5,-3.5),A(0,-2),A(-.75,-2.5)])),T=r.add(new f([A(1.5,-3),A(1,-3.5),A(.5,-2),A(1.25,-2.5)])),I=r.add(new u([A(-3,1),A(-1,1.5),A(-1.5,1),A(-3.5,.5)])),L=r.add(new m({points:[A(-2,3),A(-1,2),A(0,2.5),A(-.5,3.5),A(-1,1),A(-1.5,1.5),A(1,1)],degree:2})),C=r.add(new h({center:{x:3,y:3},rx:.5,ry:1,rotation:v(0),startAngle:v(0),endAngle:v(270)}),h.fromValues({rotation:M})),j=r.add(new c({r:.5,center:{x:2.5,y:0},startAngle:v(10),endAngle:v(340)})),N={style:{shaft:{strokeStyle:"rgba(255,0,0,0.5)"},arrow:{fillStyle:"rgba(255,0,0,0.5)",strokeStyle:"rgba(255,0,0,0.5)"}}},V=(r.add(new g,g.fromCurve({obj:D,t:M,normalize:S,scale:E}),N),r.add(new g,g.fromCurve({obj:z,t:M,normalize:S,scale:E}),N),r.add(new g,g.fromCurve({obj:k,t:M,normalize:S,scale:E}),N),r.add(new g,g.fromCurve({obj:T,t:M,normalize:S,scale:E}),N),r.add(new g,g.fromCurve({obj:I,t:M,normalize:S,scale:E}),N),r.add(new g,g.fromCurve({obj:L,t:M,normalize:S,scale:E}),N),r.add(new g,g.fromCurve({obj:j,t:M,normalize:S,scale:E}),N),r.add(new g,g.fromCurve({obj:C,t:M,normalize:S,scale:E}),N),{style:{shaft:{strokeStyle:"rgba(0,255,0,0.5)"},arrow:{fillStyle:"rgba(0,255,0,0.5)",strokeStyle:"rgba(0,255,0,0.5)"}}}),R=(r.add(new x,x.fromCurve({obj:D,t:M,normalize:P,scale:O}),V),r.add(new x,x.fromCurve({obj:z,t:M,normalize:P,scale:O}),V),r.add(new x,x.fromCurve({obj:k,t:M,normalize:P,scale:O}),V),r.add(new x,x.fromCurve({obj:T,t:M,normalize:P,scale:O}),V),r.add(new x,x.fromCurve({obj:I,t:M,normalize:P,scale:O}),V),r.add(new x,x.fromCurve({obj:L,t:M,normalize:P,scale:O}),V),r.add(new x,x.fromCurve({obj:j,t:M,normalize:P,scale:O}),V),r.add(new x,x.fromCurve({obj:C,t:M,normalize:P,scale:O}),V),{style:{r:5,fillStyle:"rgba(0,0,255,0.5)"}});r.add(new w,w.fromCurve({obj:D,t:M}),R),r.add(new w,w.fromCurve({obj:z,t:M}),R),r.add(new w,w.fromCurve({obj:k,t:M}),R),r.add(new w,w.fromCurve({obj:T,t:M}),R),r.add(new w,w.fromCurve({obj:I,t:M}),R),r.add(new w,w.fromCurve({obj:L,t:M}),R),r.add(new w,w.fromCurve({obj:j,t:M}),R),r.add(new w,w.fromCurve({obj:C,t:M}),R);let B=0,F=(new Date).getTime();const W=()=>{let e=(new Date).getTime();const t=(e-F)/1e3;F=e,B+=t/5,r.update(M,new At(B%1)),window.requestAnimationFrame(W)};W(),vn(n,(()=>{s.disconnect()}));const _=wn(r.get(S).value.value);_.onchange=e=>{r.update(S,new St(_.checked))},e.appendChild(gn(xn("Normalize normals:"),_));const q=wn(r.get(P).value.value);q.onchange=e=>{r.update(P,new St(q.checked))},e.appendChild(gn(xn("Normalize tangents:"),q));const $=new Intl.NumberFormat("en-US",{minimumFractionDigits:0,maximumFractionDigits:2}),U=bn(0,100,50),Y=xn("");U.oninput=()=>{let e=(Number.parseInt(U.value)-Number.parseInt(U.min))/(Number.parseInt(U.max)-Number.parseInt(U.min));e*=2,r.update(E,new d(e)),Y.textContent=`Normal scale: ${$.format(e)}`},U.oninput(),e.appendChild(gn(U,Y));const G=bn(0,100,50),J=xn("");G.oninput=()=>{let e=(Number.parseInt(G.value)-Number.parseInt(G.min))/(Number.parseInt(G.max)-Number.parseInt(G.min));e*=2,r.update(O,new d(e)),J.textContent=`Tangent scale: ${$.format(e)}`},G.oninput(),e.appendChild(gn(G,J))}function Ln(e,n){const r=new sn,o=new hn({x0:-2,y0:-2,x1:7,y1:6,flipY:!0,canvas:n}),s=new mn(r,o,{bg:cn,autoResize:{target:e,keepAspect:!1,minWidth:n.width/2,widthFactor:.8}}),{DefPoint:a,DefVector:l,DefLine:c,DefIntersection:f,DefFunc:p,DefLineStrip:u,INVALID:d,makePoint:h,makeLine:y,makePolygon:m,calcAngle:g,calcConvexHull:w}=t,x=i.vec2,b=!0,v=r.add(new a(1.5,2),ce,{});let A=[];A=[.3,.6,.9,1.2];const S=[v];for(let e of A){const t=r.add(new p((t=>{const{orig:n}=t,r=i.add(n,{x:e,y:0});return h(r)})),p.from({orig:v}));S.push(t)}r.add(new l({x:0,y:1}),ce,{invisible:b});const P=r.add(new l({x:0,y:-1}),ce,{invisible:b}),M=(r.add(new a(2,2),ce,{invisible:b}),r.add(new a(2.2,1.5),ce,{invisible:b}),r.add(new a(1,-.5),ce,{invisible:b}),r.add(new a(4,0),ce,{invisible:b}),r.add(new u([x(-1,1),x(1,2),x(2,2),x(2.2,1.5),x(1,-.5),x(4,0),x(5,3)]),ce,{z:3,style:{strokeStyle:"rgba(0,0,0,0.5)",lineStyle:{lineWidth:2}}})),E=(e,t,n)=>{const o=r.add(new c({leftOpen:!1,rightOpen:!0}),c.fromPointVector(t,n)),s=r.add(new f,f.fromObjects(e,o),{invisible:b}),a=r.add(new p((e=>{const{points:t,orig:n}=e;if(0===t.length)return d;let r=0,o=1/0;for(let e=0;e<t.length;e++){const s=i.len2(i.sub(t[e],n));s<o&&(o=s,r=e)}return t[r]})),p.from({points:s,orig:t}),{style:{fillStyle:"rgba(0,0,255,0.5)",r:8}});return{line:o,inter:s,closest:a}};let O=[];for(const e of S)O.push(E(M,e,P));let D=[];for(const e of O)D.push(e.closest);const z=r.add(new p((e=>{const t=e,n=[];for(let e of t)e!==d&&n.push(e);return n})),p.from(D,{},!0),{invisible:b});r.add(new u,u.fromPointArray(z),{z:1,style:{strokeStyle:"rgba(0,0,255,0.5)",lineStyle:{lineWidth:8}}}),r.add(new p((e=>{const{points:t}=e;if(t.length<2)return d;const n=[];for(let e=0;e<t.length;e++)n.push(e);return n.sort(((e,n)=>Math.abs(t[e].ua)-Math.abs(t[n].ua))),y({p0:t[n[0]],p1:t[n[1]]})})),p.from({points:z},{},!0),{z:2,style:{strokeStyle:"red",lineStyle:{lineWidth:15}}}),r.add(new p((e=>{const{points:t}=e;if(t.length<2)return d;let n=[t[0],t[1]],r=e=>{const t=i.sub(e[1],e[0]);return(n=g(t.x,t.y))>Math.PI?n-2*Math.PI:n;var n},o=r(n);for(let e=2;e<t.length;e++){let i=[n[0],t[e]],s=r(i);s>o&&(s=o,n=i)}return y({p0:n[0],p1:n[1],leftOpen:!0,rightOpen:!0})})),p.from({points:z},{},!0),{z:4,style:{strokeStyle:"rgba(128,128,128,0.5",lineStyle:{lineWidth:2,lineDash:[4]}}}),r.add(new p((e=>{const{points:t}=e;return m({points:w(t)})})),p.from({points:z},{},!0),{z:1,style:{strokeStyle:"rgb(0,255,0)",lineStyle:{lineWidth:4}}});const k=un.createForPointsAndHandles(r,o.coordinateMapper,o.canvas,[v],1/0);vn(n,(()=>{k.detach(),s.disconnect()}))}for(let e of Object.keys(n))window[e]=n[e]})();