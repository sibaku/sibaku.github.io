{"version":3,"sources":["App.js","reportWebVitals.js","index.js"],"names":["hidden","visibilityChange","timerWorker","Worker","loadAndPredict","net","img","canvas","a","wi","width","hi","height","ms","Math","max","internalResolution","min","segmentPerson","maxDetections","segmentationThreshold","segmentation","foregroundColor","r","g","b","backgroundColor","backgroundDarkeningMask","bodyPix","getMedia","constraints","stream","navigator","mediaDevices","getUserMedia","video","document","createElement","srcObject","play","console","log","Webcam","useRef","useState","w","h","canvasSize","setCanvasSize","setVideo","videoAvailable","setVideoAvailable","setNet","setImage","startProcessing","setStartProcessing","useEffect","current","load","videoHandler","useCallback","element","eventName","handleEvent","handlerRef","listener","e","addEventListener","removeEventListener","useEventHandler","v","s","im","open","onmessage","getContext","drawImage","postMessage","msg","f","ref","msHidden","webkitHidden","App","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.a8693563.chunk.js","sourcesContent":["import './App.css';\n\nimport * as bodyPix from '@tensorflow-models/body-pix';\nimport { useCallback, useEffect, useRef, useState } from 'react';\n\nlet timerWorker = new Worker('./workers/interval.worker.js');\n\nlet hidden, visibilityChange;\nif (typeof document.hidden !== \"undefined\") { // Opera 12.10 and Firefox 18 and later support\n  hidden = \"hidden\";\n  visibilityChange = \"visibilitychange\";\n} else if (typeof document.msHidden !== \"undefined\") {\n  hidden = \"msHidden\";\n  visibilityChange = \"msvisibilitychange\";\n} else if (typeof document.webkitHidden !== \"undefined\") {\n  hidden = \"webkitHidden\";\n  visibilityChange = \"webkitvisibilitychange\";\n}\n\n\n\nasync function loadAndPredict(net, img, canvas) {\n\n  /**\n   * One of (see documentation below):\n   *   - net.segmentPerson\n   *   - net.segmentPersonParts\n   *   - net.segmentMultiPerson\n   *   - net.segmentMultiPersonParts\n   * See documentation below for details on each method.\n    */\n\n  const wi = img.width;\n  const hi = img.height;\n\n  const ms = Math.max(wi, hi);\n  const internalSize = 320;\n  const internalResolution = Math.min(1.0, internalSize / ms);\n  const segmentation = await net.segmentPerson(img,\n    {\n      internalResolution,\n      maxDetections: 2,\n      segmentationThreshold: 0.8\n    });\n\n  // Convert the segmentation into a mask to darken the background.\n  const foregroundColor = { r: 0, g: 0, b: 0, a: 0 };\n  const backgroundColor = { r: 0, g: 255, b: 0, a: 255 };\n  const backgroundDarkeningMask = bodyPix.toMask(\n    segmentation, foregroundColor, backgroundColor);\n\n  const opacity = 1;\n  const maskBlurAmount = 3;\n  const flipHorizontal = false;\n  // Draw the mask onto the image on a canvas.  With opacity set to 0.7 and\n  // maskBlurAmount set to 3, this will darken the background and blur the\n  // darkened background's edge.\n  bodyPix.drawMask(\n    canvas, img, backgroundDarkeningMask, opacity, maskBlurAmount, flipHorizontal);\n\n}\n\n\nasync function getMedia(constraints) {\n  let stream = null;\n\n  try {\n    stream = await navigator.mediaDevices.getUserMedia(constraints);\n    const video = document.createElement(\"video\");\n    video.srcObject = stream;\n    video.play();\n    return video;\n    /* use the stream */\n  } catch (err) {\n    /* handle the error */\n    console.log(err);\n  }\n}\n\nfunction useEventHandler({ element, eventName, handleEvent }) {\n  const handlerRef = useRef();\n\n  useEffect(() => {\n    handlerRef.current = handleEvent;\n  }, [handleEvent]);\n\n  useEffect(() => {\n    if (!element) {\n      return;\n    }\n    const listener = e => handlerRef.current(e);\n    element.addEventListener(eventName, listener);\n\n    return () => {\n      element.removeEventListener(eventName, listener);\n\n    };\n  }, [element, eventName]);\n}\n\nfunction Webcam() {\n  const canvas = useRef(null);\n  const [canvasSize, setCanvasSize] = useState({ w: 0, h: 0 });\n  const [video, setVideo] = useState(null);\n  const [videoAvailable, setVideoAvailable] = useState(false);\n  const [net, setNet] = useState(null);\n  const [img, setImage] = useState(null);\n\n  const [startProcessing, setStartProcessing] = useState(false);\n\n  useEffect(() => {\n    if (net !== null && video !== null && canvas.current !== null && videoAvailable\n      && img !== null) {\n      // setCanvasSize(()=>({w:video.videoWidth/2,h:video.videoHeight/2}));\n      setStartProcessing(() => true);\n    }\n  }, [net, video, canvas, videoAvailable, img]);\n  useEffect(() => {\n    const load = async () => {\n\n      const net = await bodyPix.load(/** optional arguments, see below **/);\n      console.log(\"finished loading net\");\n      setNet(() => net);\n    };\n    load();\n  }, []);\n\n  const videoHandler = useCallback(() => {\n\n    img.width = 1280 / 2;\n    img.height = 720 / 2;\n    setVideoAvailable(() => true);\n\n  }, [img]);\n\n  useEventHandler({ element: video, eventName: \"loadeddata\", handleEvent: videoHandler });\n \n  useEffect(() => {\n    const open = async () => {\n      const v = await getMedia({ video: { width: 1280, height: 720 } });\n\n      setVideo(() => v);\n      setCanvasSize(s => ({ w: 1280 / 2, h: 720 / 2 }));\n      const im = document.createElement(\"canvas\");\n\n      setImage(() => im);\n    };\n    open();\n  }, []);\n\n  useEffect(() => {\n    if (video === null) {\n      return;\n    }\n  }, [video]);\n\n\n  useEffect(() => {\n    if (!startProcessing) {\n      return;\n    }\n\n\n    timerWorker.onmessage = e => {\n\n      const f = async () => {\n        const ctx = img.getContext(\"2d\");\n        ctx.drawImage(video, 0, 0, img.width, img.height);\n        await loadAndPredict(net, img, canvas.current);\n        timerWorker.postMessage({ msg: 2 });\n      };\n      f();\n\n    };\n    timerWorker.postMessage({ msg: 3 });\n\n    document.addEventListener(visibilityChange, () => {\n      if (document[hidden]) {\n\n        video.play();\n      }\n    }, false);\n\n  }, [startProcessing, img, video, videoAvailable, net]);\n\n  return <canvas width={canvasSize.w} height={canvasSize.h} ref={canvas}></canvas>\n}\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Webcam></Webcam>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}